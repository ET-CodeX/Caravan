//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define DEVICE_ID_AI075 1007

#define AI075_ADDR_CYC_WRITE        16#000
#define AI075_ADDR_CYC_READ         16#080
#define AI075_ADDR_CFG_FIRMWARE     16#100
#define AI075_ADDR_STATE_FIRMWARE   16#180

#define AI075_SDO_RESPONSE_TIMEOUT  SDIAS_SDO_TIMEOUT * 2

#define AI075_LENGTH_STATE_FIRMWARE 2
#define AI075_NUMBER_OF_ANALOG_IN   6
#define AI075_NUMBER_OF_TMP_IN      1
#define AI075_INVALID_VALUE         16#80000010$DINT
#define AI075_CABLE_BREAK_MASK      16#7F  //7 BITS
#define AI075_SHORT_CIRCUIT_MASK    16#03  //2 BITS
#define AI075_SAMPLE_POINT_MASK     16#0F  //4 BITS
#define AI075_OFFSET_SAMPLE_POINT_BITS 11

#define AI075_FIRMWARE_MIN          -10000
#define AI075_FIRMWARE_MAX          10000

//Sample Point Defines
//**************************************************************
#define AI075_FIRMWARE_VERSION_SAMPLE_POINTS_AVAILABLE  16#200
#define AI075_SAMPLE_POINTS_OFFSET_AFTER_SYNC   15    //Minimal offset that a sample point can be set after sync
#define AI075_SAMPLE_POINTS_OFFSET_BEFORE_SYNC  162   //Maximal offset that a sample point can be before next sync
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "AI075"
	Revision           = "1.36"
	GUID               = "{A4EC58ED-10D5-4968-B8E9-92C52BC670E4}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\s-dias.ico"
	SharedCommandTable = "true"
	Objectsize         = "(502,120)"
	Comment            = "SDIAS Analog In Module&#13;&#10;6x Analog In for +- 10V (Analog In 1 can be also used as Temperature Input for KTY or PT1000)&#13;&#10;1x Temperature in for a KTY-Sensor">
	<Channels>
		<Server Name="ActivateSamplePointConfig" GUID="{7330205E-E302-4774-AD77-0ABA5A7DBE66}" Visualized="true" Initialize="true" DefValue="0" WriteProtected="false" Retentive="false" Comment="This server is used to activate and deactivate the sample point configuration in the firmware.&#13;&#10;0 .. deactivate&#13;&#10;1 .. activate."/>
		<Server Name="AI1" GUID="{D60301DD-A18F-4B98-8AD0-500122404F22}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Analog input or temperature input. Status query over read().&#13;&#10;The invalid value in case of cable break or short circuit is 16#80000010."/>
		<Server Name="AI1SamplePoint" GUID="{3D70810C-D732-4C6C-A18A-44ADCACB0255}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="Sample point of the respective analog input in 탎.&#13;&#10;Valid range: (15탎 to (CycleTime - 162탎))&#13;&#10;-1 .. Feature not available or inactive. FW Version must be higher than 1.30 or client ActivateSamplePointConfig has to be 1.,&#13;&#10;-2 .. Invalid input parameter. Value must be between valid range."/>
		<Server Name="AI2" GUID="{FBD61EF2-7CEA-4F9C-B9F7-46D0F4EA9351}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Analog input or temperature input. Status query over read().&#13;&#10;The invalid value in case of cable break or short circuit is 16#80000010."/>
		<Server Name="AI2SamplePoint" GUID="{7FF8F6F0-551C-42B3-896A-CFFF2835F68E}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="Sample point of the respective analog input in 탎.&#13;&#10;Valid range: (15탎 to (CycleTime - 162탎))&#13;&#10;-1 .. Feature not available or inactive. FW Version must be higher than 1.30 or client ActivateSamplePointConfig has to be 1.,&#13;&#10;-2 .. Invalid input parameter. Value must be between valid range."/>
		<Server Name="AI3" GUID="{E97F43EC-F73E-47FB-ACA7-B8CFD1A3FE7B}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Analog input or temperature input. Status query over read().&#13;&#10;The invalid value in case of cable break or short circuit is 16#80000010."/>
		<Server Name="AI3SamplePoint" GUID="{D7465BB4-4210-4E7A-9AAC-3CBD162C8851}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="Sample point of the respective analog input in 탎.&#13;&#10;Valid range: (15탎 to (CycleTime - 162탎))&#13;&#10;-1 .. Feature not available or inactive. FW Version must be higher than 1.30 or client ActivateSamplePointConfig has to be 1.,&#13;&#10;-2 .. Invalid input parameter. Value must be between valid range."/>
		<Server Name="AI4" GUID="{44D868FC-0A04-45BD-9877-EB1A8FFD00FE}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Analog input or temperature input. Status query over read().&#13;&#10;The invalid value in case of cable break or short circuit is 16#80000010."/>
		<Server Name="AI4SamplePoint" GUID="{1DE000AA-5050-471C-BBA0-90DE2F4F9C16}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="Sample point of the respective analog input in 탎.&#13;&#10;Valid range: (15탎 to (CycleTime - 162탎))&#13;&#10;-1 .. Feature not available or inactive. FW Version must be higher than 1.30 or client ActivateSamplePointConfig has to be 1.,&#13;&#10;-2 .. Invalid input parameter. Value must be between valid range."/>
		<Server Name="AI5" GUID="{CF1CE92A-B3B9-4206-BF2F-AF018BC5F98D}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Analog input or temperature input. Status query over read().&#13;&#10;The invalid value in case of cable break or short circuit is 16#80000010."/>
		<Server Name="AI5SamplePoint" GUID="{3C2899E5-30CB-4CF8-8058-9BFB60F4BB24}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="Sample point of the respective analog input in 탎.&#13;&#10;Valid range: (15탎 to (CycleTime - 162탎))&#13;&#10;-1 .. Feature not available or inactive. FW Version must be higher than 1.30 or client ActivateSamplePointConfig has to be 1.,&#13;&#10;-2 .. Invalid input parameter. Value must be between valid range."/>
		<Server Name="AI6" GUID="{74C55139-502F-4A99-BBEA-F5F032D27F7B}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Analog input or temperature input. Status query over read().&#13;&#10;The invalid value in case of cable break or short circuit is 16#80000010."/>
		<Server Name="AI6SamplePoint" GUID="{331E1D65-335E-482B-99B8-22C79EF03E88}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="Sample point of the respective analog input in 탎.&#13;&#10;Valid range: (15탎 to (CycleTime - 162탎))&#13;&#10;-1 .. Feature not available or inactive. FW Version must be higher than 1.30 or client ActivateSamplePointConfig has to be 1.,&#13;&#10;-2 .. Invalid input parameter. Value must be between valid range."/>
		<Server Name="CableBreak" GUID="{5E340F0A-3E71-4A7B-9E8B-9C9B3B8BCDB1}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Cable break detection:&#13;&#10;Bit0...Cable break on AI1&#13;&#10;Bit1...Cable break on AI2&#13;&#10;Bit2...Cable break on AI3&#13;&#10;Bit3...Cable break on AI4&#13;&#10;Bit4...Cable break on AI5&#13;&#10;Bit5...Cable break on AI6&#13;&#10;Bit6...Cable break on TI&#13;&#10;"/>
		<Server Name="FirmwareVersion" GUID="{C8B7272F-EF0A-4E33-AF07-8A3D1044D0A5}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Version of the used firmware&#13;&#10;&#13;&#10;e.g. 16#100 means v1.0"/>
		<Server Name="FWErrorBits" GUID="{BA871004-E66C-4CEF-B404-FB53F4979611}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Firmware Status:&#13;&#10;Bit0...DC not Ok&#13;&#10;Bit1...No Sync&#13;&#10;Bit2...Flash data CRC error&#13;&#10;Bit3...Ram data CRC error&#13;&#10;Bit4...No valid EEPROM Version&#13;&#10;Bit5...Bustime not supported"/>
		<Server Name="OverCurrent" GUID="{5DC45A47-FA5A-4096-907B-ADD442E5C477}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Analog Input Voltage too high"/>
		<Server Name="RefVoltageOK" GUID="{D2239CF2-C803-4849-93ED-EEEF61643C24}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Reference Supply Voltage status."/>
		<Server Name="SamplePointState" GUID="{D7AC9078-45D4-4432-871D-F6739E2DEBBC}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the state bits of the Sample point configuration of the firmware.&#13;&#10;Bit0 ... Samplepoints settings were corrected by firmware due to invalid settings (difference between two sample points too small, 2 sample points have the same value)&#13;&#10;Bit1 ... Samplepoints could not be corrected by firmware&#13;&#10;Bit2 ... Bustime which is set by hardwareclass is invalid&#13;&#10;Bit3 ... Transfered bustime and measured bustime are different.&#13;&#10;"/>
		<Server Name="ShortCircuit" GUID="{3E8C8F44-DF39-4CAC-9EB5-DB59A029ABFF}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Short circuit detection:&#13;&#10;Bit0...Short circuit on AI1 (only temerature input)&#13;&#10;Bit1...Short circuit on TI"/>
		<Server Name="TI" GUID="{DB4A8AED-C411-4FCD-8C3A-647E5D739BFC}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Temperature input. Status query over read().&#13;&#10;The invalid value in case of cable break or short circuit is 16#80000010."/>
		<Server Name="TISamplePoint" GUID="{51B5BB64-DB05-4079-B5D5-EA03CC2E0D14}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="Sample point of the respective analog input in 탎.&#13;&#10;Valid range: (15탎 to (CycleTime - 162탎))&#13;&#10;-1 .. Feature not available or inactive. FW Version must be higher than 1.30 or client ActivateSamplePointConfig has to be 1.,&#13;&#10;-2 .. Invalid input parameter. Value must be between valid range."/>
		<Client Name="AI1_Freq" Required="false" Internal="false" Comment="Cut off frequency for low pass filter&#13;&#10;0... 1000 Hz&#13;&#10;1...  500 Hz&#13;&#10;2...  250 Hz&#13;&#10;3...  100 Hz&#13;&#10;4...   50 Hz&#13;&#10;5...   25 Hz&#13;&#10;6...   10 Hz"/>
		<Client Name="AI1_Max" Required="false" Internal="false" DefValue="10000" Comment="The scale of the analog input can be selected by this client (corresponds to +/-10V).&#13;&#10;As initvalue! Only available if AI1Config is set as an analog input. (Temperature Input does not work with scale)"/>
		<Client Name="AI1_Min" Required="false" Internal="false" DefValue="-10000" Comment="The scale of the analog input can be selected by this client (corresponds to +/-10V).&#13;&#10;As initvalue! Only available if AI1Config is set as an analog input. (Temperature Input does not work with scale)"/>
		<Client Name="AI1Config" Required="false" Internal="false" Comment="0 = AI1 used as analog in (Range: -10V...+10V)&#13;&#10;1 = AI1 used as analog in with ground reference (Range: -10V...+10V)&#13;&#10;2 = AI1 used as temperature input with KTY (Range: -50캜...+150캜)&#13;&#10;3 = AI1 used as temperature input with PT1000 (Range: -125캜...+850캜)&#13;&#10;"/>
		<Client Name="AI2_Freq" Required="false" Internal="false" Comment="Cut off frequency for low pass filter&#13;&#10;0... 1000 Hz&#13;&#10;1...  500 Hz&#13;&#10;2...  250 Hz&#13;&#10;3...  100 Hz&#13;&#10;4...   50 Hz&#13;&#10;5...   25 Hz&#13;&#10;6...   10 Hz"/>
		<Client Name="AI2_Max" Required="false" Internal="false" DefValue="10000" Comment="The scale of the analog input can be selected by this client (corresponds to +/-10V).&#13;&#10;As initvalue!"/>
		<Client Name="AI2_Min" Required="false" Internal="false" DefValue="-10000" Comment="The scale of the analog input can be selected by this client (corresponds to +/-10V).&#13;&#10;As initvalue!"/>
		<Client Name="AI2Config" Required="false" Internal="false" Comment="0 = AI2 used as analog in&#13;&#10;1 = AI2 used as analog in with ground reference&#13;&#10;Range -10V...+10V"/>
		<Client Name="AI3_Freq" Required="false" Internal="false" Comment="Cut off frequency for low pass filter&#13;&#10;0... 1000 Hz&#13;&#10;1...  500 Hz&#13;&#10;2...  250 Hz&#13;&#10;3...  100 Hz&#13;&#10;4...   50 Hz&#13;&#10;5...   25 Hz&#13;&#10;6...   10 Hz"/>
		<Client Name="AI3_Max" Required="false" Internal="false" DefValue="10000" Comment="The scale of the analog input can be selected by this client (corresponds to +/-10V).&#13;&#10;As initvalue!"/>
		<Client Name="AI3_Min" Required="false" Internal="false" DefValue="-10000" Comment="The scale of the analog input can be selected by this client (corresponds to +/-10V).&#13;&#10;As initvalue!"/>
		<Client Name="AI3Config" Required="false" Internal="false" Comment="0 = AI3 used as analog in&#13;&#10;1 = AI3 used as analog in with ground reference&#13;&#10;Range -10V...+10V"/>
		<Client Name="AI4_Freq" Required="false" Internal="false" Comment="Cut off frequency for low pass filter&#13;&#10;0... 1000 Hz&#13;&#10;1...  500 Hz&#13;&#10;2...  250 Hz&#13;&#10;3...  100 Hz&#13;&#10;4...   50 Hz&#13;&#10;5...   25 Hz&#13;&#10;6...   10 Hz"/>
		<Client Name="AI4_Max" Required="false" Internal="false" DefValue="10000" Comment="The scale of the analog input can be selected by this client (corresponds to +/-10V).&#13;&#10;As initvalue!"/>
		<Client Name="AI4_Min" Required="false" Internal="false" DefValue="-10000" Comment="The scale of the analog input can be selected by this client (corresponds to +/-10V).&#13;&#10;As initvalue!"/>
		<Client Name="AI4Config" Required="false" Internal="false" Comment="0 = AI4 used as analog in&#13;&#10;1 = AI4 used as analog in with ground reference&#13;&#10;Range -10V...+10V"/>
		<Client Name="AI5_Freq" Required="false" Internal="false" Comment="Cut off frequency for low pass filter&#13;&#10;0... 1000 Hz&#13;&#10;1...  500 Hz&#13;&#10;2...  250 Hz&#13;&#10;3...  100 Hz&#13;&#10;4...   50 Hz&#13;&#10;5...   25 Hz&#13;&#10;6...   10 Hz"/>
		<Client Name="AI5_Max" Required="false" Internal="false" DefValue="10000" Comment="The scale of the analog input can be selected by this client (corresponds to +/-10V).&#13;&#10;As initvalue!"/>
		<Client Name="AI5_Min" Required="false" Internal="false" DefValue="-10000" Comment="The scale of the analog input can be selected by this client (corresponds to +/-10V).&#13;&#10;As initvalue!"/>
		<Client Name="AI5Config" Required="false" Internal="false" Comment="0 = AI5 used as analog in&#13;&#10;1 = AI5 used as analog in with ground reference&#13;&#10;Range -10V...+10V"/>
		<Client Name="AI6_Freq" Required="false" Internal="false" Comment="Cut off frequency for low pass filter&#13;&#10;0... 1000 Hz&#13;&#10;1...  500 Hz&#13;&#10;2...  250 Hz&#13;&#10;3...  100 Hz&#13;&#10;4...   50 Hz&#13;&#10;5...   25 Hz&#13;&#10;6...   10 Hz"/>
		<Client Name="AI6_Max" Required="false" Internal="false" DefValue="10000" Comment="The scale of the analog input can be selected by this client (corresponds to +/-10V).&#13;&#10;As initvalue!"/>
		<Client Name="AI6_Min" Required="false" Internal="false" DefValue="-10000" Comment="The scale of the analog input can be selected by this client (corresponds to +/-10V).&#13;&#10;As initvalue!"/>
		<Client Name="AI6Config" Required="false" Internal="false" Comment="0 = AI6 used as analog in&#13;&#10;1 = AI6 used as analog in with ground reference&#13;&#10;Range -10V...+10V"/>
		<Client Name="TIConfig" Required="false" Internal="false" Comment="0 = TI used as temperature input with KTY (Range: -50캜...+150캜)&#13;&#10;1 = TI used as temperature input with PT1000 (Range: -125캜...+850캜)"/>
		<Client Name="UseSamplePointConfig" Required="false" Internal="false" DefValue="0" Comment="Use this client to activate the sample point feature.&#13;&#10;0 .. Sample point configuration inactive&#13;&#10;1 .. Sample point configuration active"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="BeiWol"/>
		<Dokumentation Revision="1.36" Date="08.06.2018" Author="RamAnd" Company="Sigmatek" Description="LASAL Hardware Description (.lhd) file has been updated."/>
		<Dokumentation Revision="1.35" Date="23.01.2018" Author="RamAnd" Company="Sigmatek" Description="Log messages have been standardized for easier maintenance, easier use in any class and to allow spam filtering. Code for the logging functions is now only located in HwControl."/>
		<Dokumentation Revision="1.34" Date="09.10.2017" Author="FurDom" Company="Sigmatek" Description="Added Flag &quot;ScaleAIx&quot; for check if a new calculation is necessary for AI1-6 -&gt; Realtime optimization. &#13;&#10;New calculation if Client AI_Min or AI_Max is not default."/>
		<Dokumentation Revision="1.33" Date="16.05.2017" Author="RamAnd" Company="Sigmatek" Description="When adding an SDO (i.e. via ReadSPIData) from background priority it was possible that the adding process got interrupted by receiving the answer to this SDO which is handled in cyclic priority. In the error case the answer was unexpected and therefore ignored. Then the class signals a timeout while waiting for the answer, which already arrived before waiting for it. Added mutex and changed instruction order to prevent this error."/>
		<Dokumentation Revision="1.32" Date="31.03.2017" Author="PieSte" Company="Sigmatek" Description="Correct hardware description file for sdias time calculation. "/>
		<Dokumentation Revision="1.31" Date="21.09.2016" Author="EisMic" Company="Sigmatek" Description="Added support for sample points."/>
		<Dokumentation Revision="1.30" Date="12.07.2016" Author="SeiChr" Company="Sigmatek" Description="Added Values for the total Current calculation. SA 31571"/>
		<Dokumentation Revision="1.29" Date="01.03.2016" Author="EisMic" Company="Sigmatek" Description="Corrected BoundExceed Error in base class at Write method of LEDControl Server when Place = LSL_DEACTIVATED."/>
		<Dokumentation Revision="1.28" Date="23.02.2016" Author="PieSte" Company="Sigmatek" Description="Add support for min range greater max range."/>
		<Dokumentation Revision="1.27" Date="17.06.2015" Author="EisMic" Company="Sigmatek" Description="The servers FPGAVersion, SerialNo, Device ID and status and input servers are now not reset anymore when the module is disconnected."/>
		<Dokumentation Revision="1.26" Date="16.04.2015" Author="EisMic&#13;&#10;LanSte" Company="Sigmatek" Description="Added support for visualisation in graphical hardware editor.&#13;&#10;Added support for calculating resources for graphical hardware editor."/>
		<Dokumentation Revision="1.25" Date="17.03.2015" Author="RamAnd" Company="Sigmatek" Description="Added HW Version for sdias clients."/>
		<Dokumentation Revision="1.24" Date="11.02.2015" Author="PieSte" Company="Sigmatek" Description="Corrected read spi data for hardwaretree in methode GetSPIDataFromID from baseclass."/>
		<Dokumentation Revision="1.23" Date="18.11.2014" Author="PieSte" Company="Sigmatek" Description="Added possibility  to read more data from spi flash then one sdo access.&#13;&#10;Set methode GetDeviceID to global.&#13;&#10;Add methode to calculate checksum of spi flash."/>
		<Dokumentation Revision="1.22" Date="04.07.2014" Author="EisMic" Company="Sigmatek" Description="Added support for reading hardware diagnosis and hardwaretree entry."/>
		<Dokumentation Revision="1.21" Date="07.03.2014" Author="EisMic" Company="Sigmatek" Description="Corrected comment of server Firmwareversion"/>
		<Dokumentation Revision="1.20" Date="20.01.2014" Author="PieSte" Company="Sigmatek" Description="Read Client Required and Place in Init SdiasBase"/>
		<Dokumentation Revision="1.10" Date="05.12.2013" Author="RamAnd" Company="Sigmatek" Description="Changed login mechanism to sdias manager class to be independent of bus accesses."/>
		<Dokumentation Revision="1.0" Date="29.07.2013" Author="BeiWol" Company="Sigmatek" Description="First library version"/>
	</RevDoku>
	<Network Name="AI075">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{8474B57C-5713-492F-9306-444B0DC222EA}"
				Class      = "SdiasBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassState"/>
					<Server Name="DeviceID"/>
					<Server Name="FPGAVersion"/>
					<Server Name="HwVersion"/>
					<Server Name="LEDControl" Value="0"/>
					<Server Name="RetryCounter"/>
					<Server Name="SDOState"/>
					<Server Name="SerialNo"/>
					<Client Name="Place" Value="0"/>
					<Client Name="Required" Value="1"/>
					<Client Name="SdiasIn"/>
					<Client Name="ToStdLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassState" Destination="_base.ClassState" Vertices="(804,210),(632,210),"/>
			<Connection Source="this.DeviceID" Destination="_base.DeviceID" Vertices="(804,270),(632,270),"/>
			<Connection Source="this.SerialNo" Destination="_base.SerialNo" Vertices="(804,450),(632,450),"/>
			<Connection Source="this.RetryCounter" Destination="_base.RetryCounter" Vertices="(804,510),(632,510),"/>
			<Connection Source="this.LEDControl" Destination="_base.LEDControl" Vertices="(804,570),(632,570),"/>
			<Connection Source="_base.SdiasIn" Destination="this.SdiasIn" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.Place" Destination="this.Place" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.Required" Destination="this.Required" Vertices="(218,330),(38,330),"/>
			<Connection Source="this.FPGAVersion" Destination="_base.FPGAVersion" Vertices="(804,330),(632,330),"/>
			<Connection Source="this.HwVersion" Destination="_base.HwVersion" Vertices="(804,390),(632,390),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using SdiasBase

AI075 : CLASS
: SdiasBase
	TYPE
	  t_SpecialPurpose : BSINT
	  [
	    1 PmbModus,
	    2 BootloaderUpdateRequ,
	  ];
	  t_Selection : BINT
	  [
	    1 AI1_Analog0_Temp1,
	    2 AI1_Kty0_Pt1,
	    3 AI1_Def0_Ground1,
	    4 AI2_Def0_Ground1,
	    5 AI3_Def0_Ground1,
	    6 AI4_Def0_Ground1,
	    7 AI5_Def0_Ground1,
	    8 AI6_Def0_Ground1,
	    9 TI_Kty0_Pt1,
	  ];
#pragma pack(push, 1)
	  t_StandardModus : STRUCT
	    Selection : t_Selection;  //! <Type Comment="Analog input settings" Name="t_StandardModus.Selection"/>
	    AI1_Freq : UINT;  //! <Type Comment="Cut off frequency for analog in low pass filter" Name="t_StandardModus.AI1_Freq"/>
	    AI2_Freq : UINT;  //! <Type Comment="Cut off frequency for analog in low pass filter" Name="t_StandardModus.AI2_Freq"/>
	    AI3_Freq : UINT;  //! <Type Comment="Cut off frequency for analog in low pass filter" Name="t_StandardModus.AI3_Freq"/>
	    AI4_Freq : UINT;  //! <Type Comment="Cut off frequency for analog in low pass filter" Name="t_StandardModus.AI4_Freq"/>
	    AI5_Freq : UINT;  //! <Type Comment="Cut off frequency for analog in low pass filter" Name="t_StandardModus.AI5_Freq"/>
	    AI6_Freq : UINT;  //! <Type Comment="Cut off frequency for analog in low pass filter" Name="t_StandardModus.AI6_Freq"/>
	    MessageCounter : UINT;  //! <Type Comment="Message counter." Name="t_StandardModus.MessageCounter"/>
	    uiBusTime : UINT;  //! <Type Comment="Cycletime of module in 탎." Name="t_StandardModus.uiBusTime"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_CfgFirmware : STRUCT
	    CRC : UINT;
	    DataLength : UINT;
	    Info : t_SpecialPurpose;
	    Reserved : USINT;
	    StandardModus : t_StandardModus;
	  END_STRUCT;
#pragma pack(pop)
	  t_Error : BINT
	  [
	    1 CableBreakAI1,
	    2 CableBreakAI2,
	    3 CableBreakAI3,
	    4 CableBreakAI4,
	    5 CableBreakAI5,
	    6 CableBreakAI6,
	    7 CableBreakTI,
	    8 ShortCircuitAI1,
	    9 ShortCircuitTI,
	    10 LowReference,
	    11 AiOverflow,
	  ];
	  t_InitSSW :
	  (
	    _InitVariables,
	    _ConfigModule,
	    _ReadState,
	    _Finish,
	    _InitError
	  )$UDINT;
#pragma pack(push, 1)
	  t_ReadData : STRUCT
	    Status : t_b_SdiasFWState;
	    AnalogIn1 : INT;
	    AnalogIn2 : INT;
	    AnalogIn3 : INT;
	    AnalogIn4 : INT;
	    AnalogIn5 : INT;
	    AnalogIn6 : INT;
	    TemperatureIn : INT;
	    Error : t_Error;
	  END_STRUCT;
#pragma pack(pop)
	  t_ResponseState :
	  (
	    _idle,
	    _wait,
	    _valid
	  )$UDINT;
#pragma pack(push, 1)
	  t_s_SamplePointState : STRUCT  //! <Type Public="true" Name="t_s_SamplePointState"/>
	    StateBits : BDINT
	    [
	      1 SamplePointsCorrectedByFW,
	      2 SamplePointsCouldNotBeCorrected,
	      3 InvalidCycleTimeSet,
	      4 InvalidCycleTimeCompare,
	      5 Bit5,
	      6 Bit6,
	      7 Bit7,
	      8 Bit8,
	      9 Bit9,
	      10 Bit10,
	      11 Bit11,
	      12 Bit12,
	      13 Bit13,
	      14 Bit14,
	      15 Bit15,
	      16 Bit16,
	      17 Bit17,
	      18 Bit18,
	      19 Bit19,
	      20 Bit20,
	      21 Bit21,
	      22 Bit22,
	      23 Bit23,
	      24 Bit24,
	      25 Bit25,
	      26 Bit26,
	      27 Bit27,
	      28 Bit28,
	      29 Bit29,
	      30 Bit30,
	      31 Bit31,
	      32 Bit32,
	    ];
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_WriteAccess : STRUCT
	    AccessHandle : UDINT;
	    pControlByte : t_SDIAS_pControlByte;
	    pStateByte : t_SDIAS_pStateByte;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_WriteData : STRUCT
	    AI1SamplePoint : UINT;
	    AI2SamplePoint : UINT;
	    AI3SamplePoint : UINT;
	    AI4SamplePoint : UINT;
	    AI5SamplePoint : UINT;
	    AI6SamplePoint : UINT;
	    TISamplePoint : UINT;
	    Config : BSINT
	    [
	      1 Bit1,
	      2 Bit2,
	      3 Bit3,
	      4 Bit4,
	      5 Bit5,
	      6 Bit6,
	      7 Bit7,
	      8 UseVariableSampleTime,
	    ];
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_StateFirmware : STRUCT
	    CRC : UINT;
	    DataLength : UINT;
	    FirmwareVersion : UINT;
	    MessageCounter : UINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	FirmwareVersion 	: SvrCh_HDINT;
	FWErrorBits 	: SvrCh_t_s_SdiasFWStateStandard_PTofCls_SdiasBase;
	AI1 	: SvrCh_DINT;
	AI2 	: SvrCh_DINT;
	AI3 	: SvrCh_DINT;
	AI4 	: SvrCh_DINT;
	AI5 	: SvrCh_DINT;
	AI6 	: SvrCh_DINT;
	TI 	: SvrCh_DINT;
	CableBreak 	: SvrCh_BDINT;
	ShortCircuit 	: SvrCh_BDINT;
	RefVoltageOK 	: SvrCh_DINT;
	OverCurrent 	: SvrCh_DINT;
	AI1SamplePoint 	: SvrCh_DINT;
	AI2SamplePoint 	: SvrCh_DINT;
	AI3SamplePoint 	: SvrCh_DINT;
	AI4SamplePoint 	: SvrCh_DINT;
	AI5SamplePoint 	: SvrCh_DINT;
	AI6SamplePoint 	: SvrCh_DINT;
	TISamplePoint 	: SvrCh_DINT;
	ActivateSamplePointConfig 	: SvrCh_DINT;
	SamplePointState 	: SvrCh_t_s_SamplePointState_PTofCls_AI075;
  //Clients:
	AI1Config 	: CltCh_DINT;
	AI1_Freq 	: CltCh_UDINT;
	AI1_Min 	: CltCh_DINT;
	AI1_Max 	: CltCh_DINT;
	AI2Config 	: CltCh_DINT;
	AI2_Freq 	: CltCh_UDINT;
	AI2_Min 	: CltCh_DINT;
	AI2_Max 	: CltCh_DINT;
	AI3Config 	: CltCh_DINT;
	AI3_Freq 	: CltCh_UDINT;
	AI3_Min 	: CltCh_DINT;
	AI3_Max 	: CltCh_DINT;
	AI4Config 	: CltCh_DINT;
	AI4_Freq 	: CltCh_UDINT;
	AI4_Min 	: CltCh_DINT;
	AI4_Max 	: CltCh_DINT;
	AI5Config 	: CltCh_DINT;
	AI5_Freq 	: CltCh_UDINT;
	AI5_Min 	: CltCh_DINT;
	AI5_Max 	: CltCh_DINT;
	AI6Config 	: CltCh_DINT;
	AI6_Freq 	: CltCh_UDINT;
	AI6_Min 	: CltCh_DINT;
	AI6_Max 	: CltCh_DINT;
	TIConfig 	: CltCh_DINT;
	UseSamplePointConfig 	: CltCh_DINT;
  //Variables:
		aAIRange : ARRAY [0..AI075_NUMBER_OF_ANALOG_IN-1] OF DINT;
			//! <Variable Comment="RangeInformations for the Inputs." Name="aAIRange"/>
		eInitSSW 	: t_InitSSW;			//! <Variable Comment="Initialisation Statemachine." Name="eInitSSW"/>
		eInitSSWErrorStep 	: t_InitSSW;			//! <Variable Comment="Initialisation Statemachine in case of an Error." Name="eInitSSWErrorStep"/>
		eResponseState 	: t_ResponseState;			//! <Variable Comment="Actual Response State of the SDO Communication." Name="eResponseState"/>
		pReadData 	: ^t_ReadData;			//! <Variable Comment="Read-Data from the Module." Name="pReadData"/>
		pWriteData 	: ^t_s_WriteData;			//! <Variable Comment="Write Data to the module. Since FW Version 1.30" Name="pWriteData"/>
		sWriteAccess 	: t_s_WriteAccess;			//! <Variable Comment="Write Access Data for write PDO." Name="sWriteAccess"/>
		sCfgFirmware 	: t_CfgFirmware;			//! <Variable Comment="Configuration Data for the Firmware." Name="sCfgFirmware"/>
		sStateFirmware 	: t_StateFirmware;			//! <Variable Comment="FW Informations of the Module." Name="sStateFirmware"/>
		udSDOTimeout 	: UDINT;			//! <Variable Comment="Timeout for SDO-Communication." Name="udSDOTimeout"/>
		bChangeFlag 	: BOOL;			//! <Variable Comment="Change flag for write data." Name="bChangeFlag"/>
		bIsDefaultWriteAccessAvailable 	: BOOL;			//! <Variable Comment="Flag if default writeaccess is available" Name="bIsDefaultWriteAccessAvailable"/>
		ScaleAI1 	: BOOL;
		ScaleAI2 	: BOOL;
		ScaleAI3 	: BOOL;
		ScaleAI4 	: BOOL;
		ScaleAI5 	: BOOL;
		ScaleAI6 	: BOOL;
  //Functions:
				//! <Function Comment="Constructor of Class." Name="AI075"/>
	FUNCTION AI075
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="Realtime Update Methode which runs in PreScan." Name="UpdateRt"/>
	FUNCTION VIRTUAL GLOBAL UpdateRt;
				//! <Function Comment="Realtime Update Methode which runs in PostScan." Name="UpdateRtPostScan"/>
	FUNCTION VIRTUAL GLOBAL UpdateRtPostScan;
	
	FUNCTION VIRTUAL GLOBAL AddAccesses
		VAR_OUTPUT
			eModuleInitState 	: iprStates;
		END_VAR;
				//! <Function Comment="Methode is called if this Module gets connected." Name="ConnectEvent"/>
	FUNCTION VIRTUAL GLOBAL ConnectEvent;
				//! <Function Comment="Methode is called if this Module gets disconnected." Name="DisconnectEvent"/>
	FUNCTION VIRTUAL GLOBAL DisconnectEvent;
				//! <Function Comment="Methode should be used to run a Statemachine to Initialize the Module." Name="InitModule"/>
	FUNCTION VIRTUAL GLOBAL InitModule
		VAR_OUTPUT
			eModuleInitState 	: iprStates;			//! <Variable Comment="Return BUSY until the Initialisation is finished." Name="InitModule.eModuleInitState"/>
		END_VAR;
				//! <Function Comment="This Methode is used, to check the DeviceID of the Module." Name="CheckDeviceID"/>
	FUNCTION VIRTUAL GLOBAL CheckDeviceID
		VAR_INPUT
			udID2Check 	: UDINT;			//! <Variable Comment="Device ID of connected Module." Name="CheckDeviceID.udID2Check"/>
		END_VAR
		VAR_OUTPUT
			bIsOK 	: BOOL;			//! <Variable Comment="FALSE = Wrong DeviceID for Module&#13;&#10;TRUE  = DeviceID of Module is correct" Name="CheckDeviceID.bIsOK"/>
		END_VAR;
				//! <Function Comment="Methode to receive the Response in case of SDO-Communication." Name="ReceiveSDOResponse"/>
	FUNCTION VIRTUAL ReceiveSDOResponse
		VAR_INPUT
			eCommand 	: t_SDIAS_SDO_Cmd;			//! <Variable Comment="Type of SDO-Command" Name="ReceiveSDOResponse.eCommand"/>
			hOffset 	: HINT;			//! <Variable Comment="Address-Offset in Module." Name="ReceiveSDOResponse.hOffset"/>
			usLength 	: USINT;			//! <Variable Comment="Length of Data." Name="ReceiveSDOResponse.usLength"/>
			eResult 	: iprStates;			//! <Variable Comment="State of SDO-Communication." Name="ReceiveSDOResponse.eResult"/>
			pResponseBuffer 	: ^USINT;			//! <Variable Comment="Pointer of ResponseBuffer, where the SDO-Data is located." Name="ReceiveSDOResponse.pResponseBuffer"/>
			ResponseLength 	: USINT;			//! <Variable Comment="Size of the ResponseBuffer." Name="ReceiveSDOResponse.ResponseLength"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;			//! <Variable Comment="Indicates if the Methode was successful." Name="ReceiveSDOResponse.ret_code"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetTaskCfg
		VAR_OUTPUT
			TaskCfg 	: BDINT;			//! <Variable Comment="Select which tasks will be available for this module:&#13;&#10;Bit0..Realtime PreScan&#13;&#10;Bit1..Realtime PostScan&#13;&#10;Bit2..Cyclic&#13;&#10;&#13;&#10;e.g. if only realtime postscan is needed:&#13;&#10;2#010" Name="GetTaskCfg.TaskCfg"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetDeviceID
		VAR_OUTPUT
			output 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GetFWVersion
		VAR_INPUT
			pData 	: ^CHAR;
			Length 	: UDINT;
		END_VAR;
				//! <Function Comment="Lookup-Methode to get the Frequency-Setting for the uC." Name="SetFrequency"/>
	FUNCTION SetFrequency
		VAR_INPUT
			ClientValue 	: UDINT;			//! <Variable Comment="Input-Value for the uC" Name="SetFrequency.ClientValue"/>
		END_VAR
		VAR_OUTPUT
			Frequency 	: UINT;			//! <Variable Comment="Result for the uC." Name="SetFrequency.Frequency"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AI1SamplePoint::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AI2SamplePoint::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AI3SamplePoint::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AI4SamplePoint::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AI5SamplePoint::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AI6SamplePoint::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL TISamplePoint::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ActivateSamplePointConfig::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB AI075::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_AI075
1$UINT, 36$UINT, (SIZEOF(::AI075))$UINT, 
22$UINT, 26$UINT, 0$UINT, 
TO_UDINT(2809270484), "AI075", //Class
TO_UDINT(3175101883), "SdiasBase", 1$UINT, 58$UINT, //Baseclass
//Servers:
(::AI075.FirmwareVersion.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(389440282), "FirmwareVersion", 
(::AI075.FWErrorBits.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3888132073), "FWErrorBits", 
(::AI075.AI1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4269591187), "AI1", 
(::AI075.AI2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1735760681), "AI2", 
(::AI075.AI3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(275950527), "AI3", 
(::AI075.AI4.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2383822364), "AI4", 
(::AI075.AI5.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4178644618), "AI5", 
(::AI075.AI6.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1612209968), "AI6", 
(::AI075.TI.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2416866203), "TI", 
(::AI075.CableBreak.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3580028836), "CableBreak", 
(::AI075.ShortCircuit.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(265202714), "ShortCircuit", 
(::AI075.RefVoltageOK.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4186040419), "RefVoltageOK", 
(::AI075.OverCurrent.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1742802262), "OverCurrent", 
(::AI075.AI1SamplePoint.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(145427486), "AI1SamplePoint", 
(::AI075.AI2SamplePoint.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2134236910), "AI2SamplePoint", 
(::AI075.AI3SamplePoint.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3834679937), "AI3SamplePoint", 
(::AI075.AI4SamplePoint.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2416474894), "AI4SamplePoint", 
(::AI075.AI5SamplePoint.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(195901281), "AI5SamplePoint", 
(::AI075.AI6SamplePoint.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2083775889), "AI6SamplePoint", 
(::AI075.TISamplePoint.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3686732914), "TISamplePoint", 
(::AI075.ActivateSamplePointConfig.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(84511116), "ActivateSamplePointConfig", 
(::AI075.SamplePointState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2360760474), "SamplePointState", 
//Clients:
(::AI075.AI1Config.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2190884243), "AI1Config", 
(::AI075.AI1_Freq.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1690732223), "AI1_Freq", 
(::AI075.AI1_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2432037533), "AI1_Min", 
(::AI075.AI1_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2901986756), "AI1_Max", 
(::AI075.AI2Config.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3011389198), "AI2Config", 
(::AI075.AI2_Freq.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3797087249), "AI2_Freq", 
(::AI075.AI2_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3612706893), "AI2_Min", 
(::AI075.AI2_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3948459796), "AI2_Max", 
(::AI075.AI3Config.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(352922810), "AI3Config", 
(::AI075.AI3_Freq.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(688793524), "AI3_Freq", 
(::AI075.AI3_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3929383421), "AI3_Min", 
(::AI075.AI3_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3594034852), "AI3_Max", 
(::AI075.AI4Config.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3501068852), "AI4Config", 
(::AI075.AI4_Freq.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(873142028), "AI4_Freq", 
(::AI075.AI4_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1477803501), "AI4_Min", 
(::AI075.AI4_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1679311540), "AI4_Max", 
(::AI075.AI5Config.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1993939328), "AI5Config", 
(::AI075.AI5_Freq.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(4283942057), "AI5_Freq", 
(::AI075.AI5_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1702188125), "AI5_Min", 
(::AI075.AI5_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1501063940), "AI5_Max", 
(::AI075.AI6Config.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1194394397), "AI6Config", 
(::AI075.AI6_Freq.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2042869255), "AI6_Freq", 
(::AI075.AI6_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(584396429), "AI6_Min", 
(::AI075.AI6_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(517476820), "AI6_Max", 
(::AI075.TIConfig.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(4033698726), "TIConfig", 
(::AI075.UseSamplePointConfig.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1318816480), "UseSamplePointConfig", 
END_FUNCTION


#define USER_CNT_AI075 20

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_AI075] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION AI075::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= SdiasBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= SdiasBase::ClassState.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, SdiasBase::ClassState.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_AI075;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #UpdateRt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #UpdateRtPostScan();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #AddAccesses();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #ConnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #DisconnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #InitModule();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #CheckDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #ReceiveSDOResponse();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #GetTaskCfg();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #GetDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #GetFWVersion();

#pragma warning (default : 74)
	SdiasBase::ClassState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SdiasBase::ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AI1SamplePoint.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AI1SamplePoint::Write() );
	IF AI1SamplePoint.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AI2SamplePoint.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AI2SamplePoint::Write() );
	IF AI2SamplePoint.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AI3SamplePoint.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AI3SamplePoint::Write() );
	IF AI3SamplePoint.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AI4SamplePoint.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AI4SamplePoint::Write() );
	IF AI4SamplePoint.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AI5SamplePoint.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AI5SamplePoint::Write() );
	IF AI5SamplePoint.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AI6SamplePoint.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AI6SamplePoint::Write() );
	IF AI6SamplePoint.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	TISamplePoint.pMeth			:= StoreMethod( #M_RD_DIRECT(), #TISamplePoint::Write() );
	IF TISamplePoint.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ActivateSamplePointConfig.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ActivateSamplePointConfig::Write() );
	IF ActivateSamplePointConfig.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= AI075();

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION VIRTUAL GLOBAL AI075::UpdateRt
  VAR
  	TempReadData : t_ReadData;
  END_VAR

  TempReadData := pReadData^;

  // set Status
  FWErrorBits.ErrorBits := TempReadData.Status;
  
  if (TempReadData.Error.CableBreakAI1) | (TempReadData.Error.ShortCircuitAI1 & sCfgFirmware.StandardModus.Selection.AI1_Analog0_Temp1) then
    AI1 := AI075_INVALID_VALUE;
  else
    if (sCfgFirmware.StandardModus.Selection.AI1_Analog0_Temp1) then
      // Temperature input
      AI1 := TempReadData.AnalogIn1;
    else
    // Analog input
      if ScaleAI1 then
        AI1 := AI1_Min + (aAIRange[0] * (TempReadData.AnalogIn1 - AI075_FIRMWARE_MIN)) / (AI075_FIRMWARE_MAX - AI075_FIRMWARE_MIN);
      else
        AI1 := TempReadData.AnalogIn1;
      end_if;      
    end_if;
  end_if;
  
  if (TempReadData.Error.CableBreakAI2) then
    AI2 := AI075_INVALID_VALUE;
  else
    if ScaleAI2 then
      AI2 := AI2_Min + (aAIRange[1] * (TempReadData.AnalogIn2 - AI075_FIRMWARE_MIN)) / (AI075_FIRMWARE_MAX - AI075_FIRMWARE_MIN);
    else
      AI2 := TempReadData.AnalogIn2;
    end_if;    
  end_if;
  
  if (TempReadData.Error.CableBreakAI3) then
    AI3 := AI075_INVALID_VALUE;
  else
    if ScaleAI3 then
      AI3 := AI3_Min + (aAIRange[2] * (TempReadData.AnalogIn3 - AI075_FIRMWARE_MIN)) / (AI075_FIRMWARE_MAX - AI075_FIRMWARE_MIN);
    else
      AI3 := TempReadData.AnalogIn3;
    end_if;   
  end_if;
  
  if (TempReadData.Error.CableBreakAI4) then
    AI4 := AI075_INVALID_VALUE;
  else
    if ScaleAI4 then
      AI4 := AI4_Min + (aAIRange[3] * (TempReadData.AnalogIn4 - AI075_FIRMWARE_MIN)) / (AI075_FIRMWARE_MAX - AI075_FIRMWARE_MIN);
    else
      AI4 := TempReadData.AnalogIn4;
    end_if;    
  end_if;
  
  if (TempReadData.Error.CableBreakAI5) then
    AI5 := AI075_INVALID_VALUE;
  else
    if ScaleAI5 then
      AI5 := AI5_Min + (aAIRange[4] * (TempReadData.AnalogIn5 - AI075_FIRMWARE_MIN)) / (AI075_FIRMWARE_MAX - AI075_FIRMWARE_MIN);
    else
      AI5 := TempReadData.AnalogIn5;
    end_if;    
  end_if;
  
  if (TempReadData.Error.CableBreakAI6) then
    AI6 := AI075_INVALID_VALUE;
  else
    if ScaleAI6 then
      AI6 := AI6_Min + (aAIRange[5] * (TempReadData.AnalogIn6 - AI075_FIRMWARE_MIN)) / (AI075_FIRMWARE_MAX - AI075_FIRMWARE_MIN);
    else
      AI6 := TempReadData.AnalogIn6;  
    end_if;    
  end_if;
  
  if (TempReadData.Error.CableBreakTI) | (TempReadData.Error.ShortCircuitTI) then
    TI := AI075_INVALID_VALUE;
  else
    TI  := TempReadData.TemperatureIn;
  end_if;

  // set Error server
  CableBreak  := TempReadData.Error and AI075_CABLE_BREAK_MASK;                                                   //mask Cable break Bits
  ShortCircuit:= (TempReadData.Error shr (AI075_NUMBER_OF_ANALOG_IN + AI075_NUMBER_OF_TMP_IN)) and AI075_SHORT_CIRCUIT_MASK;  // Shift to short cut Bits and Mask ShortCircuit Bits
  SamplePointState.StateBits := (TempReadData.Error shr AI075_OFFSET_SAMPLE_POINT_BITS) and AI075_SAMPLE_POINT_MASK;
  RefVoltageOK := TempReadData.Error.LowReference XOR 1;
  OverCurrent := TempReadData.Error.AiOverflow;
  

  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL AI075::UpdateRtPostScan

  //Only write data when its changed and sample points are used
  if bChangeFlag then
    //Check for valid pointer, maybe old firmware is used
    if pWriteData then
      pWriteData^.AI1SamplePoint := AI1SamplePoint$UINT;
      pWriteData^.AI2SamplePoint := AI2SamplePoint$UINT;
      pWriteData^.AI3SamplePoint := AI3SamplePoint$UINT;
      pWriteData^.AI4SamplePoint := AI4SamplePoint$UINT;
      pWriteData^.AI5SamplePoint := AI5SamplePoint$UINT;
      pWriteData^.AI6SamplePoint := AI6SamplePoint$UINT;
      pWriteData^.TISamplePoint := TISamplePoint$UINT;
      
      pWriteData^.Config.UseVariableSampleTime := ActivateSamplePointConfig <> 0;
            
      //Reset Change flag
      bChangeFlag := FALSE;    
    end_if;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI075::ConnectEvent

  // start the accesses on the SDIAS (initialize the control byte in the DPRAM)
  if DefaultAccesses.ReadAccess.pControlByte then
    pReadData := DefaultAccesses.ReadAccess.pData$^t_ReadData;

    DefaultAccesses.ReadAccess.pControlByte^.EnableDO := TRUE;
  else
    eInitState := _DOHandleInvalid;
    return;
  end_if;
    
  //Send data first time
  bChangeFlag := TRUE;
  
  // Only enable DOs if sample point config is used  
  if UseSamplePointConfig then
    //Check if a default write access is available at the hardware (valid length)
    if bIsDefaultWriteAccessAvailable = TRUE then
      if DefaultAccesses.WriteAccess.pControlByte then
        pWriteData := DefaultAccesses.WriteAccess.pData$^t_s_WriteData;

        DefaultAccesses.WriteAccess.pControlByte^.EnableDO := TRUE;
      else
        eInitState := _DOHandleInvalid;
        return;
      end_if;   
    else
      //No Default access available, we use our own created write access
      if sWriteAccess.pControlByte then
        sWriteAccess.pControlByte^.EnableDO := TRUE;
      else
        eInitState := _DOHandleInvalid;
        return;
      end_if;  
    end_if;
  end_if;
  
  eInitSSW := _InitVariables;
  eResponseState := _idle;
  eInitState    := _NotInitialized;

END_FUNCTION


FUNCTION VIRTUAL AI075::ReceiveSDOResponse
	VAR_INPUT
		eCommand 	: t_SDIAS_SDO_Cmd;
		hOffset 	: HINT;
		usLength 	: USINT;
		eResult 	: iprStates;
		pResponseBuffer 	: ^USINT;
		ResponseLength 	: USINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR
  
  ret_code := SdiasBase::ReceiveSDOResponse(eCommand, hOffset, usLength, eResult, pResponseBuffer, ResponseLength);
                                           
  // spi access from baseclass                                         
  if bSDOResponseHandle = TRUE then
    return;
  end_if;   
  
  if eResult = READY then
    
    case eCommand of
      SDIAS_SDO_CMD_MEM_WRITE:
        case hOffset of
          AI075_ADDR_CFG_FIRMWARE:
            if eResponseState = _wait then
              eResponseState := _valid;
            end_if;           
        end_case;
        
      SDIAS_SDO_CMD_MEM_READ:
        case hOffset of
          AI075_ADDR_STATE_FIRMWARE:
            if eResponseState = _wait then
              eResponseState := _valid;
            end_if;
            sStateFirmware := pResponseBuffer^$t_StateFirmware;
        end_case;
    end_case;
    
    if eResponseState <> _valid then
      LogError("@ZZZZ (AI075::ReceiveSDOResponse) Error in response data of SDO");
      eInitSSW := _InitError;      
    end_if;
  else
    case eCommand of
      SDIAS_SDO_CMD_MEM_WRITE:
        LogError("@ZZZZ (AI075::ReceiveSDOResponse) Error while writing the firmware configuration");
      SDIAS_SDO_CMD_MEM_READ:
        LogError("@ZZZZ (AI075::ReceiveSDOResponse) Error while waiting for the firmware state");
    end_case;
    eInitSSW := _InitError;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI075::InitModule
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
  VAR
  	TmpRetcode      : iprStates;
  END_VAR
  
  eModuleInitState := BUSY;

  CASE eInitSSW OF
//**********************************************************************************************************************************************************
    _InitVariables:
      AI1Config := AI1Config.Read();
      AI2Config := AI2Config.Read();
      AI3Config := AI3Config.Read();
      AI4Config := AI4Config.Read();
      AI5Config := AI5Config.Read();
      AI6Config := AI6Config.Read();
      TIConfig  := TIConfig.Read();
      
      AI1_Freq := AI1_Freq.Read();
      AI2_Freq := AI2_Freq.Read();
      AI3_Freq := AI3_Freq.Read();
      AI4_Freq := AI4_Freq.Read();
      AI5_Freq := AI5_Freq.Read();
      AI6_Freq := AI6_Freq.Read();

      ActivateSamplePointConfig := ActivateSamplePointConfig.Read() AND 0x01;

      sCfgFirmware.StandardModus.AI1_Freq := SetFrequency(AI1_Freq);
      sCfgFirmware.StandardModus.AI2_Freq := SetFrequency(AI2_Freq);
      sCfgFirmware.StandardModus.AI3_Freq := SetFrequency(AI3_Freq);
      sCfgFirmware.StandardModus.AI4_Freq := SetFrequency(AI4_Freq);
      sCfgFirmware.StandardModus.AI5_Freq := SetFrequency(AI5_Freq);
      sCfgFirmware.StandardModus.AI6_Freq := SetFrequency(AI6_Freq);      
      
      AI1_Min := AI1_Min.Read();
      AI1_Max := AI1_Max.Read();
      AI2_Min := AI2_Min.Read();
      AI2_Max := AI2_Max.Read();
      AI3_Min := AI3_Min.Read();
      AI3_Max := AI3_Max.Read();
      AI4_Min := AI4_Min.Read();
      AI4_Max := AI4_Max.Read();
      AI5_Min := AI5_Min.Read();
      AI5_Max := AI5_Max.Read();
      AI6_Min := AI6_Min.Read();
      AI6_Max := AI6_Max.Read();
      
      //check if calculation is necessary
      if (AI1Config < 2) & ((AI1_Max <> AI075_FIRMWARE_MAX) | (AI1_Min <> AI075_FIRMWARE_MIN)) then
        ScaleAI1 := TRUE;      
      end_if;
      if (AI2_Max <> AI075_FIRMWARE_MAX) | (AI2_Min <> AI075_FIRMWARE_MIN) then
        ScaleAI2 := TRUE;      
      end_if;
      if (AI3_Max <> AI075_FIRMWARE_MAX) | (AI3_Min <> AI075_FIRMWARE_MIN) then
        ScaleAI3 := TRUE;      
      end_if;
      if (AI4_Max <> AI075_FIRMWARE_MAX) | (AI4_Min <> AI075_FIRMWARE_MIN) then
        ScaleAI4 := TRUE;      
      end_if;      
      if (AI5_Max <> AI075_FIRMWARE_MAX) | (AI5_Min <> AI075_FIRMWARE_MIN) then
        ScaleAI5 := TRUE;      
      end_if;
      if (AI6_Max <> AI075_FIRMWARE_MAX) | (AI6_Min <> AI075_FIRMWARE_MIN) then
        ScaleAI6 := TRUE;      
      end_if;
      
      aAIRange[0] := AI1_Max - AI1_Min;
      aAIRange[1] := AI2_Max - AI2_Min;
      aAIRange[2] := AI3_Max - AI3_Min;
      aAIRange[3] := AI4_Max - AI4_Min;
      aAIRange[4] := AI5_Max - AI5_Min;
      aAIRange[5] := AI6_Max - AI6_Min;        
      
      sCfgFirmware.StandardModus.Selection := 0;
      case AI1Config of
      0:  //Analog in default
        sCfgFirmware.StandardModus.Selection.AI1_Analog0_Temp1 := 0;
        sCfgFirmware.StandardModus.Selection.AI1_Kty0_Pt1      := 0;
        sCfgFirmware.StandardModus.Selection.AI1_Def0_Ground1  := 0;
      1:  //Analog in ground
        sCfgFirmware.StandardModus.Selection.AI1_Analog0_Temp1 := 0;
        sCfgFirmware.StandardModus.Selection.AI1_Kty0_Pt1      := 0;
        sCfgFirmware.StandardModus.Selection.AI1_Def0_Ground1  := 1;     
      2:  //KTY
        sCfgFirmware.StandardModus.Selection.AI1_Analog0_Temp1 := 1;
        sCfgFirmware.StandardModus.Selection.AI1_Kty0_Pt1      := 0;
        sCfgFirmware.StandardModus.Selection.AI1_Def0_Ground1  := 0;      
      3:  //PT1000
        sCfgFirmware.StandardModus.Selection.AI1_Analog0_Temp1 := 1;
        sCfgFirmware.StandardModus.Selection.AI1_Kty0_Pt1      := 1;
        sCfgFirmware.StandardModus.Selection.AI1_Def0_Ground1  := 0;
      end_case;
      
      sCfgFirmware.StandardModus.Selection.AI2_Def0_Ground1     := AI2Config <> 0;
      sCfgFirmware.StandardModus.Selection.AI3_Def0_Ground1     := AI3Config <> 0;
      sCfgFirmware.StandardModus.Selection.AI4_Def0_Ground1     := AI4Config <> 0;
      sCfgFirmware.StandardModus.Selection.AI5_Def0_Ground1     := AI5Config <> 0;
      sCfgFirmware.StandardModus.Selection.AI6_Def0_Ground1     := AI6Config <> 0;
      sCfgFirmware.StandardModus.Selection.TI_Kty0_Pt1          := TIConfig <> 0;
      
      UseSamplePointConfig := UseSamplePointConfig.Read();
      
      // Use the new handling
      if UseSamplePointConfig then
      
        // Increment Messagecounter
        sCfgFirmware.StandardModus.MessageCounter += 1;
        
        // Bustime
        sCfgFirmware.StandardModus.uiBusTime := to_uint(udBusTime / 1000); // Convert in 탎
  
        sCfgFirmware.Info.PmbModus                      := FALSE;
        sCfgFirmware.Info.BootloaderUpdateRequ          := FALSE;      
        
        // Tell firmware that Messagecounter is used
        sCfgFirmware.Info.3 := TRUE;  
        sCfgFirmware.DataLength                         := sizeof(t_CfgFirmware) - sizeof(t_CfgFirmware.CRC) - sizeof(t_CfgFirmware.DataLength);
        sCfgFirmware.CRC                                := CheckSum_16( pData:=(#sCfgFirmware.Info)$^UINT, uiDataLength:=sCfgFirmware.DataLength,uiCrcStart:=16#FFFF);   
        
      else // Old handling
        sCfgFirmware.Info.PmbModus                      := FALSE;
        sCfgFirmware.Info.BootloaderUpdateRequ          := FALSE;
        sCfgFirmware.DataLength                         := sizeof(t_CfgFirmware) - sizeof(t_CfgFirmware.CRC) - sizeof(t_CfgFirmware.DataLength) - sizeof(t_CfgFirmware.StandardModus.MessageCounter) - sizeof(t_CfgFirmware.StandardModus.uiBusTime) ;
        sCfgFirmware.CRC                                := CheckSum_16(pData:=(#sCfgFirmware.Info)$^UINT, uiDataLength:=sCfgFirmware.DataLength, uiCrcStart:=16#FFFF);
      end_if;
      
      if (eInitState = _InvalidConfguration) then
        eInitSSW   := _InitError;
      else
        eInitSSW   := _ConfigModule;      
      end_if;
    
//**********************************************************************************************************************************************************
    _ConfigModule:
      case eResponseState of
        _idle:
          TmpRetcode  := StartWriteSDO(hOffset:=AI075_ADDR_CFG_FIRMWARE, usLength:=sizeof(t_CfgFirmware), pWriteBuffer:=(#sCfgFirmware)$^USINT, eCommand:=SDIAS_SDO_CMD_MEM_WRITE);
          if TmpRetcode = READY then
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= _wait; 
          elsif TmpRetcode = ERROR then
            eModuleInitState := ERROR;
            LogError("@ZZZZ (AI075::InitModule) Failed to add write SDO for firmware configuration");
            eInitState := _NoMem;
          end_if;
          //*****************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > AI075_SDO_RESPONSE_TIMEOUT) then
            LogError("@ZZZZ (AI075::InitModule) SDO Response timeout config module");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW := _InitError;
          end_if;
        //*****************************************************
        _valid:
          eInitSSW        := _ReadState;
          eResponseState  := _idle;
        //*****************************************************
      end_case;
      
//**********************************************************************************************************************************************************
    _ReadState:
      case eResponseState of
        _idle:
          TmpRetcode  := StartReadSDO(hOffset:=AI075_ADDR_STATE_FIRMWARE, usLength:=sizeof(t_StateFirmware), eCommand:=SDIAS_SDO_CMD_MEM_READ);
          if TmpRetcode = READY then
            udSDOTimeout      := ops.tAbsolute;
            eResponseState := _wait; 
          elsif TmpRetcode = ERROR then
            eModuleInitState := ERROR;
            LogError("@ZZZZ (AI075::InitModule) Failed to add read SDO for firmware info");
            eInitState := _NoMem;
          end_if; 
          //*****************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > AI075_SDO_RESPONSE_TIMEOUT) then
            LogError("@ZZZZ (AI075::InitModule) SDO Response timeout read state");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW := _InitError;
          end_if;
        //*****************************************************
        _valid: 
        
          // Check for correct length, allow old and new datalength
          if  sStateFirmware.DataLength = sizeof(t_StateFirmware) - sizeof(t_StateFirmware.CRC) - sizeof(t_StateFirmware.DataLength) |
              sStateFirmware.DataLength = sizeof(t_StateFirmware) - sizeof(t_StateFirmware.CRC) - sizeof(t_StateFirmware.DataLength) - sizeof(t_StateFirmware.MessageCounter) then
            if (sStateFirmware.CRC = CheckSum_16(pData:= #sStateFirmware.FirmwareVersion, uiDataLength:= sStateFirmware.DataLength, uiCrcStart:=16#FFFF)) then
              FirmwareVersion := (sStateFirmware.FirmwareVersion and 16#0000FFFF)$HDINT;
              
              eInitSSW         := _Finish;
              eResponseState   := _idle;      
              
                // Sample points are only supported with new config communication
              if UseSamplePointConfig = FALSE then
                AI1SamplePoint := -1;
                AI2SamplePoint := -1;
                AI3SamplePoint := -1;
                AI4SamplePoint := -1;
                AI5SamplePoint := -1;
                AI6SamplePoint := -1;
                TISamplePoint := -1;
                bChangeFlag := FALSE; // we don't need to write data, cause it is not supported
                
                // Disable DO if sample point config is not active
                if bIsDefaultWriteAccessAvailable then
                  DefaultAccesses.WriteAccess.pControlByte^.EnableDO := FALSE;
                end_if;    
                
              end_if;
              
              if FirmwareVersion < AI075_FIRMWARE_VERSION_SAMPLE_POINTS_AVAILABLE then
                
                // Check for compatibility
                if UseSamplePointConfig then
                  eModuleInitState := ERROR;
                  LogError("@ZZZZ (AI075::InitModule) Client UseNewConfigComm is active, but old FirmwareVersion is used. Please update to FirmwareVersion 2.00 or higher or set client value to 0");
                  eInitState := _ClientNotready;
                end_if;
                
                // Old FW Version -> Sample points are not supported
                AI1SamplePoint := -1;
                AI2SamplePoint := -1;
                AI3SamplePoint := -1;
                AI4SamplePoint := -1;
                AI5SamplePoint := -1;
                AI6SamplePoint := -1;
                TISamplePoint := -1;
                bChangeFlag := FALSE; // Old FW Version -> we don't need to write data, cause it is not supported
                                              
              else
                // New Firmware with implemented message counter
                if UseSamplePointConfig & ( sStateFirmware.MessageCounter <> sCfgFirmware.StandardModus.MessageCounter) then
                  eModuleInitState := ERROR;
                  LogError("@ZZZZ (AI075::InitModule) Invalid message counter from Firmware");
                  eInitState := _ClientNotready;
                end_if;
                
                if UseSamplePointConfig then
                
                  //Write values
                  tmpRetcode$DINT := AI1SamplePoint.Write(input:=AI1SamplePoint);
                  
                  //Check for invalid parametervalue
                  if TmpRetcode$DINT = -2 then
                    eModuleInitState := ERROR;
                    LogError("@ZZZZ (AI075::InitModule) Samplepoint setting of AI1 is invalid");
                    eInitState := _ClientNotready;
                  end_if;

                  tmpRetcode$DINT := AI2SamplePoint.Write(input:=AI2SamplePoint);
                  
                  //Check for invalid parametervalue
                  if TmpRetcode$DINT = -2 then
                    eModuleInitState := ERROR;
                    LogError("@ZZZZ (AI075::InitModule) Samplepoint setting of AI2 is invalid");
                    eInitState := _ClientNotready;
                  end_if;
                  
                  tmpRetcode$DINT := AI3SamplePoint.Write(input:=AI3SamplePoint);

                  //Check for invalid parametervalue
                  if TmpRetcode$DINT = -2 then
                    eModuleInitState := ERROR;
                    LogError("@ZZZZ (AI075::InitModule) Samplepoint setting of AI3 is invalid");
                    eInitState := _ClientNotready;
                  end_if;                
                  
                  tmpRetcode$DINT := AI4SamplePoint.Write(input:=AI4SamplePoint);
                  
                  //Check for invalid parametervalue
                  if TmpRetcode$DINT = -2 then
                    eModuleInitState := ERROR;
                    LogError("@ZZZZ (AI075::InitModule) Samplepoint setting of AI4 is invalid");
                    eInitState := _ClientNotready;
                  end_if;
                  
                  tmpRetcode$DINT := AI5SamplePoint.Write(input:=AI5SamplePoint);
                  
                  //Check for invalid parametervalue
                  if TmpRetcode$DINT = -2 then
                    eModuleInitState := ERROR;
                    LogError("@ZZZZ (AI075::InitModule) Samplepoint setting of AI5 is invalid");
                    eInitState := _ClientNotready;
                  end_if;                
                  
                  tmpRetcode$DINT := AI6SamplePoint.Write(input:=AI6SamplePoint);
                  
                  //Check for invalid parametervalue
                  if TmpRetcode$DINT = -2 then
                    eModuleInitState := ERROR;
                    LogError("@ZZZZ (AI075::InitModule) Samplepoint setting of AI6 is invalid");
                    eInitState := _ClientNotready;
                  end_if;                
                  
                  tmpRetcode$DINT := TISamplePoint.Write(input:=TISamplePoint);
                  
                  //Check for invalid parametervalue
                  if TmpRetcode$DINT = -2 then
                    eModuleInitState := ERROR;
                    LogError("@ZZZZ (AI075::InitModule) Samplepoint setting of TI is invalid");
                    eInitState := _ClientNotready;
                  end_if;
                end_if;
                
              end_if;
            else
              eModuleInitState := ERROR;
              LogError("@ZZZZ (AI075::InitModule) Invalid checksum at firmware info");
              eInitState := _ClientNotready;
            end_if;
          else
            eModuleInitState := ERROR;
            LogError("@ZZZZ (AI075::InitModule) Invalid length at firmware info");
            eInitState := _ClientNotready;
          end_if;

      end_case;
//**********************************************************************************************************************************************************
    _Finish:
      eInitSSW         := _InitVariables;
      eModuleInitState := READY;
      eInitState      := _ClassOk;
      
//**********************************************************************************************************************************************************
    _InitError:
      eModuleInitState := ERROR; 
      if (eInitState <> _InvalidConfguration) then
        eInitState      := _ClientNotready;
      end_if;  
      
//**********************************************************************************************************************************************************
  END_CASE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI075::CheckDeviceID
	VAR_INPUT
		udID2Check 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bIsOK 	: BOOL;
	END_VAR
  
	//look if it is right hardware
	if ( udID2Check <> DEVICE_ID_AI075 ) then
		bIsOK := FALSE;
	else
    bIsOK := TRUE;
	end_if;
  
END_FUNCTION

FUNCTION AI075::SetFrequency
	VAR_INPUT
		ClientValue 	: UDINT;
	END_VAR
	VAR_OUTPUT
		Frequency 	: UINT;
	END_VAR
  
  // lookup table for cut off frequency
  case ClientValue of
    6:  Frequency := 10;
    5:  Frequency := 25;
    4:  Frequency := 50;
    3:  Frequency := 100;
    2:  Frequency := 250;
    1:  Frequency := 500;
  else 
        Frequency := 1000;
  end_case;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI075::DisconnectEvent

  SdiasBase::DisconnectEvent();

END_FUNCTION


FUNCTION AI075::AI075
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
  
	ret_code := C_OK;

END_FUNCTION


FUNCTION VIRTUAL AI075::GetTaskCfg
	VAR_OUTPUT
		TaskCfg 	: BDINT;
	END_VAR

  TaskCfg := SDIAS_TASK_MASK_RT_PRE OR SDIAS_TASK_MASK_RT_POST;

END_FUNCTION


FUNCTION VIRTUAL AI075::GetDeviceID
	VAR_OUTPUT
		output 	: UDINT;
	END_VAR
 
  output := DEVICE_ID_AI075;

END_FUNCTION


FUNCTION VIRTUAL AI075::GetFWVersion
	VAR_INPUT
		pData 	: ^CHAR;
		Length 	: UDINT;
	END_VAR
  
  //Check pointer
  if pData then
    //Length of Firmwareversion (HDINT) -> 8Byte +1 byte zero termination
    if Length >= 9 then
      _itoa(udNumber:=FirmwareVersion, pString:=pData);  
    else
      pData^ := 0;
    end_if; 
  end_if;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL AI075::AddAccesses
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
  VAR
  	tempCmd         : CmdStruct;
    _result         : results;
  END_VAR

  //Initvalue
  bIsDefaultWriteAccessAvailable := FALSE;
  
  // Get supported features from sdias manager class
  tempCmd.uiCmd := SDIAS_CMD_GET_SUPPORTED_FEATURES;
  SdiasIn.NewInst(pPara:=#tempCmd, pResult:=#_result);
  
  //Check if info of Default Accesses is available in AddAccesses method
  if _result.aData[0]$t_SDIAS_SupportedFeatureBits1.DefAcc4InitAcc = 1 then  
    if DefaultAccesses.WriteAccess.usLength <> 0 then
      bIsDefaultWriteAccessAvailable := TRUE;
    end_if;
  end_if;

  // Check if default access is available or we have to add it here
  if bIsDefaultWriteAccessAvailable = FALSE then
    
    // Only add accesss is sample point configuration is used
    if UseSamplePointConfig then
      
      // No default access available, add write access here
      if AddWrAccess(hOffset              := AI075_ADDR_CYC_WRITE
                   , uLength              := sizeof(t_s_WriteData)
                   , ppData               := #pWriteData
                   , ppStateByte          := #sWriteAccess.pStateByte
                   , ppControlByte        := #sWriteAccess.pControlByte
                   , pAccessHandle        := #sWriteAccess.AccessHandle
                   ) <> READY then
        LogError("@ZZZZ (AI075::AddAccesses) Adding write access for sample points failed");
      end_if;
    end_if;
  end_if;
  
  eModuleInitState := READY;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI075::AI1SamplePoint::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  if FirmwareVersion >= AI075_FIRMWARE_VERSION_SAMPLE_POINTS_AVAILABLE & UseSamplePointConfig = TRUE then
    if input >= AI075_SAMPLE_POINTS_OFFSET_AFTER_SYNC & input <= ((udBusTime$DINT/1000) - AI075_SAMPLE_POINTS_OFFSET_BEFORE_SYNC) then
      result := input;  
      bChangeFlag := TRUE;
      AI1SamplePoint := result;
    else
      result := -2; // Invalid input parameter
    end_if;
  else
    result := -1; // Invalid firmwareversion, or feature inactive
  end_if;  
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI075::AI2SamplePoint::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if FirmwareVersion >= AI075_FIRMWARE_VERSION_SAMPLE_POINTS_AVAILABLE & UseSamplePointConfig = TRUE then
    if input >= AI075_SAMPLE_POINTS_OFFSET_AFTER_SYNC & input <= ((udBusTime$DINT/1000) - AI075_SAMPLE_POINTS_OFFSET_BEFORE_SYNC) then
      result := input;  
      bChangeFlag := TRUE;
      AI2SamplePoint := result;
    else
      result := -2; // Invalid input parameter
    end_if;
  else
    result := -1; // Invalid firmwareversion, or feature inactive
  end_if;  

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI075::AI3SamplePoint::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if FirmwareVersion >= AI075_FIRMWARE_VERSION_SAMPLE_POINTS_AVAILABLE & UseSamplePointConfig = TRUE then
    if input >= AI075_SAMPLE_POINTS_OFFSET_AFTER_SYNC & input <= ((udBusTime$DINT/1000) - AI075_SAMPLE_POINTS_OFFSET_BEFORE_SYNC) then
      result := input;  
      bChangeFlag := TRUE;
      AI3SamplePoint := result;
    else
      result := -2; // Invalid input parameter
    end_if;
  else
    result := -1; // Invalid firmwareversion, or feature inactive
  end_if;  
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI075::AI4SamplePoint::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  if FirmwareVersion >= AI075_FIRMWARE_VERSION_SAMPLE_POINTS_AVAILABLE & UseSamplePointConfig = TRUE then
    if input >= AI075_SAMPLE_POINTS_OFFSET_AFTER_SYNC & input <= ((udBusTime$DINT/1000) - AI075_SAMPLE_POINTS_OFFSET_BEFORE_SYNC) then
      result := input;  
      bChangeFlag := TRUE;
     AI4SamplePoint := result;
    else
      result := -2; // Invalid input parameter
    end_if;
  else
    result := -1; // Invalid firmwareversion, or feature inactive
  end_if;  
    
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI075::AI5SamplePoint::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if FirmwareVersion >= AI075_FIRMWARE_VERSION_SAMPLE_POINTS_AVAILABLE & UseSamplePointConfig = TRUE then
    if input >= AI075_SAMPLE_POINTS_OFFSET_AFTER_SYNC & input <= ((udBusTime$DINT/1000) - AI075_SAMPLE_POINTS_OFFSET_BEFORE_SYNC) then
      result := input;  
      bChangeFlag := TRUE;
      AI5SamplePoint := result;
    else
      result := -2; // Invalid input parameter
    end_if;
  else
    result := -1; // Invalid firmwareversion, or feature inactive
  end_if;
   
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI075::AI6SamplePoint::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if FirmwareVersion >= AI075_FIRMWARE_VERSION_SAMPLE_POINTS_AVAILABLE & UseSamplePointConfig = TRUE then
    if input >= AI075_SAMPLE_POINTS_OFFSET_AFTER_SYNC & input <= ((udBusTime$DINT/1000) - AI075_SAMPLE_POINTS_OFFSET_BEFORE_SYNC) then
      result := input;
      bChangeFlag := TRUE;
      AI6SamplePoint := result;
    else
      result := -2; // Invalid input parameter
    end_if;
  else
    result := -1; // Invalid firmwareversion, or feature inactive
  end_if;  
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI075::TISamplePoint::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
 
  if FirmwareVersion >= AI075_FIRMWARE_VERSION_SAMPLE_POINTS_AVAILABLE & UseSamplePointConfig = TRUE then
    if input >= AI075_SAMPLE_POINTS_OFFSET_AFTER_SYNC & input <= ((udBusTime$DINT/1000) - AI075_SAMPLE_POINTS_OFFSET_BEFORE_SYNC)  then
      result := input;  
      bChangeFlag := TRUE;
      TISamplePoint := result;
    else
      result := -2; // Invalid input parameter
    end_if;
  else
    result := -1; // Invalid firmwareversion, or feature inactive
  end_if;
      
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI075::ActivateSamplePointConfig::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  bChangeFlag := TRUE;

  if input then
    result := 1;
    ActivateSamplePointConfig := 1;
  else
    result := 0;
    ActivateSamplePointConfig := 0;
  end_if;

END_FUNCTION
