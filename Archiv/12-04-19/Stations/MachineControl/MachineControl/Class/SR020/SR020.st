//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define DEVICE_ID_SR020             1015        //DeviceID of SR020

#define SR020_ADDR_CYC_WRITE        16#00       //Address for TPDO
#define SR020_ADDR_CYC_READ         16#0A       //Address for RPDO


#define SR020_ADDR_CFG_FIRMWARE     16#200      //Address-Offset to the Configuration of the Firmware
#define SR020_ADDR_STATE_FIRMWARE   16#280      //Address-Offset to the Status of the Firmware
#define SR020_ADDR_I2T_THRESHOLD    16#20       //Address-Offset to Write I²T Threshold
#define SR020_ADDR_LED_MAX          16#18       //Address-Offset to get LED Configuration-Values


//Define for the H-Brdige
//-----------------------------------------------------------
#define SR020_GATE_A_LOW		          2#0100000000000000    //Bit-Configuration for Enable GateA Low-Switch
#define SR020_GATE_A_HIGH		          2#0001000000000000    //Bit-Configuration for Enable GateA High-Switch
#define SR020_GATE_B_LOW		          2#1000000000000000    //Bit-Configuration for Enable GateB Low-Switch
#define SR020_GATE_B_HIGH		          2#0010000000000000    //Bit-Configuration for Enable GateB High-Switch  

#define SR020_MASK_CONTROL	          16#0FFF     //Mask for Output Sequence Bits
#define SR020_MASK_TIME		            16#F000     //Mask for TimeValue

#define SR020_T_SWITCH                41      //Delay Time for Switch
#define SR020_DEFAULT_SEQ_INIT        1       //Initilization for Sequencer => After 1 FPGA-Cycle switch to next Sequency


#define SR020_FPGA_FREQ_MHZ           50    //Frequency of FPGA

#define SR020_SDO_RESPONSE_TIMEOUT  SDIAS_SDO_TIMEOUT * 2     //SDO-Response Timeout

//#define SR020_I2T_THRESHOLD          16000000   //Maximal allowed I²T Value in mA²s ==> 16 A²s
//#pragma message ("TarPet: dieser Wert wurde vorest empirisch ermittelt und sollte noch genau bestimmt werden");
#define SR020_I2T_THRESHOLD          78000   //Maximal allowed I²T Value in mA²s ==> 16 A²s

#define SR020_SPEED_SCALING          10000      //Scaling of the Server Speed (0.00% to 100.00%)
#define SR020_MINPULSE_SCALING       1000       //Scaling of the Server MinPulse (0.0% to 100.0%)

#define SR020_STATUS_BITS_LATCHED  2#0001110011110 // no DC OK info, no sequencer info, no Overtemperature and no I2C error
#define SR020_STATUS_BITS          2#1010000000000 // Overtemperature and I2C error
#define SR020_STATUS_BITS_INVERTED 2#0000001100001 // DC OK info and sequencer info


//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "SR020"
	Revision           = "1.34"
	GUID               = "{A704A6E0-948D-4221-8039-975ED191F902}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\s-dias.ico"
	SharedCommandTable = "true"
	Objectsize         = "(778,120)"
	Comment            = "SDIAS DC-Motor Module which supports&#13;&#10;1 x DC motor drive 3.5 A&#13;&#10;1 x Power LED out 20 mA&#13;&#10;1 x Power LED out 350 mA">
	<Channels>
		<Server Name="Enable" GUID="{D4F6A90D-763E-40F4-90AD-845CDAFE6A59}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Server to Enable the DC-Motor&#13;&#10;0 = Disabled&#13;&#10;1 = Enable"/>
		<Server Name="ErrorBits" GUID="{C636C30C-2491-4C12-B617-EE90700D91D5}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Error Bits:&#13;&#10;Bit0...Not used&#13;&#10;Bit1...No Sync&#13;&#10;Bit2...Flash data CRC error&#13;&#10;Bit3...Ram data CRC error&#13;&#10;Bit4...No valid EEPROM Version&#13;&#10;..&#13;&#10;Bit16..Sequence disabled&#13;&#10;Bit17..Wrong sequence&#13;&#10;Bit18..Absolute time error&#13;&#10;Bit19..Motor current high&#13;&#10;Bit20..Motor current too high&#13;&#10;Bit21..External supply voltage not ok&#13;&#10;Bit22..Motor supply voltage not ok&#13;&#10;Bit23..Periphery reset LED&#13;&#10;Bit24..Periphery reset Motor&#13;&#10;Bit25..Induction voltage too high&#13;&#10;Bit26..Over temperature error&#13;&#10;..&#13;&#10;Bit28..I²T Error&#13;&#10;"/>
		<Server Name="ErrorQuit" GUID="{A138ABDF-7EE4-4181-ACDC-C09A460A301C}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Write 1 to quit the error bits"/>
		<Server Name="FirmwareVersion" GUID="{20910AAF-4461-403C-9B2B-4EDD87ECB06F}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Version of the used firmware"/>
		<Server Name="I2T" GUID="{D8F24096-C019-4D31-A309-127AE2817976}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="actual I²T Value."/>
		<Server Name="Led20" GUID="{4952FC46-601A-4ACD-8DE3-32715E42EC1C}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Intensity of the LED (8 Bit Value)."/>
		<Server Name="Led350" GUID="{FBE557C2-E061-4010-8765-3239CDF4C48D}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Intensity of the LED (8 Bit Value)."/>
		<Server Name="MinPulse" GUID="{F29A3197-B26E-44D6-933C-81E1BE26150F}" Visualized="true" Initialize="true" DefValue="7" WriteProtected="false" Retentive="false" Comment="Minimal Pulsewidth of PWM [0,1%]&#13;&#10;A change of this value will takes action after writing a new value to server SetSpeed."/>
		<Server Name="MotorCurrent" GUID="{1A3E7B79-A6C4-481C-915D-7C2E84DA95B5}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="actual Motor Current [mA]"/>
		<Server Name="SetSpeed" GUID="{C4C3F0CB-31E7-468F-8BCE-3BBA726548AD}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Set-Velocity of the Motor. [0.01%]&#13;&#10;Min-Value (negative Direction): -10000 = -100,00%&#13;&#10;Max-Value (positive Direction): 10000  = 100,00%&#13;&#10;"/>
		<Server Name="Temperature" GUID="{10DC733E-42F1-49B0-ACDD-BC9FB3E0D632}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="actual Temperature of the Module (°C)"/>
		<Server Name="VoltageOk" GUID="{4C6B6E07-23DF-495B-9EA6-294C395A79D1}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Voltage supply is ok"/>
		<Server Name="VoltageOkMotor" GUID="{08976ABE-1087-4D65-B17F-64F3494C849D}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Voltage Supply for Motor is Ok"/>
		<Client Name="I2TThreshold" Required="true" Internal="false" DefValue="100" Comment="This client is used to set the I2C threshold in percent of the maximum threshold (maximum allowed I2T value of the hardware). A violation of this threshold causes an I2T error which leads to a switching off of the motor output."/>
		<Client Name="PWMPeriod" Required="true" Internal="false" DefValue="32" Comment="Sequencer PWM period in µs."/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="ObeChr"/>
		<Dokumentation Revision="1.34" Date="08.06.2018" Author="RamAnd" Company="Sigmatek" Description="LASAL Hardware Description (.lhd) file has been updated."/>
		<Dokumentation Revision="1.33" Date="23.01.2018" Author="RamAnd" Company="Sigmatek" Description="Log messages have been standardized for easier maintenance, easier use in any class and to allow spam filtering. Code for the logging functions is now only located in HwControl."/>
		<Dokumentation Revision="1.32" Date="16.05.2017" Author="RamAnd" Company="Sigmatek" Description="When adding an SDO (i.e. via ReadSPIData) from background priority it was possible that the adding process got interrupted by receiving the answer to this SDO which is handled in cyclic priority. In the error case the answer was unexpected and therefore ignored. Then the class signals a timeout while waiting for the answer, which already arrived before waiting for it. Added mutex and changed instruction order to prevent this error."/>
		<Dokumentation Revision="1.31" Date="12.07.2016" Author="SeiChr" Company="Sigmatek" Description="Added Values for the total Current calculation. SA 31571"/>
		<Dokumentation Revision="1.30" Date="01.03.2016" Author="EisMic" Company="Sigmatek" Description="Corrected BoundExceed Error in base class at Write method of LEDControl Server when Place = LSL_DEACTIVATED."/>
		<Dokumentation Revision="1.29" Date="09.07.2015" Author="PieSte" Company="Sigmatek" Description="Corrected cast for pointer in methode ReceiveSDOResponse()."/>
		<Dokumentation Revision="1.28" Date="17.06.2015" Author="EisMic" Company="Sigmatek" Description="The servers FPGAVersion, SerialNo, Device ID and status and input servers are now not reset anymore when the module is disconnected."/>
		<Dokumentation Revision="1.27" Date="27.05.2015" Author="EisMic" Company="Sigmatek" Description="Corrected ConnectEvent Method that outputs are set after reconnect."/>
		<Dokumentation Revision="1.26" Date="16.04.2015" Author="EisMic&#13;&#10;LanSte" Company="Sigmatek" Description="Added support for visualisation in graphical hardware editor.&#13;&#10;Added support for calculating resources for graphical hardware editor."/>
		<Dokumentation Revision="1.25" Date="17.03.2015" Author="RamAnd" Company="Sigmatek" Description="Added HW Version for sdias clients."/>
		<Dokumentation Revision="1.24" Date="11.02.2015" Author="PieSte" Company="Sigmatek" Description="Corrected read spi data for hardwaretree in methode GetSPIDataFromID from baseclass."/>
		<Dokumentation Revision="1.23" Date="18.11.2014" Author="PieSte" Company="Sigmatek" Description="Added possibility  to read more data from spi flash then one sdo access.&#13;&#10;Set methode GetDeviceID to global.&#13;&#10;Add methode to calculate checksum of spi flash."/>
		<Dokumentation Revision="1.22" Date="27.10.2014" Author="lanste" Description="Corrected error: OverTemperatureError was sometimes set after startup.&#13;&#10;Errorquitflags were not auomaitically reset in the PDO after quiting an error."/>
		<Dokumentation Revision="1.21" Date="04.07.2014" Author="EisMic" Company="Sigmatek" Description="Added support for reading hardware diagnosis and hardwaretree entry."/>
		<Dokumentation Revision="1.20" Date="20.01.2014" Author="PieSte" Company="Sigmatek" Description="Read Client Required and Place in Init SdiasBase"/>
		<Dokumentation Revision="1.10" Date="05.12.2013" Author="RamAnd" Company="Sigmatek" Description="Changed login mechanism to sdias manager class to be independent of bus accesses."/>
		<Dokumentation Revision="1.0" Date="02.08.2013" Author="ObeChr" Company="Sigmatek" Description="First library version"/>
	</RevDoku>
	<Network Name="SR020">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{9D210CB4-56AE-407E-BFAA-342F76987F71}"
				Class      = "SdiasBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassState"/>
					<Server Name="DeviceID"/>
					<Server Name="FPGAVersion"/>
					<Server Name="HwVersion"/>
					<Server Name="LEDControl" Value="0"/>
					<Server Name="RetryCounter"/>
					<Server Name="SDOState"/>
					<Server Name="SerialNo"/>
					<Client Name="Place" Value="0"/>
					<Client Name="Required" Value="1"/>
					<Client Name="SdiasIn"/>
					<Client Name="ToStdLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassState" Destination="_base.ClassState" Vertices="(804,210),(632,210),"/>
			<Connection Source="this.DeviceID" Destination="_base.DeviceID" Vertices="(804,270),(632,270),"/>
			<Connection Source="this.SerialNo" Destination="_base.SerialNo" Vertices="(804,450),(632,450),"/>
			<Connection Source="this.RetryCounter" Destination="_base.RetryCounter" Vertices="(804,510),(632,510),"/>
			<Connection Source="this.LEDControl" Destination="_base.LEDControl" Vertices="(804,570),(632,570),"/>
			<Connection Source="_base.SdiasIn" Destination="this.SdiasIn" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.Place" Destination="this.Place" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.Required" Destination="this.Required" Vertices="(218,330),(38,330),"/>
			<Connection Source="this.FPGAVersion" Destination="_base.FPGAVersion" Vertices="(804,330),(632,330),"/>
			<Connection Source="this.HwVersion" Destination="_base.HwVersion" Vertices="(804,390),(632,390),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using SdiasBase

SR020 : CLASS
: SdiasBase
	TYPE
	  t_bi_SeqData : BINT  //! <Type Comment="Sequence Data." Name="t_bi_SeqData"/>
	  [
	    1 bTimeBit0,  //! <Type Comment="Sequence time value (11 Bits)." Name="t_bi_SeqData.bTimeBit0"/>
	    2 bTimeBit1,  //! <Type Comment="Sequence time value (11 Bits)." Name="t_bi_SeqData.bTimeBit1"/>
	    3 bTimeBit2,  //! <Type Comment="Sequence time value (11 Bits)." Name="t_bi_SeqData.bTimeBit2"/>
	    4 bTimeBit3,  //! <Type Comment="Sequence time value (11 Bits)." Name="t_bi_SeqData.bTimeBit3"/>
	    5 bTimeBit4,  //! <Type Comment="Sequence time value (11 Bits)." Name="t_bi_SeqData.bTimeBit4"/>
	    6 bTimeBit5,  //! <Type Comment="Sequence time value (11 Bits)." Name="t_bi_SeqData.bTimeBit5"/>
	    7 bTimeBit6,  //! <Type Comment="Sequence time value (11 Bits)." Name="t_bi_SeqData.bTimeBit6"/>
	    8 bTimeBit7,  //! <Type Comment="Sequence time value (11 Bits)." Name="t_bi_SeqData.bTimeBit7"/>
	    9 bTimeBit8,  //! <Type Comment="Sequence time value (11 Bits)." Name="t_bi_SeqData.bTimeBit8"/>
	    10 bTimeBit9,  //! <Type Comment="Sequence time value (11 Bits)." Name="t_bi_SeqData.bTimeBit9"/>
	    11 bTimeBit10,  //! <Type Comment="Sequence time value (11 Bits)." Name="t_bi_SeqData.bTimeBit10"/>
	    12 bTimeCount,  //! <Type Comment="0 = take relative Time Counter&#13;&#10;1 = take absolute Time Counter            &#13;&#10;" Name="t_bi_SeqData.bTimeCount"/>
	    13 bLeftHigh,  //! <Type Comment="H-bridge element." Name="t_bi_SeqData.bLeftHigh"/>
	    14 bRightHigh,  //! <Type Comment="H-bridge element." Name="t_bi_SeqData.bRightHigh"/>
	    15 bLeftLow,  //! <Type Comment="H-bridge element." Name="t_bi_SeqData.bLeftLow"/>
	    16 bRightLow,  //! <Type Comment="H-bridge element." Name="t_bi_SeqData.bRightLow"/>
	  ];
	  t_e_InitSSW :  //! <Type Comment="State definition for Initialization." Name="t_e_InitSSW"/>
	  (
	    Init_Variables,  //! <Type Comment="Initialize default value." Name="t_e_InitSSW.Init_Variables"/>
	    Init_Firmware,  //! <Type Comment="SDO write access to firmware (writes config data)." Name="t_e_InitSSW.Init_Firmware"/>
	    Init_GetStateFW,  //! <Type Comment="SDO read access to firmware (read status data)." Name="t_e_InitSSW.Init_GetStateFW"/>
	    Init_ConfigModule,  //! <Type Comment="SDO write access to CPLD (writes config data)." Name="t_e_InitSSW.Init_ConfigModule"/>
	    Init_GetConfigLed,
	    Init_Finish,  //! <Type Comment="Finish initialization." Name="t_e_InitSSW.Init_Finish"/>
	    Init_QuitError,
	    Init_Error  //! <Type Comment="Error in initialization." Name="t_e_InitSSW.Init_Error"/>
	  )$UDINT;
	  t_e_SDOState :  //! <Type Comment="SDO Response states." Name="t_e_SDOState"/>
	  (
	    SDO_Idle,  //! <Type Comment="No SDO transmission." Name="t_e_SDOState.SDO_Idle"/>
	    SDO_Wait,  //! <Type Comment="SDO transmission in progress." Name="t_e_SDOState.SDO_Wait"/>
	    SDO_Valid  //! <Type Comment="SDO transmission succeeded." Name="t_e_SDOState.SDO_Valid"/>
	  )$UDINT;
#pragma pack(push, 1)
	  t_s_FWConfiguration : STRUCT  //! <Type Comment="Configuration Data of from HW-Class to Firmware." Name="t_s_FWConfiguration"/>
	    hCRC : HINT;  //! <Type Comment="Checksum of Datablock" Name="t_s_FWConfiguration.hCRC"/>
	    uDataLength : UINT;  //! <Type Comment="Length of Datablock&#13;&#10;" Name="t_s_FWConfiguration.uDataLength"/>
	    Info : BSINT  //! <Type Comment="Info (Special-Purpose / Statusbits)" Name="t_s_FWConfiguration.Info"/>
	    [
	      1 PMBModus,  //! <Type Comment="Mode for Firmware&#13;&#10;&#13;&#10;0 = standard Mode&#13;&#10;1 = PMB Mode" Name="t_s_FWConfiguration.Info.PMBModus"/>
	      2 BootLoaderUpdateRequest,  //! <Type Comment="Update request for bootloader." Name="t_s_FWConfiguration.Info.BootLoaderUpdateRequest"/>
	    ];
	    Reserved : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_FWState : STRUCT  //! <Type Comment="Configuration Data of from Firmware to HW-Class." Name="t_s_FWState"/>
	    hCRC : HINT;  //! <Type Comment="Checksum of Datablock" Name="t_s_FWState.hCRC"/>
	    uDataLength : UINT;  //! <Type Comment="Length of Datablock" Name="t_s_FWState.uDataLength"/>
	    hFWVersion : HINT;  //! <Type Comment="Firmware Verion." Name="t_s_FWState.hFWVersion"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_LEDConfiguration : STRUCT
	    uPWMPrescaler20mA : UINT;
	    uPWMPrescaler350mA : UINT;
	    usMaxValue20mA : USINT;
	    usMaxValue350mA : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_MotorConfiguration : STRUCT  //! <Type Comment="CPLD address space for SDO communication." Name="t_s_MotorConfiguration"/>
	    usI2tTreshold : UDINT;  //! <Type Comment="Maximal I²T value (only 21 Bit)" Name="t_s_MotorConfiguration.usI2tTreshold"/>
	  END_STRUCT;
#pragma pack(pop)
	  t_SR_State : BINT
	  [
	    1 bSequenceEnabled,  //! <Type Comment="Sequence enable bit (only used in Status register)." Name="t_SR_State.bSequenceEnabled"/>
	    2 bWrongSequence,  //! <Type Comment="Wrong Sequence occured (forbidden Setting of the Output Sequence Bits) - only used in Status register latched." Name="t_SR_State.bWrongSequence"/>
	    3 bAbsoluteTimeError,  //! <Type Comment="Absolute Time Error occurred (the absolute Time Values must rise on each Sequence) - only used in Status register latched.." Name="t_SR_State.bAbsoluteTimeError"/>
	    4 bMotorCurrentHigh,  //! <Type Comment="High Motor Current." Name="t_SR_State.bMotorCurrentHigh"/>
	    5 bMotorCurrentTooHigh,  //! <Type Comment="Motor Current too high (additional Periphery reset occurs)." Name="t_SR_State.bMotorCurrentTooHigh"/>
	    6 bDCOkExt,  //! <Type Comment="DC_ok (Extern Supply for LEDs, Current measurement(OpAmp))." Name="t_SR_State.bDCOkExt"/>
	    7 bDCOKMotor,  //! <Type Comment="Supply Voltage Motor" Name="t_SR_State.bDCOKMotor"/>
	    8 bPeripheryResetLED,  //! <Type Comment="Periphery Reset occured on LED Device." Name="t_SR_State.bPeripheryResetLED"/>
	    9 bPeripheryResetMotor,  //! <Type Comment="Periphery Reset occured on Sequencer Device." Name="t_SR_State.bPeripheryResetMotor"/>
	    10 bInductionVoltageTooHigh,  //! <Type Comment="Induction Voltage from Motor too high (additional Periphery Reset occurs) " Name="t_SR_State.bInductionVoltageTooHigh"/>
	    11 bOverTemperatureError,  //! <Type Comment="Over temperature &gt;95°C" Name="t_SR_State.bOverTemperatureError"/>
	    13 bI2TError,  //! <Type Comment="I²T Error occured" Name="t_SR_State.bI2TError"/>
	  ];
#pragma pack(push, 1)
	  t_s_ReadData : STRUCT  //! <Type Comment="Cyclic read memory space." Name="t_s_ReadData"/>
	    uiTemperature : UINT;  //! <Type Comment="Actual Temperature in Kelvin." Name="t_s_ReadData.uiTemperature"/>
	    iActCurrent : INT;  //! <Type Comment="Actual Motor Current." Name="t_s_ReadData.iActCurrent"/>
	    biStatusLatch : t_SR_State;  //! <Type Comment="Hardware Status Register latched (clear on read excl. OverTemperatureError and I2TError)." Name="t_s_ReadData.biStatusLatch"/>
	    biStatus : t_SR_State;  //! <Type Comment="Hardware Status Register" Name="t_s_ReadData.biStatus"/>
	    I2TValue : UDINT;  //! <Type Comment="Actual I²T value." Name="t_s_ReadData.I2TValue"/>
	    Status : t_b_SdiasFWState;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_SeqData1234 : STRUCT
	    Seq1 : t_bi_SeqData;
	    Seq2 : t_bi_SeqData;
	    Seq3 : t_bi_SeqData;
	    Seq4 : t_bi_SeqData;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_WriteData : STRUCT  //! <Type Comment="Cyclic configuration information for hardware." Name="t_s_WriteData"/>
	    sSeqData1 : t_bi_SeqData;  //! <Type Comment="Sequencer 1 Data" Name="t_s_WriteData.sSeqData1"/>
	    sSeqData2 : t_bi_SeqData;  //! <Type Comment="Sequencer 2 Data" Name="t_s_WriteData.sSeqData2"/>
	    sSeqData3 : t_bi_SeqData;  //! <Type Comment="Sequencer 3 Data" Name="t_s_WriteData.sSeqData3"/>
	    sSeqData4 : t_bi_SeqData;  //! <Type Comment="Sequencer 4 Data" Name="t_s_WriteData.sSeqData4"/>
	    uiPeriodTime : UINT;  //! <Type Comment="Sequencer Period Time" Name="t_s_WriteData.uiPeriodTime"/>
	    usPWMLed20 : USINT;  //! <Type Comment="Raw Value for PWM Output on Time for 20mA LED." Name="t_s_WriteData.usPWMLed20"/>
	    usPWMLed350 : USINT;  //! <Type Comment="Raw Value for PWM Output on Time for 350mA LED." Name="t_s_WriteData.usPWMLed350"/>
	    biControl : BINT  //! <Type Comment="Hardware Control Register." Name="t_s_WriteData.biControl"/>
	    [
	      1 bSeqEnable,  //! <Type Comment="Sequencer enable" Name="t_s_WriteData.biControl.bSeqEnable"/>
	      4 bMotorCurrentHighEn,  //! <Type Comment="Enable latched High Motor Current." Name="t_s_WriteData.biControl.bMotorCurrentHighEn"/>
	      5 bMotorCurrentTooHighEn,  //! <Type Comment="Enable latched Motor Current too high." Name="t_s_WriteData.biControl.bMotorCurrentTooHighEn"/>
	      6 bDCOkExtEn,  //! <Type Comment="Enable latched DC (Extern Supply for LEDs, Current Measurement(OpAmp))." Name="t_s_WriteData.biControl.bDCOkExtEn"/>
	      7 bDCOkMotorEn,  //! <Type Comment="Enable latched DC Motor." Name="t_s_WriteData.biControl.bDCOkMotorEn"/>
	      8 bPeripheryResetLedEn,  //! <Type Comment="Enable latched Periphery Reset LED." Name="t_s_WriteData.biControl.bPeripheryResetLedEn"/>
	      9 bPeripheryResetMotorEn,  //! <Type Comment="Enable latched Periphery Reset Motor." Name="t_s_WriteData.biControl.bPeripheryResetMotorEn"/>
	      10 bInductionVoltageTooHighEn,  //! <Type Comment="Enable latched Induction Voltage from Motor too high (additional Periphery Reset occurs)." Name="t_s_WriteData.biControl.bInductionVoltageTooHighEn"/>
	      11 bOverTemperatureSwOffEn,  //! <Type Comment="1 = Over Temperature - switch off enable." Name="t_s_WriteData.biControl.bOverTemperatureSwOffEn"/>
	      12 bQuitOverTemperatureError,  //! <Type Comment="1 = Quit (clear) Over Temperature 95°C." Name="t_s_WriteData.biControl.bQuitOverTemperatureError"/>
	      13 bI2tSwOffEn,  //! <Type Comment="1 = I2T Error - switch off enable." Name="t_s_WriteData.biControl.bI2tSwOffEn"/>
	      14 bQuitI2tError,  //! <Type Comment="1 = Quit (clear) I2T error." Name="t_s_WriteData.biControl.bQuitI2tError"/>
	      15 bLed20En,  //! <Type Comment="LED 20mA PWM SW enable (1 = on)." Name="t_s_WriteData.biControl.bLed20En"/>
	      16 bLed350En,  //! <Type Comment="LED 350mA PWM SW enable (1 = on)." Name="t_s_WriteData.biControl.bLed350En"/>
	    ];
	  END_STRUCT;
#pragma pack(pop)
	  t_SR_Error_State : BINT
	  [
	    1 bSequenceDisabled,  //! <Type Comment="Inverted sequence enable bit" Name="t_SR_Error_State.bSequenceDisabled"/>
	    2 bWrongSequence,  //! <Type Comment="Wrong Sequence occured (forbidden Setting of the Output Sequence Bits)." Name="t_SR_Error_State.bWrongSequence"/>
	    3 bAbsoluteTimeError,  //! <Type Comment="Absolute Time Error occurred (the absolute Time Values must rise on each Sequence)." Name="t_SR_Error_State.bAbsoluteTimeError"/>
	    4 bMotorCurrentHigh,  //! <Type Comment="High Motor Current." Name="t_SR_Error_State.bMotorCurrentHigh"/>
	    5 bMotorCurrentTooHigh,  //! <Type Comment="Motor Current too high (additional Periphery reset occurs)." Name="t_SR_Error_State.bMotorCurrentTooHigh"/>
	    6 bExternDCNotOK,  //! <Type Comment="Extern Supply for LEDs, Current measurement(OpAmp) is not OK" Name="t_SR_Error_State.bExternDCNotOK"/>
	    7 bMotorDCNotOK,  //! <Type Comment="Motor Supply Voltage is not OK" Name="t_SR_Error_State.bMotorDCNotOK"/>
	    8 bPeripheryResetLED,  //! <Type Comment="Periphery Reset occured on LED Device." Name="t_SR_Error_State.bPeripheryResetLED"/>
	    9 bPeripheryResetMotor,  //! <Type Comment="Periphery Reset occured on Sequencer Device." Name="t_SR_Error_State.bPeripheryResetMotor"/>
	    10 bInductionVoltageTooHigh,  //! <Type Comment="Induction Voltage from Motor too high (additional Periphery Reset occurs) " Name="t_SR_Error_State.bInductionVoltageTooHigh"/>
	    11 bOverTemperatureError,  //! <Type Comment="Over temperature &gt;95°C" Name="t_SR_Error_State.bOverTemperatureError"/>
	    13 bI2TError,  //! <Type Comment="I²T Error occured" Name="t_SR_Error_State.bI2TError"/>
	  ];
#pragma pack(push, 1)
	  t_SDIAS_Fw_State_SR : STRUCT  //! <Type Public="true" Name="t_SDIAS_Fw_State_SR"/>
	    StandardState : t_b_SdiasFWState;
	    SRState : t_SR_Error_State;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	FirmwareVersion 	: SvrCh_HDINT;
	ErrorBits 	: SvrCh_t_SDIAS_Fw_State_SR_PTofCls_SR020;
	Led20 	: SvrCh_DINT;
	Led350 	: SvrCh_DINT;
	Enable 	: SvrCh_DINT;
	SetSpeed 	: SvrCh_DINT;
	MinPulse 	: SvrCh_DINT;
	MotorCurrent 	: SvrCh_DINT;
	Temperature 	: SvrCh_DINT;
	I2T 	: SvrCh_UDINT;
	ErrorQuit 	: SvrCh_DINT;
	VoltageOk 	: SvrCh_DINT;
	VoltageOkMotor 	: SvrCh_DINT;
  //Clients:
	PWMPeriod 	: CltCh_UDINT;
	I2TThreshold 	: CltCh_UDINT;
  //Variables:
		eInitSSW 	: t_e_InitSSW;			//! <Variable Comment="State of the initialization." Name="eInitSSW"/>
		eInitSSWErrorStep 	: t_e_InitSSW;			//! <Variable Comment="Stores the init state in case of an error." Name="eInitSSWErrorStep"/>
		eResponseState 	: t_e_SDOState;			//! <Variable Comment="SDO response state" Name="eResponseState"/>
		pReadData 	: ^t_s_ReadData;			//! <Variable Comment="Pointer to read-Data, used for cyclic communication." Name="pReadData"/>
		pWriteData 	: ^t_s_WriteData;			//! <Variable Comment="Pointer to write data, used for cyclic communication." Name="pWriteData"/>
		sConfiguration 	: t_s_MotorConfiguration;			//! <Variable Comment="Memory area for SDO communication." Name="sConfiguration"/>
		sFWConfiguration 	: t_s_FWConfiguration;
		sFWState 	: t_s_FWState;			//! <Variable Comment="Memory area for data transfer from firmware to software." Name="sFWState"/>
		sLEDConfig 	: t_s_LEDConfiguration;			//! <Variable Comment="Configuration for LEDs" Name="sLEDConfig"/>
		sReadData 	: t_s_ReadData;
		sWriteData 	: t_s_WriteData;			//! <Variable Comment="Write data, used for cyclic communication." Name="sWriteData"/>
		udSDOTimeout 	: UDINT;			//! <Variable Comment="Used to detect a SDO response timeout." Name="udSDOTimeout"/>
		uiPeriodCount 	: UINT;			//! <Variable Comment="Sequencer period length (FPGA clock * PWM Period of sequencer)." Name="uiPeriodCount"/>
		uiTimeMin 	: UINT;			//! <Variable Comment="Minimum sequence period" Name="uiTimeMin"/>
		bUpdateSeqData 	: BOOL;
		sSeqData 	: t_s_SeqData1234;
  //Functions:
				//! <Function Comment="Constructor of Class." Name="SR020"/>
	FUNCTION SR020
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="Realtime Update Methode which runs in PreScan." Name="UpdateRt"/>
	FUNCTION VIRTUAL GLOBAL UpdateRt;
				//! <Function Comment="Realtime Update Methode which runs in PostScan." Name="UpdateRtPostScan"/>
	FUNCTION VIRTUAL GLOBAL UpdateRtPostScan;
				//! <Function Comment="Methode is called if this Module gets connected." Name="ConnectEvent"/>
	FUNCTION VIRTUAL GLOBAL ConnectEvent;
				//! <Function Comment="Methode is called if this Module gets disconnected." Name="DisconnectEvent"/>
	FUNCTION VIRTUAL GLOBAL DisconnectEvent;
				//! <Function Comment="Methode should be used to run a Statemachine to Initialize the Module." Name="InitModule"/>
	FUNCTION VIRTUAL GLOBAL InitModule
		VAR_OUTPUT
			eModuleInitState 	: iprStates;			//! <Variable Comment="Return BUSY until the Initialisation is finished." Name="InitModule.eModuleInitState"/>
		END_VAR;
				//! <Function Comment="This Methode should be used, to check the DeviceID of the Module." Name="CheckDeviceID"/>
	FUNCTION VIRTUAL GLOBAL CheckDeviceID
		VAR_INPUT
			udID2Check 	: UDINT;			//! <Variable Comment="Device ID of connected Module." Name="CheckDeviceID.udID2Check"/>
		END_VAR
		VAR_OUTPUT
			bIsOK 	: BOOL;			//! <Variable Comment="FALSE = Wrong DeviceID for Module&#13;&#10;TRUE  = DeviceID of Module is correct" Name="CheckDeviceID.bIsOK"/>
		END_VAR;
				//! <Function Comment="Methode to receive the Response in case of SDO-Communication." Name="ReceiveSDOResponse"/>
	FUNCTION VIRTUAL ReceiveSDOResponse
		VAR_INPUT
			eCommand 	: t_SDIAS_SDO_Cmd;			//! <Variable Comment="Type of SDO-Command" Name="ReceiveSDOResponse.eCommand"/>
			hOffset 	: HINT;			//! <Variable Comment="Address-Offset in Module." Name="ReceiveSDOResponse.hOffset"/>
			usLength 	: USINT;			//! <Variable Comment="Length of Data." Name="ReceiveSDOResponse.usLength"/>
			eResult 	: iprStates;			//! <Variable Comment="State of SDO-Communication." Name="ReceiveSDOResponse.eResult"/>
			pResponseBuffer 	: ^USINT;			//! <Variable Comment="Pointer of ResponseBuffer, where the SDO-Data is located." Name="ReceiveSDOResponse.pResponseBuffer"/>
			ResponseLength 	: USINT;			//! <Variable Comment="Size of the ResponseBuffer." Name="ReceiveSDOResponse.ResponseLength"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;			//! <Variable Comment="Indicates if the Methode was successful." Name="ReceiveSDOResponse.ret_code"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetTaskCfg
		VAR_OUTPUT
			TaskCfg 	: BDINT;			//! <Variable Comment="Select which tasks will be available for this module:&#13;&#10;Bit0..Realtime PreScan&#13;&#10;Bit1..Realtime PostScan&#13;&#10;Bit2..Cyclic&#13;&#10;&#13;&#10;e.g. if only realtime postscan is needed:&#13;&#10;2#010" Name="GetTaskCfg.TaskCfg"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetDeviceID
		VAR_OUTPUT
			output 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GetFWVersion
		VAR_INPUT
			pData 	: ^CHAR;
			Length 	: UDINT;
		END_VAR;
				//! <Function Comment="Methode to calculate PWM-Signal depending on Speed." Name="CalculatePWM"/>
	FUNCTION CalculatePWM;
	
	FUNCTION VIRTUAL GLOBAL Led20::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Led350::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Enable::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SetSpeed::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL MinPulse::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ErrorQuit::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB SR020::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_SR020
1$UINT, 34$UINT, (SIZEOF(::SR020))$UINT, 
13$UINT, 2$UINT, 0$UINT, 
TO_UDINT(928449634), "SR020", //Class
TO_UDINT(3175101883), "SdiasBase", 1$UINT, 58$UINT, //Baseclass
//Servers:
(::SR020.FirmwareVersion.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(389440282), "FirmwareVersion", 
(::SR020.ErrorBits.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(259769398), "ErrorBits", 
(::SR020.Led20.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1272032155), "Led20", 
(::SR020.Led350.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4026063412), "Led350", 
(::SR020.Enable.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(56102836), "Enable", 
(::SR020.SetSpeed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(33026088), "SetSpeed", 
(::SR020.MinPulse.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(421244052), "MinPulse", 
(::SR020.MotorCurrent.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1218745960), "MotorCurrent", 
(::SR020.Temperature.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(860731524), "Temperature", 
(::SR020.I2T.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(24948417), "I2T", 
(::SR020.ErrorQuit.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(971218924), "ErrorQuit", 
(::SR020.VoltageOk.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2158378107), "VoltageOk", 
(::SR020.VoltageOkMotor.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4002343342), "VoltageOkMotor", 
//Clients:
(::SR020.PWMPeriod.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1793508181), "PWMPeriod", 
(::SR020.I2TThreshold.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1599586102), "I2TThreshold", 
END_FUNCTION


#define USER_CNT_SR020 20

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_SR020] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION SR020::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= SdiasBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= SdiasBase::ClassState.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, SdiasBase::ClassState.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_SR020;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #UpdateRt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #UpdateRtPostScan();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #ConnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #DisconnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #InitModule();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #CheckDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #ReceiveSDOResponse();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #GetTaskCfg();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #GetDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #GetFWVersion();

#pragma warning (default : 74)
	SdiasBase::ClassState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SdiasBase::ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Led20.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Led20::Write() );
	IF Led20.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Led350.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Led350::Write() );
	IF Led350.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Enable.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Enable::Write() );
	IF Enable.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SetSpeed.pMeth			:= StoreMethod( #M_RD_DIRECT(), #SetSpeed::Write() );
	IF SetSpeed.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	MinPulse.pMeth			:= StoreMethod( #M_RD_DIRECT(), #MinPulse::Write() );
	IF MinPulse.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ErrorQuit.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ErrorQuit::Write() );
	IF ErrorQuit.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= SR020();

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION VIRTUAL GLOBAL SR020::UpdateRt

  //Read Information from DPRam
  sReadData := pReadData^;


  // Error states
  //----------------------------------------------

  // standard error states
  ErrorBits.StandardState := sReadData.Status;

  // only set the errors (we need some of the bits from latched and some inverted from the normal status) => not beautiful but fast
  // OverTemperatureError and I2C error are not latched despite beeing in the Latched Bitfield  
  ErrorBits.SRState := ((ErrorBits.SRState OR sReadData.biStatusLatch) AND SR020_STATUS_BITS_LATCHED) OR (sReadData.biStatusLatch AND SR020_STATUS_BITS) OR ((NOT sReadData.biStatus) AND SR020_STATUS_BITS_INVERTED);
  
  
  VoltageOk       := sReadData.biStatus.bDCOkExt;
  VoltageOkMotor  := sReadData.biStatus.bDCOKMotor;

  //I²T 
  I2T       := sReadData.I2TValue AND 16#001FFFFF;
  
  //Temperture Informations
//  #pragma message ("Dieser Wert ist in °C => allerdings mit SHR 4");
  Temperature       := sReadData.uiTemperature SHR 4;

  
  //Disable
  if sReadData.biStatusLatch.bInductionVoltageTooHigh | 
     sReadData.biStatusLatch.bMotorCurrentTooHigh     |
     sReadData.biStatusLatch.bOverTemperatureError    |
     sReadData.biStatusLatch.bI2TError                |
     (sReadData.biStatusLatch.bDCOKMotor = FALSE)     then
    Enable.Write(0);
  end_if;
    
    
  //Motor Current
  //----------------------------------------------
  //Only in Enable Status and no PeripheryReset of Motor or LED
  if Enable & SetSpeed & (sReadData.biStatus.bPeripheryResetLED = FALSE) & (sReadData.biStatus.bPeripheryResetMotor = FALSE) then
    //Actual Motor Current
    MotorCurrent := sReadData.iActCurrent;      
  else
    //Don't show a MotorCurrent
    MotorCurrent := 0;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SR020::UpdateRtPostScan
  
  if bUpdateSeqData then
    sWriteData.sSeqData2 := sSeqData.Seq2;
    sWriteData.sSeqData4 := sSeqData.Seq4;
  
    bUpdateSeqData := FALSE;
  end_if;

  //Write to DPRam
  pWriteData^ := sWriteData;
    
  //Check for Change PostScan-Data
  if ErrorQuit then
    
    //Reset Quit Error Bits (we quit only once) => don't check the actual state of the bit to save time
    sWriteData.biControl.bQuitOverTemperatureError  := FALSE;
    sWriteData.biControl.bQuitI2tError              := FALSE;
    
    ErrorQuit := 0;

  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SR020::ConnectEvent
  
  //Read Access
  if DefaultAccesses.ReadAccess.pControlByte then
    pReadData := DefaultAccesses.ReadAccess.pData$^t_s_ReadData;

    //Start Read-Access to Module (Set ControlWord in DPRam)
    DefaultAccesses.ReadAccess.pControlByte^.EnableDO := true;
  else
    //No ControlWord available
    eInitState := _DOHandleInvalid;
    return;
  end_if;
  
  
  //Write Access
  if DefaultAccesses.WriteAccess.pControlByte then
    pWriteData := DefaultAccesses.WriteAccess.pData$^t_s_WriteData;

    //Start Write-Access to Module (Set ControlWord in DPRam)
    DefaultAccesses.WriteAccess.pControlByte^.EnableDO := true;
  else  
    //No ControlWord available
    eInitState := _DOHandleInvalid;
    return;
  end_if;

  //Reset Statemachines
  eInitSSW       := Init_Variables;
  eResponseState := SDO_Idle;
  eInitState    := _NotInitialized;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SR020::DisconnectEvent
  
  //Reset DO-Data
  if pWriteData then
    _memset(dest := pWriteData, usByte := 0, cntr := sizeof(t_s_WriteData));
  end_if;

  //Call Disconnect of Base-Class
  SdiasBase::DisconnectEvent();

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SR020::Led20::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	//Limitation of Input-Value
	if ( input < 0 ) then
		input := 0;
	elsif ( input > sLEDConfig.usMaxValue20mA ) then
		input := sLEDConfig.usMaxValue20mA;
	end_if;

  //Check for Change
  if input <> Led20 then
  
    //Save Input
    Led20 := input;
    
    //Enable for LED
    sWriteData.biControl.bLed20En := Led20 <> 0;
    
    //Set PWM for LED
    sWriteData.usPWMLed20 := Led20$USINT;
    
  end_if;

  result := Led20;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL SR020::Led350::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	//Limitation of Input-Value
	if ( input < 0 ) then
		input := 0;
	elsif ( input > sLEDConfig.usMaxValue350mA ) then
		input := sLEDConfig.usMaxValue350mA;
	end_if;

  //Check for Change
  if input <> Led350 then
  
    //Save Input
    Led350 := input;
    
    //Enable for LED
    sWriteData.biControl.bLed350En := Led350 <> 0;
    
    //Set PWM for LED
    sWriteData.usPWMLed350 := Led350$USINT; 
    
  end_if;

  result := Led350;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SR020::SetSpeed::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //Check for Change
  if SetSpeed <> input then
  
    //Limit Input
    //------------------------------------------
    if input < 0 then
      
      //Negative Direction
      if input < -SR020_SPEED_SCALING then
        SetSpeed := -SR020_SPEED_SCALING;
      else
        SetSpeed := input;
      end_if;
      
    //Positive Direction
    else
    
      //Negative Direction
      if input > SR020_SPEED_SCALING then
        SetSpeed := SR020_SPEED_SCALING;
      else
        SetSpeed := input;
      end_if;
      
    end_if;

    //Calculate PWM-Signal
    CalculatePWM();
    
  end_if;
      
  result := SetSpeed;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL SR020::Enable::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //Check for Change
  if Enable <> input then
  
    //Save Input
    Enable := input;
    
    //Enable
    if Enable then
    
      //Check Error
      if (ErrorBits.SRState.bMotorCurrentTooHigh = FALSE) & 
         (ErrorBits.SRState.bInductionVoltageTooHigh = FALSE) then
        Enable := 1;
      else
        Enable := 0;
      end_if;
    
    else
    //Disable
    
      //Reset Speed
      SetSpeed.Write(0);
    end_if;
    
    //Update Enable bit in control word
    sWriteData.biControl.bSeqEnable := to_bool(Enable);
    
  end_if;

  result := Enable;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SR020::MinPulse::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //Check for Change
  if input <> MinPulse then
    
    //Limitation of Value
    if ( input > SR020_MINPULSE_SCALING ) then
      input := SR020_MINPULSE_SCALING;
    elsif ( input < 0 ) then
      input := 0;
    end_if;
    
    //Save Input
    MinPulse := input;

    //Calculate minimum Timelength of Pulse
    uiTimeMin := to_uint( ( MinPulse * uiPeriodCount )$UDINT / SR020_MINPULSE_SCALING );
  
    //new Calculation of PWM
    if Enable then
      CalculatePWM();
    end_if;

  end_if;

 	result := MinPulse;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SR020::ErrorQuit::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  if input then    
    // reset all error bits. if there's still an error, they will appear in next realtime.
    ErrorBits.SRState := 0;
  end_if;

  // I²T Error Quit
  sWriteData.biControl.bQuitI2tError := input <> 0;
  
  // Overtemperature Error Quit
  sWriteData.biControl.bQuitOverTemperatureError := input <> 0;

  //Save Quit last because we reset the server in UpdateRtPostScan
  ErrorQuit := input;
	result := ErrorQuit;

END_FUNCTION


FUNCTION SR020::SR020
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
  
	ret_code := C_OK;

END_FUNCTION


FUNCTION VIRTUAL SR020::ReceiveSDOResponse
	VAR_INPUT
		eCommand 	: t_SDIAS_SDO_Cmd;
		hOffset 	: HINT;
		usLength 	: USINT;
		eResult 	: iprStates;
		pResponseBuffer 	: ^USINT;
		ResponseLength 	: USINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR
  
  //Call Response of Base-Class
  ret_code := SdiasBase::ReceiveSDOResponse(eCommand        := eCommand, 
                                            hOffset         := hOffset, 
                                            usLength        := usLength, 
                                            eResult         := eResult, 
                                            pResponseBuffer := pResponseBuffer, 
                                            ResponseLength  := ResponseLength);
    
  // spi access from baseclass                                         
  if bSDOResponseHandle = TRUE then
    return;
  end_if;  

  //Evaluate Result of SDO
  //----------------------------------------------------------------------------
  if eResult = READY then
    
    //Check Type of SDO-Command
    case eCommand of
    
      //Memory Write
      SDIAS_SDO_CMD_MEM_WRITE:
      
        case hOffset of
        
          SR020_ADDR_CFG_FIRMWARE:
            if eResponseState = SDO_Wait then
              eResponseState := SDO_Valid;
            end_if; 
            
          SR020_ADDR_I2T_THRESHOLD:
            if eResponseState = SDO_Wait then
              eResponseState := SDO_Valid;
            end_if; 
            
          else
            LogError("@ZZZZ (SR020::ReceiveSDOResponse) Invalid Offset in Write-Response of SDO");
        
        end_case;
       
      //Memory Read
      SDIAS_SDO_CMD_MEM_READ:
      
        case hOffset of
        
          SR020_ADDR_STATE_FIRMWARE:
            if eResponseState = SDO_Wait then
              eResponseState := SDO_Valid;
            end_if;

            sFWState := pResponseBuffer^$t_s_FWState;
            
          SR020_ADDR_LED_MAX  :
            if eResponseState = SDO_Wait then
              eResponseState := SDO_Valid;
            end_if;

            sLEDConfig := pResponseBuffer^$t_s_LEDConfiguration;
            
          else
            LogError("@ZZZZ (SR020::ReceiveSDOResponse) Invalid Offset in Write-Response of SDO");
        
        end_case;
        
    end_case;
    
    //Check if Class was in Valid State for SDO Response
    if eResponseState <> SDO_Valid then
      LogError("@ZZZZ (SR020::ReceiveSDOResponse) Class in wrong State during Response of SDO");
      eInitSSW := Init_Error;      
    end_if;
    
    
  //Problem with Response
  //----------------------------------------------------------------------------
  else
    
    //Check Type of SDO-Command to set correct Log-Message
    case eCommand of
    
      SDIAS_SDO_CMD_MEM_WRITE:
        LogError("@ZZZZ (SR020::ReceiveSDOResponse) Error while executing a sdo write-command");
      SDIAS_SDO_CMD_MEM_READ:
        LogError("@ZZZZ (SR020::ReceiveSDOResponse) Error while executing a sdo read-command");
        
    end_case;
    
    eInitSSW := Init_Error;
    
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SR020::InitModule
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
  VAR
  	TmpRetcode      : iprStates;
  END_VAR
  
  
  //Init Returncode
  eModuleInitState := BUSY;
  
  
  //*****************************************************************************
  //** STATEMACHINE FOR INITIALIZATION OF THE MODULE                           **
  //*****************************************************************************
  
  case eInitSSW of
  
    //Setting up Variables
    //*****************************************************************************
    Init_Variables:
    
      //Read Settings
      PWMPeriod := PWMPeriod.Read();
      
      //Calculate PeriodTime of FPGA
      uiPeriodCount           := to_uint(SR020_FPGA_FREQ_MHZ * PWMPeriod);
      sWriteData.uiPeriodTime := uiPeriodCount + 2 * SR020_T_SWITCH; 
      
      
      //Sequences 1 + 3: used to switch between two active Sequences 2 + 4 => avoid ShortCircuit of H-Bridge
      //-----------------------------------------------------------------------------------------------------------
      sWriteData.sSeqData1$UINT        := SR020_T_SWITCH;     //Disable Time for switching between two active Phases
      sWriteData.sSeqData1.bTimeCount  := 0;                  //Relative Time
      sWriteData.sSeqData3$UINT        := SR020_T_SWITCH;     //Disable Time for switching between two active Phases
      sWriteData.sSeqData3.bTimeCount  := 0;                  //Relative Time
      
      //Sequency 2 + 4: used for controlling the dc-motor
      //-----------------------------------------------------------------------------------------------------------
      sWriteData.sSeqData2$UINT := ( SR020_GATE_A_LOW + SR020_GATE_B_LOW ) OR ( SR020_DEFAULT_SEQ_INIT AND SR020_MASK_CONTROL ) OR SR020_DEFAULT_SEQ_INIT;    //Init Value für Sequencer
      sWriteData.sSeqData2.bTimeCount := 0;      //Relative Time
      sWriteData.sSeqData4$UINT := ( SR020_GATE_A_LOW + SR020_GATE_B_LOW ) OR ( SR020_DEFAULT_SEQ_INIT AND SR020_MASK_CONTROL ) OR SR020_DEFAULT_SEQ_INIT;    //Init Value für Sequencer
      sWriteData.sSeqData4.bTimeCount := 0;      //Relative Time
      
      //ControlWord
      //--------------------------------------------------------
      sWriteData.biControl.bSeqEnable                 := false;
      sWriteData.biControl.bMotorCurrentHighEn        := true;
      sWriteData.biControl.bMotorCurrentTooHighEn     := true;
      sWriteData.biControl.bDCOkExtEn                 := true;
      sWriteData.biControl.bDCOkMotorEn               := true;
      sWriteData.biControl.bPeripheryResetLedEn       := true;
      sWriteData.biControl.bPeripheryResetMotorEn     := true;
      sWriteData.biControl.bInductionVoltageTooHighEn := true;
      sWriteData.biControl.bOverTemperatureSwOffEn    := true;
      sWriteData.biControl.bI2tSwOffEn                := true; 
      
      //Set Led to current value of leds (used for that after reconnect the leds are switched on again if they were switched on before reconnect)
      sWriteData.biControl.bLed20En                   := Led20 <> 0;
      sWriteData.biControl.bLed350En                  := Led350 <> 0;
      
      //First Error-Quit
      sWriteData.biControl.bQuitOverTemperatureError  := true;
      sWriteData.biControl.bQuitI2tError              := true;
      
      // Reset Error Bits. These are set with |, => may retain false state after VARAN Dis/Reconnect 
      ErrorBits$UDINT := 0;

      //Calculate minimum Timelength of Pulse
      uiTimeMin := to_uint( ( MinPulse * uiPeriodCount )$UDINT / SR020_MINPULSE_SCALING );
      
      // set I²T Treshold 
      I2TThreshold := I2TThreshold.Read();
      if I2TThreshold > 100 then
        I2TThreshold := 100;
      end_if;

      sConfiguration.usI2tTreshold := SR020_I2T_THRESHOLD * I2TThreshold / 100;  
      
      
      //Set Configuration-Block of FW
      sFWConfiguration.Info         := 0;
      sFWConfiguration.uDataLength  := sizeof(sFWConfiguration) - sizeof(sFWConfiguration.hCRC) - sizeof(sFWConfiguration.uDataLength);
      sFWConfiguration.hCRC         := CheckSum_16( pData         := (#sFWConfiguration.Info)$^UINT, 
                                                    uiDataLength  := sFWConfiguration.uDataLength, 
                                                    uiCRCStart    := 16#FFFF);
      
      //Next Step is to Initialize Firmware
      eInitSSW  := Init_Firmware;
    
    
    //Initialize Firmware
    //*****************************************************************************
    Init_Firmware:
    
      //Statemachine for SDO-Communication
      case eResponseState of
        
        //Idle
        //-------------------------------------------------------
        SDO_Idle:
        
          //Start SDO-Command
          tmpRetcode := StartWriteSDO(hOffset       := SR020_ADDR_CFG_FIRMWARE, 
                                      usLength      := sizeof(sFWConfiguration), 
                                      pWriteBuffer  := (#sFWConfiguration)$^USINT, 
                                      eCommand      := SDIAS_SDO_CMD_MEM_WRITE);
          
          //Evaluate Returncode
          if tmpRetcode = READY then
            
            //Timestamp for TimeoutCheck
            udSDOTimeout    := ops.tAbsolute;
            eResponseState  := SDO_Wait; 
          
          //Error occured  
          elsif tmpRetcode = ERROR then
          
            eModuleInitState := ERROR;
            LogError("@ZZZZ ((SR020::InitModule) Failed to add write SDO for firmware configuration");
            eInitState := _NoMem;
            
          end_if;
        
        //Wait for Response
        //-------------------------------------------------------
        SDO_Wait:
        
          //Timeout-Check
          if ((ops.tAbsolute - udSDOTimeout) > SR020_SDO_RESPONSE_TIMEOUT) then
          
            LogError("@ZZZZ (SR020::InitModule) SDO Response timeout config module");
            eInitSSWErrorStep  := eInitSSW;
            eInitSSW          := Init_Error;
            
          end_if;
          
        //Response received
        //-------------------------------------------------------
        SDO_Valid:
          
          eInitSSW        := Init_GetStateFW;
          eResponseState  := SDO_Idle;
          
      end_case;
    
      
    //Get Firmware Informations
    //*****************************************************************************
    Init_GetStateFW:

      //Statemachine for SDO-Communication
      case eResponseState of
        
        //Idle
        //-------------------------------------------------------
        SDO_Idle:
        
          //Start SDO-Command
          tmpRetcode := StartReadSDO( hOffset   := SR020_ADDR_STATE_FIRMWARE, 
                                      usLength  := sizeof(sFWState), 
                                      eCommand  := SDIAS_SDO_CMD_MEM_READ);
          
          //Evaluate Returncode
          if tmpRetcode = READY then
            
            //Timestamp for TimeoutCheck
            udSDOTimeout    := ops.tAbsolute;
            eResponseState  := SDO_Wait; 
          
          //Error occured  
          elsif tmpRetcode = ERROR then
          
            eModuleInitState := ERROR;
            LogError("@ZZZZ (SR020::InitModule) Failed to add read SDO for firmware info");
            eInitState := _NoMem;
            
          end_if;
        
        //Wait for Response
        //-------------------------------------------------------
        SDO_Wait:
        
          //Timeout-Check
          if ((ops.tAbsolute - udSDOTimeout) > SR020_SDO_RESPONSE_TIMEOUT) then
          
            LogError("@ZZZZ (SR020::InitModule) SDO Response timeout read state");
            eInitSSWErrorStep  := eInitSSW;
            eInitSSW          := Init_Error;
            
          end_if;
          
        //Response received
        //-------------------------------------------------------
        SDO_Valid:
        
          //Check Length of FirmwarePackage
          if ( sFWState.uDataLength = sizeof( sFWState ) - sizeof( sFWState.hCRC ) - sizeof( sFWState.uDataLength ) ) then
          
            //Check CRC
            if (sFWState.hCRC = CheckSum_16( pData         := #sFWState.hFWVersion, 
                                            uiDataLength  := sFWState.uDataLength, 
                                            uiCrcStart    := 16#FFFF)) then
              
              //Write Version of FW to Server
              FirmwareVersion := (sFWState.hFWVersion and 16#0000FFFF)$HDINT;

              //Next Step
              eResponseState   := SDO_Idle;
              eInitSSW         := Init_ConfigModule;
            
            //Wrong CRC
            else
            
              eInitState       := _ClientNotready;
              eModuleInitState := ERROR;
              LogError("@ZZZZ (SR020::InitModule) Invalid checksum at firmware info");
              
            end_if;
          
          //Wrong Data-Length
          else
          
            eInitState       := _ClientNotready;
            eModuleInitState := ERROR;
            LogError("@ZZZZ (SR020::InitModule) Invalid length at firmware info");
            
          end_if;

      end_case;
    
    
    //Write Configuration to Module
    //*****************************************************************************
    Init_ConfigModule:
    
      //Statemachine for SDO-Communication
      case eResponseState of
    
        //Idle
        //-------------------------------------------------------
        SDO_Idle:
        
          //Start SDO-Command
          tmpRetcode := StartWriteSDO(hOffset       := SR020_ADDR_I2T_THRESHOLD, 
                                      usLength      := sizeof(sConfiguration.usI2tTreshold), 
                                      pWriteBuffer  := (#sConfiguration.usI2tTreshold)$^USINT, 
                                      eCommand      := SDIAS_SDO_CMD_MEM_WRITE);
          
          //Evaluate Returncode
          if tmpRetcode = READY then
            
            //Timestamp for TimeoutCheck
            udSDOTimeout    := ops.tAbsolute;
            eResponseState  := SDO_Wait; 
          
          //Error occured  
          elsif tmpRetcode = ERROR then
          
            eModuleInitState := ERROR;
            LogError("@ZZZZ (SR020::InitModule) Failed to add write SDO for Module configuration");
            eInitState := _NoMem;
            
          end_if;
        
        //Wait for Response
        //-------------------------------------------------------
        SDO_Wait:
        
          //Timeout-Check
          if ((ops.tAbsolute - udSDOTimeout) > SR020_SDO_RESPONSE_TIMEOUT) then
          
            LogError("@ZZZZ (SR020::InitModule) SDO Response timeout config module");
            eInitSSWErrorStep  := eInitSSW;
            eInitSSW          := Init_Error;
            
          end_if;
          
        //Response received
        //-------------------------------------------------------
        SDO_Valid:
          
          eInitSSW        := Init_GetConfigLed;
          eResponseState  := SDO_Idle;
          
      end_case;


    //Get LED-Configuration
    //*****************************************************************************
    Init_GetConfigLed:
    
      //Statemachine for SDO-Communication
      case eResponseState of
        
        //Idle
        //-------------------------------------------------------
        SDO_Idle:
        
          //Start SDO-Command
          tmpRetcode := StartReadSDO( hOffset   := SR020_ADDR_LED_MAX, 
                                      usLength  := sizeof(sLEDConfig), 
                                      eCommand  := SDIAS_SDO_CMD_MEM_READ);
          
          //Evaluate Returncode
          if tmpRetcode = READY then
            
            //Timestamp for TimeoutCheck
            udSDOTimeout    := ops.tAbsolute;
            eResponseState  := SDO_Wait; 
          
          //Error occured  
          elsif tmpRetcode = ERROR then
          
            eModuleInitState := ERROR;
            LogError("@ZZZZ (SR020::InitModule) Failed to add read SDO for LED configuration");
            eInitState := _NoMem;
            
          end_if;
        
        //Wait for Response
        //-------------------------------------------------------
        SDO_Wait:
        
          //Timeout-Check
          if ((ops.tAbsolute - udSDOTimeout) > SR020_SDO_RESPONSE_TIMEOUT) then
          
            LogError("@ZZZZ (SR020::InitModule) SDO Response timeout read state");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW          := Init_Error;
            
          end_if;
          
        //Response received
        //-------------------------------------------------------
        SDO_Valid:
        
          eInitSSW        := Init_QuitError;
          eResponseState  := SDO_Idle;

      end_case;
      
    Init_QuitError :         
      
      //Write to DPRam
      pWriteData^ := sWriteData;
      // Reset Quit Flags, We don't need to quit again in 1st UpdateRtPostScan
      sWriteData.biControl.bQuitOverTemperatureError  := false;
      sWriteData.biControl.bQuitI2tError              := false;
      
      eInitSSW        := Init_Finish;
    
    //Initialization of Module finished
    //*****************************************************************************
    Init_Finish:
    
      eInitSSW          := Init_Variables;
      eInitState        := _ClassOk;
      eModuleInitState  := READY;
     
   
   //Error during Initialization
   //*****************************************************************************
   Init_Error:
      
      eInitState        := _ClientNotready;
      eModuleInitState  := ERROR; 
  
  end_case;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL SR020::CheckDeviceID
	VAR_INPUT
		udID2Check 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bIsOK 	: BOOL;
	END_VAR
  
	//Check DeviceID of Module
	if ( udID2Check <> DEVICE_ID_SR020 ) then
		bIsOK := false;
	else
    bIsOK := true;
	end_if;

END_FUNCTION


FUNCTION SR020::CalculatePWM
  VAR
    tmpPWM	            : UINT;
    tmpBridgeOnSwitch   : UINT;
    tmpBridgeOffSwitch  : UINT;
    tmpTime             : UINT;
  END_VAR
            
  //Input 0 => Brake (Short Circuit)
  //*****************************************************************************
  if SetSpeed = 0 then
  
    tmpBridgeOnSwitch   := ( SR020_GATE_A_LOW + SR020_GATE_B_LOW ) OR ( SR020_DEFAULT_SEQ_INIT AND SR020_MASK_CONTROL );
    tmpBridgeOffSwitch  := ( SR020_GATE_A_LOW + SR020_GATE_B_LOW ) OR ( SR020_DEFAULT_SEQ_INIT AND SR020_MASK_CONTROL );
    
    //No PWM
    tmpPWM := uiPeriodCount / 2;
    
  //Input < 0 => Negative Direction (Gate A - High, Gate B - Low)
  //*****************************************************************************
  elsif SetSpeed < 0 then
  
    tmpBridgeOnSwitch   := ( SR020_GATE_A_HIGH + SR020_GATE_B_LOW ) OR ( SR020_DEFAULT_SEQ_INIT AND SR020_MASK_CONTROL );
    tmpBridgeOffSwitch  := ( SR020_GATE_A_LOW + SR020_GATE_B_LOW )  OR ( SR020_DEFAULT_SEQ_INIT AND SR020_MASK_CONTROL );
    
    //Calculate PWM
    tmpPWM := to_uint(-SetSpeed);
    
  //Input > 0 => Positive Direction ()
  //*****************************************************************************
  else
  
    tmpBridgeOnSwitch   := ( SR020_GATE_A_LOW + SR020_GATE_B_HIGH ) OR ( SR020_DEFAULT_SEQ_INIT AND SR020_MASK_CONTROL );
    tmpBridgeOffSwitch  := ( SR020_GATE_A_LOW + SR020_GATE_B_LOW )  OR ( SR020_DEFAULT_SEQ_INIT AND SR020_MASK_CONTROL );
    
    //Calculate PWM
    tmpPWM := to_uint(SetSpeed);
  
  end_if;

  
  //Time Calculation
  tmpTime := tmpPWM * (uiPeriodCount)  / SR020_SPEED_SCALING;
  
  if tmpTime < uiTimeMin then
    tmpTime := uiTimeMin;
  end_if;

  
  //Set Write-Data
  //lanste 24.10.2014 If Seq1 or Seq3 are changed as well updateRTPostscan must be updatet as well.
  sSeqData.Seq2 := ( tmpBridgeOnSwitch  AND SR020_MASK_TIME ) OR tmpTime;
  sSeqData.Seq4 := ( tmpBridgeOffSwitch AND SR020_MASK_TIME ) OR ( uiPeriodCount - ( tmpTime AND SR020_MASK_CONTROL ) );
  
  // Lock seqdata update behind a flag and because calculation can be interrupted.
  bUpdateSeqData := TRUE;
   
END_FUNCTION


FUNCTION VIRTUAL SR020::GetTaskCfg
	VAR_OUTPUT
		TaskCfg 	: BDINT;
	END_VAR

  TaskCfg := SDIAS_TASK_MASK_RT_PRE OR SDIAS_TASK_MASK_RT_POST;

END_FUNCTION


FUNCTION VIRTUAL SR020::GetDeviceID
	VAR_OUTPUT
		output 	: UDINT;
	END_VAR
  
  output := DEVICE_ID_SR020;

END_FUNCTION


FUNCTION VIRTUAL SR020::GetFWVersion
	VAR_INPUT
		pData 	: ^CHAR;
		Length 	: UDINT;
	END_VAR
  
  //Check pointer
  if pData then
    //Length of Firmwareversion (HDINT) -> 8Byte +1 byte zero termination
    if Length >= 9 then
      _itoa(udNumber:=FirmwareVersion, pString:=pData);  
    else
      pData^ := 0;
    end_if; 
  end_if;
  
END_FUNCTION
