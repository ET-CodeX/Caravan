//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "InputMyIO"
	Revision           = "0.0"
	GUID               = "{7883B54C-6B79-4E2E-BBDC-173BD1AC194B}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(308,120)">
	<Channels>
		<Server Name="sXDir" GUID="{F73E9BCD-8BEB-4365-A018-A53ABFEAF022}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="sYDir" GUID="{49EEEFE9-819C-41EB-82B2-13DBF905D947}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="oc_Grafix" Required="false" Internal="false"/>
	</Channels>
	<Network Name="InputMyIO">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{C3FA2E8F-A7E7-40B0-871E-D42042B6B0ED}"
				Class      = "_MyIO"
				Position   = "(218,120)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Refresh"/>
					<Server Name="Server0"/>
					<Client Name="Graphic"/>
					<Client Name="Lse"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Server0" Destination="_base.Server0" Vertices="(690,210),(518,210),"/>
			<Connection Source="this.Refresh" Destination="_base.Refresh" Vertices="(690,270),(518,270),"/>
			<Connection Source="_base.Lse" Destination="this.Lse" Vertices="(218,210),(38,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _MyIO

InputMyIO : CLASS
: _MyIO
  //Servers:
	sXDir 	: SvrCh_DINT;
	sYDir 	: SvrCh_DINT;
  //Clients:
	oc_Grafix 	: CltChCmd__Grafix;
  //Variables:
		bMyFocus 	: BOOL;
  //Functions:
				//! <Function Comment="this method will be called once when the focus will be given to this object" Name="GetFocus"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetFocus
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="GetFocus.pio"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="return _IFAILED if you dont want to get the focus on the other hand _IDLE" Name="GetFocus.retcode"/>
		END_VAR;
				//! <Function Comment="this method is called once when the focus is taken from object" Name="KillFocus"/>
	FUNCTION __CDECL VIRTUAL GLOBAL KillFocus
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="KillFocus.pio"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="return always _IDLE because you can&apos;t prevent action" Name="KillFocus.retcode"/>
		END_VAR;
				//! <Function Comment="this method is called everytime when the input is active and a event occured" Name="GetEvent"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetEvent
		VAR_INPUT
			ped 	: ^_EDITOR;			//! <Variable Comment="pointer to _EDITOR information" Name="GetEvent.ped"/>
			pe 	: ^_EVENT;			//! <Variable Comment="pointer to _EVENT information" Name="GetEvent.pe"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="for the returnstatement there are 3 different possibilities&#13;&#10;  _IDLE ..... the system should goon like it is (system goes on)&#13;&#10;  _IDIDIT ... i did it (system is ready)&#13;&#10;  _IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;" Name="GetEvent.retcode"/>
		END_VAR;
				//! <Function Comment="this method is called everytime when system wants to redraw the io" Name="Draw"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Draw
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="Draw.pio"/>
			pr 	: ^_RESULT;			//! <Variable Comment="pointer to _RESULT information" Name="Draw.pr"/>
			pv 	: ^_VARIABLE;			//! <Variable Comment="pointer to io _VARIABLE information" Name="Draw.pv"/>
			input 	: BOOL;			//! <Variable Comment="TRUE it&apos;s an input&#13;&#10;FALSE it&apos;s an output" Name="Draw.input"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="for the returnstatement there are 3 different possibilities&#13;&#10;  _IDLE ..... the system should goon like it is (system goes on)&#13;&#10;  _IDIDIT ... i did it (system is ready)&#13;&#10;  _IFAILED .. i tried to do my best, but i failed (system is re" Name="Draw.retcode"/>
		END_VAR;
				//! <Function Comment="this method is called everytime when system wants to get data for defined io.&#13;&#10;&#13;&#10;pr ........ &#13;&#10;pio ....... pointer to io information&#13;&#10;pv ........ pointer to io variableinformation&#13;&#10;input ..... TRUE it&apos;s an input / FALSE it&apos;s an output&#13;&#10;&#13;&#10;for the returnstatement there are 3 different possibilities&#13;&#10;_IDLE ..... the system should goon like it is (system goes on)&#13;&#10;_IDIDIT ... i did it (system is ready)&#13;&#10;_IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;&#13;&#10;if you want to do it let&apos;s return _IDIDIT and initialize the  structure _RESULT&#13;&#10;" Name="GetData"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetData
		VAR_INPUT
			pr 	: ^_RESULT;			//! <Variable Comment="pointer to _RESULT information" Name="GetData.pr"/>
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="GetData.pio"/>
			pv 	: ^_VARIABLE;			//! <Variable Comment="pointer to _VARIABLE information given by LSE" Name="GetData.pv"/>
			input 	: BOOL;			//! <Variable Comment="TRUE it&apos;s an input&#13;&#10;FALSE it&apos;s an output" Name="GetData.input"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="for the returnstatement there are 3 different possibilities&#13;&#10;  _IDLE ..... the system should goon like it is (system goes on)&#13;&#10;  _IDIDIT ... i did it (system is ready)&#13;&#10;  _IFAILED .. i tried to do my best, but i failed (system is ready)" Name="GetData.retcode"/>
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _Grafix


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB InputMyIO::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_INPUTMYIO
0$UINT, 0$UINT, (SIZEOF(::InputMyIO))$UINT, 
2$UINT, 1$UINT, 0$UINT, 
TO_UDINT(3621868871), "InputMyIO", //Class
TO_UDINT(2980745877), "_MyIO", 0$UINT, 3$UINT, //Baseclass
//Servers:
(::InputMyIO.sXDir.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1684374723), "sXDir", 
(::InputMyIO.sYDir.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3705267110), "sYDir", 
//Clients:
(::InputMyIO.oc_Grafix.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3600269815), "oc_Grafix", TO_UDINT(197854207), "_Grafix", 1$UINT, 2$UINT, 
END_FUNCTION


#define USER_CNT_InputMyIO 17

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_InputMyIO] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION InputMyIO::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _MyIO::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _MyIO::Server0.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _MyIO::Server0.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_InputMyIO;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #GetFocus();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #KillFocus();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #GetEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #Draw();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #GetData();

#pragma warning (default : 74)
	_MyIO::Server0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _MyIO::Server0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	sXDir.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF sXDir.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	sYDir.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF sYDir.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION __CDECL VIRTUAL GLOBAL InputMyIO::GetData
	VAR_INPUT
		pr 	: ^_RESULT;
		pio 	: ^_IO;
		pv 	: ^_VARIABLE;
		input 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retcode (EAX) 	: _DOIT;
	END_VAR
  
  _MyIO::GetData(pr:=pr, pio:=pio, pv:=pv, input:=input);  
  // pr : pointer auf Serverdaten 
  pr^.value := TO_DINT((TO_UDINT(sXDir) rol 1) xor (TO_UDINT(sYDir)));
  retcode := _IDIDIT;

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL InputMyIO::GetEvent
	VAR_INPUT
		ped 	: ^_EDITOR;
		pe 	: ^_EVENT;
	END_VAR
	VAR_OUTPUT
		retcode (EAX) 	: _DOIT;
	END_VAR
  
  _MyIO::GetEvent(ped:=ped, pe:=pe);
  
  retcode := _IDLE;
  
  if pe^.ftype = _EVENT_HIDMOVE then  
  
    if (pe^.dot.x >= ped^.input.io.space.xy1.x) &  
       (pe^.dot.x <= ped^.input.io.space.xy2.x) &
       (pe^.dot.y >= ped^.input.io.space.xy1.y) &
       (pe^.dot.y <= ped^.input.io.space.xy2.y) then
       
       sXDir := pe^.dot.x - ped^.input.io.space.xy1.x;
       sYDir := ped^.input.io.space.xy2.y - pe^.dot.y;
       
       retcode := _IDIDIT;
                                                                              
    end_if;
  end_if;

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL InputMyIO::Draw
	VAR_INPUT
		pio 	: ^_IO;
		pr 	: ^_RESULT;
		pv 	: ^_VARIABLE;
		input 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retcode (EAX) 	: _DOIT;
	END_VAR
  VAR
  	act   : _NEWSCREEN;
    x     : _KOORD;
    y     : _KOORD;
    color : _COLOR;
  END_VAR
  
  _MyIO::Draw(pio:=pio, pr:=pr, pv:=pv, input:=input);

  x := pio^.space.xy1.x + TO_INT(sXDir);
  y := pio^.space.xy2.y - TO_INT(sYDir);
  
  if (bMyFocus = TRUE) then
    color := GetEditColorBack(x0:=_EDITACTIVE);
  else
    color := pio^.coltxt;
  end_if;
  
  push_screen(p0:=#act);
  
  oc_Grafix.PutImage(image:=#pio^.image, 
                     x0:=DEFKOORD,
                     y0:=DEFKOORD);
  
  oc_Grafix.Rectangle(x0:= pio^.space.xy1.x, 
                      y0:= pio^.space.xy1.y, 
                      x1:= pio^.space.xy2.x, 
                      y1:= pio^.space.xy2.y, 
                      attrib:= pio^.attrib, 
                      color:= pio^.colframe);

  oc_Grafix.Line(x0:=pio^.space.xy1.x,
                 y0:=y,
                 x1:=pio^.space.xy2.x, 
                 y1:=y, 
                 attrib:=pio^.attrib, 
                 color:=color);
                 
  oc_Grafix.Line(x0:=x,
                 y0:=pio^.space.xy1.y,
                 x1:=x, 
                 y1:=pio^.space.xy2.y, 
                 attrib:=pio^.attrib, 
                 color:=color);
                 
  pop_screen(p0:=#act);                       
  copy_screen(p0:=#act, p1:=#pio^.space); 
  
  retcode := _IDIDIT;
  
  END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL InputMyIO::GetFocus
	VAR_INPUT
		pio 	: ^_IO;
	END_VAR
	VAR_OUTPUT
		retcode (EAX) 	: _DOIT;
	END_VAR
  
  _MyIO::GetFocus(pio:=pio);

  bMyFocus := TRUE;
  retcode := _IDLE;
  
END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL InputMyIO::KillFocus
	VAR_INPUT
		pio 	: ^_IO;
	END_VAR
	VAR_OUTPUT
		retcode (EAX) 	: _DOIT;
	END_VAR
  
  _MyIO::KillFocus(pio:=pio);

  bMyFocus := FALSE;
  retcode := _IDLE;

END_FUNCTION
