//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES

//===========================================================================================================

#define MaxNoStations         50        // max. allowed No of stations

#define IPcfgWindowNrMsgBox   51000     // Window-Number of the Message Box


//===========================================================================================================


//}}LSL_DEFINES

//{{LSL_DECLARATION
#include <.\LoaderItf.h>

(*!
<Class
	Name               = "_IPConfigMain"
	Revision           = "1.2"
	GUID               = "{44CBA06A-C6AD-4544-A504-8AF920587BC9}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	DefBackground      = "100 ms"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(570,120)"
	Comment            = "IP Configuration Main&#13;&#10;management for IP configuration">
	<Channels>
		<Server Name="CmdIPConfig" GUID="{3E6ADB55-D39F-4E42-8BBE-627D963EAA94}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Commands to operate with the IP configuration"/>
		<Server Name="NoOfStations" GUID="{324F7F7B-3645-46F6-9613-FBADEA1DB64A}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Number (No) of registered stations"/>
		<Server Name="NrLastMessage" GUID="{FD087FF5-04BC-41B8-B5B7-B0F3A9452C3A}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="SRam" Comment="number of the last message"/>
		<Client Name="_IP" Required="false" Internal="false" Comment="Object channel to _IP (don&apos;t connect)"/>
		<Client Name="ActWindow" Required="true" Internal="false" Comment="number of the active window &#13;&#10;(connect to corresponding server of the class &quot;ProjectGlobal&quot;)"/>
		<Client Name="ChangeIsActive" Required="true" Internal="false" Comment="1 = the changing of the IP addresses is active &#13;&#10;use this information for example to deactivate the TCPCommunication"/>
		<Client Name="SigCLib" Required="false" Internal="false" Comment="Object channel to SigCLib (don&apos;t connect)"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\LoaderItf.h" Include="true"/>
			<File Path=".\Class\_IPConfigMain\_IPConfigMain_de.pdf"/>
			<File Path=".\Class\_IPConfigMain\_IPConfigMain_en.pdf"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek GmbH"/>
		<Dokumentation Revision="1.2" Date="2017-12-07" Author="KaiAnd" Company="Sigmatek GmbH" Description="new client ChangeIsActive (1 = the changing of the IP addresses is active)"/>
		<Dokumentation Revision="1.1" Date="2017-11-30" Author="KaiAnd" Company="Sigmatek GmbH" Description="start the init procedure only in the first call of IF_IpcIni(), and not after a SOFTRESET"/>
		<Dokumentation Revision="1.0" Date="2017-11-28" Author="KaiAnd" Company="Sigmatek GmbH" Description="Class created"/>
	</RevDoku>
	<Network Name="_IPConfigMain">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{51A6A02F-7368-4C68-9C77-57A8D4C29C42}"
				Class      = "_Global"
				Position   = "(218,120)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Server0"/>
					<Client Name="Lse"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Server0" Destination="_base.Server0" Vertices="(690,210),(518,210),"/>
			<Connection Source="_base.Lse" Destination="this.Lse" Vertices="(218,210),(38,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _Global

_IPConfigMain : CLASS
: _Global
	TYPE
	  t_e_ApplyStepsMain :
	  (
	    APPLY_IDLE,
	    START_APPLY,
	    SEND_APPLY_IF,
	    CHECK_APPLY_IF,
	    SEND_APPLY_MM,
	    CHECK_APPLY_MM,
	    SEND_APPLY_OK,
	    CHECK_APPLY_OK,
	    APPLY_OK,
	    APPLY_NOK,
	    LSE_SOFTRESET,
	    APPLY_DONE
	  )$UDINT;
	  t_e_StationsInitSteps :
	  (
	    INIT_IDLE,
	    START_INIT_IF,
	    CHECK_INIT_IF,
	    START_INIT_MM,
	    CHECK_INIT_MM,
	    INIT_DONE
	  )$UDINT;
#pragma pack(push, 1)
	  t_Station : STRUCT
	    pStation : ^void;
	    StationStatus : DINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	NoOfStations 	: SvrCh_DINT;
	CmdIPConfig 	: SvrCh_DINT;
	NrLastMessage 	: SvrCh_DINT;
  //Clients:
	_IP 	: CltChCmd__IP;
	SigCLib 	: CltChCmd_SigCLib;
	ActWindow 	: CltCh_UDINT;
	ChangeIsActive 	: CltCh_DINT;
  //Variables:
		piniSav 	: ^_IPCINI;
		StationsInitStep 	: t_e_StationsInitSteps;
		MainInitDone 	: BOOL;
		TimeStampHmsImp 	: UDINT;
		hmsImp 	: DINT;
		StationCount 	: DINT;
		StationList : ARRAY [0..MaxNoStations] OF t_Station;

		NewCmdIPConfig 	: DINT;
		ApplyStep 	: t_e_ApplyStepsMain;
		ApplyHmsWait 	: DINT;
		tmpTxt : ARRAY [0..80] OF CHAR;

  //Functions:
				//! <Function Comment="used for cyclic ToDos" Name="IF_ProjectRun"/>
	FUNCTION VIRTUAL GLOBAL IF_ProjectRun
		VAR_INPUT
			pe 	: ^_EVENT;
		END_VAR;
				//! <Function Comment="The method IF_IPCINI() is called once after the init, and supplies data from File ipc.ini " Name="IF_IpcIni"/>
	FUNCTION VIRTUAL GLOBAL IF_IpcIni
		VAR_INPUT
			pini 	: ^_IPCINI;
		END_VAR;
				//! <Function Comment="Register a station (is called by the station which want&apos;s to be registered)." Name="RegisterStation"/>
	FUNCTION GLOBAL RegisterStation
		VAR_INPUT
			pStation 	: ^void;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="return code: &#13;&#10;0 = OK / -1 = Error" Name="RegisterStation.retcode"/>
		END_VAR;
				//! <Function Comment="function for work the INIT of the Main-Object&#13;&#10;--&gt; working with IpcIni structure&#13;&#10;--&gt; working with the MultiMaster-settings" Name="workMainInits"/>
	FUNCTION workMainInits
		VAR_INPUT
			workMode 	: DINT;			//! <Variable Comment="working mode&#13;&#10;0 ... called by IF_IpcIni()&#13;&#10;1 ... called outside IF_IpcIni()" Name="workMainInits.workMode"/>
		END_VAR;
				//! <Function Comment="function for work the INIT of the Stationj-Objects&#13;&#10;" Name="workStationInits"/>
	FUNCTION workStationInits;
				//! <Function Comment="subroutine: work the commands given by the command-server" Name="workCmdIPConfig"/>
	FUNCTION workCmdIPConfig;
				//! <Function Comment="subroutine: work the state machine for &quot;Apply settings&quot;" Name="workApplySettings"/>
	FUNCTION workApplySettings;
				//! <Function Comment="check the IP settings of all stations" Name="checkIPSettings"/>
	FUNCTION checkIPSettings
		VAR_OUTPUT
			retval 	: DINT;			//! <Variable Comment="return value&#13;&#10;  0 = IP range is OK &#13;&#10;-1 = internal error during check&#13;&#10;-2 = NOT OK, stations with same IP found&#13;&#10;-3 = NOT OK, IP address is not allowed&#13;&#10;-4 = NOT OK, IP/subnet validation failed&#13;&#10;" Name="checkIPSettings.retval"/>
		END_VAR;
				//! <Function Comment="open the message box" Name="OpenMsgBox"/>
	FUNCTION OpenMsgBox
		VAR_INPUT
			MsgNr 	: DINT;			//! <Variable Comment="message number (nr)" Name="OpenMsgBox.MsgNr"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL CmdIPConfig::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _IP
#pragma usingLtd SigCLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _IPConfigMain::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__IPCONFIGMAIN
1$UINT, 2$UINT, (SIZEOF(::_IPConfigMain))$UINT, 
3$UINT, 4$UINT, 0$UINT, 
TO_UDINT(4058854491), "_IPConfigMain", //Class
TO_UDINT(3788417926), "_Global", 0$UINT, 14$UINT, //Baseclass
//Servers:
(::_IPConfigMain.NoOfStations.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(568876996), "NoOfStations", 
(::_IPConfigMain.CmdIPConfig.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1285581105), "CmdIPConfig", 
(::_IPConfigMain.NrLastMessage.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(3142740264), "NrLastMessage", 
//Clients:
(::_IPConfigMain._IP.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3530626343), "_IP", TO_UDINT(3530626343), "_IP", 1$UINT, 8$UINT, 
(::_IPConfigMain.SigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(77440046), "SigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 23$UINT, 
(::_IPConfigMain.ActWindow.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2511770808), "ActWindow", 
(::_IPConfigMain.ChangeIsActive.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3804088839), "ChangeIsActive", 
END_FUNCTION


#define USER_CNT__IPConfigMain 44

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__IPConfigMain] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _IPConfigMain::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _Global::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _Global::Server0.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _Global::Server0.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT__IPConfigMain;
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #IF_ProjectRun();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[40]		:= #IF_IpcIni();

#pragma warning (default : 74)
	_Global::Server0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _Global::Server0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	CmdIPConfig.pMeth			:= StoreMethod( #M_RD_DIRECT(), #CmdIPConfig::Write() );
	IF CmdIPConfig.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	NrLastMessage.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF NrLastMessage.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

#pragma usingltd _IPConfigStation


FUNCTION VIRTUAL GLOBAL _IPConfigMain::IF_IpcIni
	VAR_INPUT
		pini 	: ^_IPCINI;
	END_VAR

  piniSav := pini;          // save the pini pointer!

  workMainInits(0);         // INIT mode 0: called by IF_IpcIni()
  MainInitDone := 0;

  if (StationsInitStep <> INIT_DONE) then   // don't do the INIT after a SOFTRESET
    StationsInitStep := START_INIT_IF;      // set Statios INIT Step
  end_if;


END_FUNCTION


FUNCTION VIRTUAL GLOBAL _IPConfigMain::IF_ProjectRun
	VAR_INPUT
		pe 	: ^_EVENT;
	END_VAR
#pragma warning(default: 73);
	VAR
		i 	        : DINT;
	END_VAR


  //===================================================================================================================
  //
  // used for cyclic ToDos
  //
  //===================================================================================================================


  //===============================================================================================================
  // generate the time impulse
  //---------------------------------------------------------------------------------------------------------------
	hmsImp := 0;
  if ((ops.tAbsolute - TimeStampHmsImp) >= 100) then
    TimeStampHmsImp := ops.tAbsolute;
	  hmsImp := 1;
  end_if;  


  //===============================================================================================================
  // read clients
  //---------------------------------------------------------------------------------------------------------------
  ActWindow := ActWindow.Read();


  //===============================================================================================================
  //  work the stations Init
  //---------------------------------------------------------------------------------------------------------------
  workStationInits();


  //===============================================================================================================
  // work the IF_ipcini()
  // ... This needs a cyclic call because at the moment of the IF_ipcini() not all station data is available
  //     the NewInst() in the staion-object will need more than one cycle
  //---------------------------------------------------------------------------------------------------------------
  if ((StationsInitStep = INIT_DONE) & (MainInitDone = FALSE)) then
  
    workMainInits(1);        // mode 1: called outside IF_IpcIni()

    // check if all stations have status "main init done"
    MainInitDone := TRUE;           // default "main Init done"
    if (StationCount > 0) then
      for i:=0 to (StationCount -1) do
        if (StationList[i].StationStatus = 0) then
          MainInitDone := FALSE;
        end_if;
      end_for;
    end_if;
  end_if;


  //===============================================================================================================
  //  work the commands given by the command-server
  //---------------------------------------------------------------------------------------------------------------
  workCmdIPConfig();


  //===============================================================================================================
  //  work the state machine for "Apply settings"
  //---------------------------------------------------------------------------------------------------------------
  workApplySettings();


  //===================================================================================================================


END_FUNCTION


FUNCTION GLOBAL _IPConfigMain::RegisterStation
	VAR_INPUT
		pStation 	: ^void;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR

  retcode := -1;
  
  if (StationCount < sizeof(StationList)/sizeof(t_Station)) then
    StationList[StationCount].pStation      := pStation;
    StationList[StationCount].StationStatus := 0;
    StationCount += 1;
    retcode := 0;    
  end_if;

  NoOfStations := StationCount;   // Output for Visu
  
END_FUNCTION


FUNCTION _IPConfigMain::workMainInits
	VAR_INPUT
		workMode 	: DINT;
	END_VAR

	VAR
    myThis          : ^_IPConfigMain;
    StIP            : HDINT;
    StSubnet        : HDINT;
    StGateway       : HDINT;
    StStationNr     : DINT;
    StStationNrMM   : DINT;
    StNetMode       : _IPConfigStation::t_e_NET_MODE;
    StIsInternalIF  : DINT;
    StIsMMCommIF    : DINT;
		myRet           : DINT;
		myPtr           : ^_COMPORT;
		i 	            : DINT;
		x 	            : DINT;
		y 	            : DINT;
  END_VAR

  //===================================================================================================================
  //  IP-settings INIT
  //===================================================================================================================
  if ((StationCount > 0) & (piniSav^.ComSet.no)) then // need registered station(s) and ipc.ini-connection(s)
  
    for i:=0 to (StationCount -1) do    // loop for all stations
      
      if (StationList[i].pStation <> NIL) then
        myThis := this;
        this$^void := StationList[i].pStation;
        #pragma warning(disable: 137);
        myRet := myThis^.StationList[i].pStation$^_IPConfigStation^.GetSavedSettings( pIsInternalIF := #StIsInternalIF, 
                                                                                      pIsMMCommIF   := #StIsMMCommIF, 
                                                                                      pIP           := #StIP, 
                                                                                      pSubnet       := #StSubnet, 
                                                                                      pGateway      := #StGateway, 
                                                                                      pStationNr    := #StStationNr, 
                                                                                      pStationNrMM  := #StStationNrMM, 
                                                                                      pNetMode      := #StNetMode);
        #pragma warning(default: 137);
        this := myThis;

        if (myRet = 0) then

          //=========================================================================================================
          //
          //  Case A: Station is NOT in NetMode "Software-IP" and is not in mode "InitDeviceIP"
          //
          //    !!! the station-object gets the settings from the ConfigIF-object - that needs time !!!
          //    !!! so it's not always possible to work this case only inside the IF_IpcIni() !!!
          //    !!! it can be necessary to work this case later (= outside) the IF_IpcIni() !!!
          //=========================================================================================================
          if ((StNetMode <> SoftwareIP) & (StNetMode <> InitDeviceIP)) then
          
            StationList[i].StationStatus := 1;        // Status "main Init done"

            //=======================================================================================================
            //  (Case A) work with the ipc.ini structure (for LSE network settings)
            //=======================================================================================================
            //    the ipc.ini has still the actual settings! 
            //    --> search in the ipc.ini for the IP of the station-object and set the station-number 
            //        of the station-object to the value of the ipc.ini
            //-------------------------------------------------------------------------------------------------------
            for x:=0 to (piniSav^.ComSet.no -1) do    // loop for all ipc.ini-connections
            
              myPtr := piniSav^.ComSet.ptr + x*sizeof(_COMPORT);  // set the pointer to the connection data

              // is the IP address the same as the IP of the station-object?
              // or is IP address marked as INTERNAL and the station-IF is also an internal IF?
              if ( (myPtr^.comdef.ipadress = StIP) |
                   ((myPtr^.comdef.typ = _COM_INTERN) & (StIsInternalIF = 1)) )then

                // get the station-nr: = index of the mapper[] where the mapper-content is the ptr-index 
                // (see LSE-Kernel docu to "IF_IpcIni")
                for y:=0 to (255) do
                  if (piniSav^.ComSet.mapper[y] = (TO_UINT(x))$_COMAP) then
                    StStationNr := y;
                  end_if;
                end_for;

                // set the station-nr to the station-object
                myThis := this;                                 
                this$^void := StationList[i].pStation;
                #pragma warning(disable: 137);
                myThis^.StationList[i].pStation$^_IPConfigStation^.SetStationNr(StStationNr);
                #pragma warning(default: 137);
                this := myThis;

              end_if;

            end_for;

            //=======================================================================================================
            //  (Case A) work with the MultiMaster settings (for MultiMaster communication)
            //=======================================================================================================
            //    the MultiMaster settings have still the actual settings! 
            //    --> Search in the MultiMaster settings for the IP of the station-object and set the 
            //        MM-station-number of the station-object to the value of the MM-settings
            //-------------------------------------------------------------------------------------------------------
(* --- is done in the station object ---
            if (StIsMMCommIF = 1) then    // only if station is used for MultiMaster communication
              for x:=0 to (255 -1) do     // loop MultiMaster stations

                tmpTxt[0] := 0;
                LDR_MM_StatNrConnGetStr(udStationId:=TO_UDINT(x), pszConn:=#tmpTxt[0]);
                if (tmpTxt[0] = 'T') then   // IP-String starts with "TCPIP:"
                  _IP.ConvertStrToBin(strAddress:=#tmpTxt[6], pIPAddress:=#tmpIP$UDINT);  // convert IP address

                  if (tmpIP = StIP) then    // is the MultiMaster-IP the the Station-IP?
                    // set the station-nr to the station-object
                    myThis := this;                                 
                    this$^void := StationList[i].pStation;
                    #pragma warning(disable: 137);
                    myThis^.StationList[i].pStation$^_IPConfigStation^.SetStationNrMM(StationNumberMM:=x);;
                    #pragma warning(default: 137);
                    this := myThis;
                    exit;
                  end_if;

                end_if;

              end_for;
            end_if;
*)
            //=======================================================================================================

          end_if;   // (StNetMode)


          //=========================================================================================================
          //
          //  Case B: Station IS in NetMode "Software-IP" 
          //
          //    the Station-object holds the actual settings!
          //=========================================================================================================
          if (StNetMode = SoftwareIP) then

            StationList[i].StationStatus := 1;    // Status "main Init done"

            //=======================================================================================================
            //  (Case B) work with the ipc.ini structure (for LSE network settings)
            //=======================================================================================================
            //    the ipc.ini has NOT the actual settings! 
            //    --> overwrite the values within the ipc.ini-struct with data from the station-object.
            //        (so now the LSE-communication works with "Software-IP" settings)
            //-------------------------------------------------------------------------------------------------------
            //    !!! it's generally not allowed to work this function outside the IF_IpcIni() !!!
            //-------------------------------------------------------------------------------------------------------
            if (workMode = 0) then  // mode 0: called by IF_IpcIni()
            
              // station-nr = index of the mapper[] (see LSE-Kernel docu to "IF_IpcIni")
              // mapper-content[station-nr] is the ptr-index
              x := TO_DINT((piniSav^.ComSet.mapper[StStationNr])$UINT); // ptr-index

              if (x <= (piniSav^.ComSet.no -1)) then
              
                myPtr := piniSav^.ComSet.ptr + x*sizeof(_COMPORT);  // set the pointer to the connection data
                myPtr^.comdef.ipadress := StIP;                     // set the IP address in ipc.ini-struct

              end_if;

            end_if;

            //=======================================================================================================
            //  (Case B) work with the MultiMaster settings (for MultiMaster communication)
            //=======================================================================================================
            //    the MultiMaster settings have NOT the actual settings! 
            //    --> overwrite the MultiMaster-Settings with data from the station-object.
            //        (so now the MultiMaster-communication works with "Software-IP" settings)
            //-------------------------------------------------------------------------------------------------------
(* --- is done in the station object ---
            if ((StIsInternalIF = 0) & (StIsMMCommIF = 1)) then   // only if station is external IF and used for MultiMaster

              SigCLib.StrCpy(dst0:=#tmpTxt[0], src0:="TCPIP:");   // needed Prefix
              _IP.ConvertBinToStr(strAddress:=#tmpTxt[6], strAddressLen:=sizeof(tmpTxt)-6, TO_UDINT(StIP));
              LDR_MM_StatNrConnSetStr(udStationId:=TO_UINT(StStationNrMM), pszConn:=#tmpTxt[0]);

            end_if;
*)
            //=======================================================================================================

          end_if;   // (StNetMode)

          //-------------------------------------------------------------------------------------------------------

          //=========================================================================================================

        end_if;   // (myRet)
      end_if;   // (pStation <> NIL)
    end_for;
  end_if;   // (registered station(s) and ipc.ini-connection(s))
  //===================================================================================================================

END_FUNCTION


FUNCTION _IPConfigMain::workStationInits

	VAR
    myThis          : ^_IPConfigMain;
		myRet           : DINT;
    foundBUSY       : BOOL;
		i 	            : DINT;
  END_VAR


  //=========================================================================================================
  // state machine with different steps for Stations INIT
  //=========================================================================================================
  case (StationsInitStep) of

    //=======================================================================================================
    // INIT_IDLE ... nothing to do
  	//-------------------------------------------------------------------------------------------------------
    INIT_IDLE:

    //=======================================================================================================
    // START_INIT_IF ... start the Stations INIT Interfaces
  	//-------------------------------------------------------------------------------------------------------
    START_INIT_IF:

      if (StationCount > 0) then

        for i:=0 to (StationCount -1) do

          if (StationList[i].pStation <> NIL) then
            myThis := this;
            this$^void := StationList[i].pStation;
            #pragma warning(disable: 137);
            myThis^.StationList[i].pStation$^_IPConfigStation^.CmdInitIF(HmsDelay:=i*0);
            #pragma warning(default: 137);
            this := myThis;
          end_if;

        end_for;
        StationsInitStep := CHECK_INIT_IF;

      else
        StationsInitStep := INIT_IDLE;
        OpenMsgBox(MsgNr:=-7);   // ERROR: no stations (interfacees) registered
      end_if;

    //=======================================================================================================
    // CHECK_INIT_IF ... check the Stations INIT Interfaces
  	//-------------------------------------------------------------------------------------------------------
    CHECK_INIT_IF:

      foundBUSY := FALSE;

      if (StationCount > 0) then

        for i:=0 to (StationCount -1) do

          if (StationList[i].pStation <> NIL) then
            myThis := this;
            this$^void := StationList[i].pStation;
            #pragma warning(disable: 137);
            myRet := myThis^.StationList[i].pStation$^_IPConfigStation^.GetInitStatusIF();
            #pragma warning(default: 137);
            this := myThis;

            if (myRet = 0) then
              foundBUSY := TRUE;
            end_if;

          end_if;

        end_for;

        if (foundBUSY = FALSE) then
          StationsInitStep := START_INIT_MM;
        end_if;

      else    // (that case is not really possible in this step ...)
        StationsInitStep := INIT_IDLE;
        OpenMsgBox(MsgNr:=-7);   // ERROR: no stations (interfacees) registered
      end_if;

    //=======================================================================================================
    // START_INIT_MM ... start the Stations INIT MultiMaster
  	//-------------------------------------------------------------------------------------------------------
    START_INIT_MM:

      if (StationCount > 0) then

        for i:=0 to (StationCount -1) do

          if (StationList[i].pStation <> NIL) then
            myThis := this;
            this$^void := StationList[i].pStation;
            #pragma warning(disable: 137);
            myThis^.StationList[i].pStation$^_IPConfigStation^.CmdInitMM(HmsDelay:=i*0);
            #pragma warning(default: 137);
            this := myThis;
          end_if;

        end_for;
        StationsInitStep := CHECK_INIT_MM;

      else    // (that case is not really possible in this step ...)
        StationsInitStep := INIT_IDLE;
        OpenMsgBox(MsgNr:=-7);   // ERROR: no stations (interfacees) registered
      end_if;

    //=======================================================================================================
    // CHECK_INIT_MM ... check the Stations INIT MultiMaster
  	//-------------------------------------------------------------------------------------------------------
    CHECK_INIT_MM:

      foundBUSY := FALSE;

      if (StationCount > 0) then

        for i:=0 to (StationCount -1) do

          if (StationList[i].pStation <> NIL) then
            myThis := this;
            this$^void := StationList[i].pStation;
            #pragma warning(disable: 137);
            myRet := myThis^.StationList[i].pStation$^_IPConfigStation^.GetInitStatusMM();
            #pragma warning(default: 137);
            this := myThis;

            if (myRet = 0) then
              foundBUSY := TRUE;
            end_if;

          end_if;

        end_for;

        if (foundBUSY = FALSE) then
          StationsInitStep := INIT_DONE;
        end_if;

      else    // (that case is not really possible in this step ...)
        StationsInitStep := INIT_IDLE;
        OpenMsgBox(MsgNr:=-7);   // ERROR: no stations (interfacees) registered
      end_if;

    //=======================================================================================================
    // INIT_DONE ... nothing more to do
  	//-------------------------------------------------------------------------------------------------------
    INIT_DONE:


    //=======================================================================================================

  end_case;


END_FUNCTION


FUNCTION _IPConfigMain::workCmdIPConfig
  VAR
    Ret           : DINT;
  END_VAR

  //=========================================================================================================
  // different Commands to operate with the IP configuration
  //=========================================================================================================

  case (NewCmdIPConfig) of
  
    //-------------------------------------------------------------------------------------------------------
    // Command 1: "check IP settings"
    //-------------------------------------------------------------------------------------------------------
    1:
      Ret := checkIPSettings();
      if (Ret < 0) then
        OpenMsgBox(MsgNr:=Ret);   // ERROR-Message
      else
        OpenMsgBox(MsgNr:=1);     // OK-Message
      end_if;

    //-------------------------------------------------------------------------------------------------------
    // Command 2: "Apply IP settings"
    //-------------------------------------------------------------------------------------------------------
    2:
      if (StationsInitStep <> INIT_DONE) then
        OpenMsgBox(MsgNr:=2);       // BUSY-Message

      else

        Ret := checkIPSettings();
        if (Ret < 0) then
          OpenMsgBox(MsgNr:=Ret);   // ERROR-Message
        else
          OpenMsgBox(MsgNr:=3);     // started-Message
          ApplyStep := START_APPLY; // set the "START_APPLY" step for the state machine
        end_if;

      end_if;

    //-------------------------------------------------------------------------------------------------------
    // Command 3: ""
    //-------------------------------------------------------------------------------------------------------
    3:

    //-------------------------------------------------------------------------------------------------------
    // Command 4: ""
    //-------------------------------------------------------------------------------------------------------
    4:

    //-------------------------------------------------------------------------------------------------------
    // Command 5: ""
    //-------------------------------------------------------------------------------------------------------
    5:


    //-------------------------------------------------------------------------------------------------------
    // unknown command
    //-------------------------------------------------------------------------------------------------------
    else



    //-------------------------------------------------------------------------------------------------------



  
  end_case;

  NewCmdIPConfig := 0;

  //=========================================================================================================

END_FUNCTION


FUNCTION _IPConfigMain::workApplySettings
	VAR
    myThis          : ^_IPConfigMain;
		myRet           : DINT;
    foundNOK        : BOOL;
    foundBUSY       : BOOL;
		i 	            : DINT;
  END_VAR


  //=========================================================================================================
  // state machine with different steps for procedure "Apply settings"
  //=========================================================================================================
  case (ApplyStep) of

    //=======================================================================================================
    // APPLY_IDLE ... no action
  	//-------------------------------------------------------------------------------------------------------
    APPLY_IDLE:

      if (ChangeIsActive <> 0) then
        ChangeIsActive := ChangeIsActive.Write(0);    // reset "the changing of the IP addresses is active"
      end_if;


    //=======================================================================================================
    // START_APPLY ... first steps
    //-------------------------------------------------------------------------------------------------------
    START_APPLY:

      ChangeIsActive := ChangeIsActive.Write(1);    // set "the changing of the IP addresses is active"
      ApplyHmsWait := 15;
      ApplyStep := SEND_APPLY_IF;

    //=======================================================================================================
    // SEND_APPLY_IF ... forward command for interfaces to all Station objects
    //-------------------------------------------------------------------------------------------------------
    SEND_APPLY_IF:

      ApplyHmsWait -= hmsImp;
      if (ApplyHmsWait <= 0) then
        ApplyHmsWait := 0;

        if (StationCount > 0) then

          for i:=0 to (StationCount -1) do

            if (StationList[i].pStation <> NIL) then
              myThis := this;
              this$^void := StationList[i].pStation;
              #pragma warning(disable: 137);
              myThis^.StationList[i].pStation$^_IPConfigStation^.CmdApplySettingsIF(i*0);
              #pragma warning(default: 137);
              this := myThis;
            end_if;

          end_for;
          ApplyHmsWait := 5;
          ApplyStep := CHECK_APPLY_IF;

        else
          ApplyStep := APPLY_IDLE;
          OpenMsgBox(MsgNr:=-7);   // ERROR: no stations (interfacees) registered
        end_if;

      end_if;

    //=======================================================================================================
    // CHECK_APPLY_IF ... check the apply-status of interfaces of all Stations
    //-------------------------------------------------------------------------------------------------------
    CHECK_APPLY_IF:

      ApplyHmsWait -= hmsImp;
      if (ApplyHmsWait <= 0) then
        ApplyHmsWait := 0;

        foundNOK  := FALSE;
        foundBUSY := FALSE;

        if (StationCount > 0) then

          for i:=0 to (StationCount -1) do

            if (StationList[i].pStation <> NIL) then
              myThis := this;
              this$^void := StationList[i].pStation;
              #pragma warning(disable: 137);
              myRet := myThis^.StationList[i].pStation$^_IPConfigStation^.GetApplyStatus();
              #pragma warning(default: 137);
              this := myThis;

              if (myRet = 0) then
                foundBUSY := TRUE;
              elsif (myRet < 0) then
                foundNOK  := TRUE;
              end_if;

            end_if;

          end_for;

          if (foundNOK = TRUE) then
            ApplyHmsWait := 0;
            ApplyStep := APPLY_NOK;
          end_if;
          if ((foundBUSY = FALSE) & (foundNOK = FALSE)) then
            ApplyHmsWait := 0;
            ApplyStep := SEND_APPLY_MM;
          end_if;

        else    // (that case is not really possible in this step ...)
          ApplyStep := APPLY_IDLE;
          OpenMsgBox(MsgNr:=-7);   // ERROR: no stations (interfacees) registered
        end_if;

      end_if;

    //=======================================================================================================
    // SEND_APPLY_MM ... forward command for MultiMaster-settings to all Station objects
    //-------------------------------------------------------------------------------------------------------
    SEND_APPLY_MM:

      ApplyHmsWait -= hmsImp;
      if (ApplyHmsWait <= 0) then
        ApplyHmsWait := 0;

        if (StationCount > 0) then

          for i:=0 to (StationCount -1) do

            if (StationList[i].pStation <> NIL) then
              myThis := this;
              this$^void := StationList[i].pStation;
              #pragma warning(disable: 137);
              myThis^.StationList[i].pStation$^_IPConfigStation^.CmdApplySettingsMM(i*0);
              #pragma warning(default: 137);
              this := myThis;
            end_if;

          end_for;
          ApplyHmsWait := 5;
          ApplyStep := CHECK_APPLY_MM;

        else
          ApplyStep := APPLY_IDLE;
          OpenMsgBox(MsgNr:=-7);   // ERROR: no stations (interfacees) registered
        end_if;

      end_if;

    //=======================================================================================================
    // CHECK_APPLY_MM ... check the apply-status of Multimaster of all Stations
    //-------------------------------------------------------------------------------------------------------
    CHECK_APPLY_MM:

      ApplyHmsWait -= hmsImp;
      if (ApplyHmsWait <= 0) then
        ApplyHmsWait := 0;

        foundNOK  := FALSE;
        foundBUSY := FALSE;

        if (StationCount > 0) then

          for i:=0 to (StationCount -1) do

            if (StationList[i].pStation <> NIL) then
              myThis := this;
              this$^void := StationList[i].pStation;
              #pragma warning(disable: 137);
              myRet := myThis^.StationList[i].pStation$^_IPConfigStation^.GetApplyStatus();
              #pragma warning(default: 137);
              this := myThis;

              if (myRet = 0) then
                foundBUSY := TRUE;
              elsif (myRet < 0) then
                foundNOK  := TRUE;
              end_if;

            end_if;

          end_for;

          if (foundNOK = TRUE) then
            ApplyHmsWait := 0;
            ApplyStep := APPLY_NOK;
          end_if;
          if ((foundBUSY = FALSE) & (foundNOK = FALSE)) then
            ApplyHmsWait := 0;
            ApplyStep := SEND_APPLY_OK;
          end_if;

        else    // (that case is not really possible in this step ...)
          ApplyStep := APPLY_IDLE;
          OpenMsgBox(MsgNr:=-7);   // ERROR: no stations (interfacees) registered
        end_if;

      end_if;

    //=======================================================================================================
    // SEND_APPLY_MM ... forward command for "Apply OK" to all Station objects
    //-------------------------------------------------------------------------------------------------------
    SEND_APPLY_OK:

      ApplyHmsWait -= hmsImp;
      if (ApplyHmsWait <= 0) then
        ApplyHmsWait := 0;

        if (StationCount > 0) then

          for i:=0 to (StationCount -1) do

            if (StationList[i].pStation <> NIL) then
              myThis := this;
              this$^void := StationList[i].pStation;
              #pragma warning(disable: 137);
              myThis^.StationList[i].pStation$^_IPConfigStation^.CmdApplyOK(20);
              #pragma warning(default: 137);
              this := myThis;
            end_if;

          end_for;
          ApplyHmsWait := 5;
          ApplyStep := CHECK_APPLY_OK;

        else
          ApplyStep := APPLY_IDLE;
          OpenMsgBox(MsgNr:=-7);   // ERROR: no stations (interfacees) registered
        end_if;

      end_if;

    //=======================================================================================================
    // CHECK_APPLY_OK ... check the apply-status of all Stations
    //-------------------------------------------------------------------------------------------------------
    CHECK_APPLY_OK:

      ApplyHmsWait -= hmsImp;
      if (ApplyHmsWait <= 0) then
        ApplyHmsWait := 0;

        foundNOK  := FALSE;
        foundBUSY := FALSE;

        if (StationCount > 0) then

          for i:=0 to (StationCount -1) do

            if (StationList[i].pStation <> NIL) then
              myThis := this;
              this$^void := StationList[i].pStation;
              #pragma warning(disable: 137);
              myRet := myThis^.StationList[i].pStation$^_IPConfigStation^.GetApplyStatus();
              #pragma warning(default: 137);
              this := myThis;

              if (myRet = 0) then
                foundBUSY := TRUE;
              elsif (myRet < 0) then
                foundNOK  := TRUE;
              end_if;

            end_if;

          end_for;

          if (foundNOK = TRUE) then
            ApplyHmsWait := 0;
            ApplyStep := APPLY_NOK;
          end_if;
          if ((foundBUSY = FALSE) & (foundNOK = FALSE)) then
            ApplyHmsWait := 0;
            ApplyStep := APPLY_OK;
          end_if;

        else    // (that case is not really possible in this step ...)
          ApplyStep := APPLY_IDLE;
          OpenMsgBox(MsgNr:=-7);   // ERROR: no stations (interfacees) registered
        end_if;

      end_if;

  	//=======================================================================================================
    // APPLY_NOK ... one or more applies went wrong -> reset all Stations to old settings
  	//-------------------------------------------------------------------------------------------------------
    APPLY_NOK:

      ApplyHmsWait -= hmsImp;
      if (ApplyHmsWait <= 0) then
        ApplyHmsWait := 0;

        if (StationCount > 0) then

          for i:=0 to (StationCount -1) do

            if (StationList[i].pStation <> NIL) then
              myThis := this;
              this$^void := StationList[i].pStation;
              #pragma warning(disable: 137);
              myThis^.StationList[i].pStation$^_IPConfigStation^.CmdRestoreSavedAddr();;
              #pragma warning(default: 137);
              this := myThis;

            end_if;

          end_for;

          ApplyStep := APPLY_IDLE;
          OpenMsgBox(MsgNr:=4);   // MSG: "apply IP settings" failed

        else    // (that case is not really possible in this step ...)
          ApplyStep := APPLY_IDLE;
          OpenMsgBox(MsgNr:=-7);   // ERROR: no stations (interfacees) registered
        end_if;

      end_if;

  	//=======================================================================================================
    // APPLY_OK ... all applies went OK -> save new settings on all Stations
  	//-------------------------------------------------------------------------------------------------------
    APPLY_OK:

      ApplyHmsWait -= hmsImp;
      if (ApplyHmsWait <= 0) then
        ApplyHmsWait := 0;

        if (StationCount > 0) then

          for i:=0 to (StationCount -1) do

            if (StationList[i].pStation <> NIL) then
              myThis := this;
              this$^void := StationList[i].pStation;
              #pragma warning(disable: 137);
              myThis^.StationList[i].pStation$^_IPConfigStation^.SaveIOSettings();
              myThis^.StationList[i].pStation$^_IPConfigStation^.SetNetMode(NewNetMode:=SoftwareIP);
              #pragma warning(default: 137);
              this := myThis;

            end_if;

          end_for;

          OpenMsgBox(MsgNr:=5);   // MSG: "apply IP settings" successful - SOFTRESET!
          ApplyHmsWait := 20;
          ApplyStep := LSE_SOFTRESET;

        else    // (that case is not really possible in this step ...)
          ApplyStep := APPLY_IDLE;
          OpenMsgBox(MsgNr:=-7);   // ERROR: no stations (interfacees) registered
        end_if;

      end_if;

  	//=======================================================================================================
    // LSE_SOFTRESET ... Softreset for LSE-communication
  	//-------------------------------------------------------------------------------------------------------
    LSE_SOFTRESET:

      ApplyHmsWait -= hmsImp;
      if (ApplyHmsWait <= 0) then
        ApplyHmsWait := 0;

        ApplyStep := APPLY_DONE;
        Lse.IF_Softreset();

      end_if;

  	//=======================================================================================================
    // APPLY_DONE ... Apply completely done
  	//-------------------------------------------------------------------------------------------------------
    APPLY_DONE:

      ApplyHmsWait -= hmsImp;
      if (ApplyHmsWait <= 0) then
        ApplyHmsWait := 0;

        OpenMsgBox(MsgNr:=6);     // "completely done"-Message
        ApplyStep := APPLY_IDLE;

      end_if;

  	//=======================================================================================================
  end_case;

  //=========================================================================================================

END_FUNCTION


FUNCTION _IPConfigMain::checkIPSettings
	VAR_OUTPUT
		retval 	: DINT;
	END_VAR

	VAR
    myThis            : ^_IPConfigMain;
    X_IP            : HDINT;
    X_Subnet        : HDINT;
    X_Gateway       : HDINT;
    X_StationNr     : DINT;
    X_StationNrMM   : DINT;
    X_NetMode       : _IPConfigStation::t_e_NET_MODE;
    X_IsInternalIF  : DINT;
    X_IsMMCommIF    : DINT;
		RetX            : DINT;
    Y_IP            : HDINT;
    Y_Subnet        : HDINT;
    Y_Gateway       : HDINT;
    Y_StationNr     : DINT;
    Y_StationNrMM   : DINT;
    Y_NetMode       : _IPConfigStation::t_e_NET_MODE;
    Y_IsInternalIF  : DINT;
    Y_IsMMCommIF    : DINT;
		RetY            : DINT;
    mySubnet        : HDINT;
		x 	            : DINT;
		y 	            : DINT;
	END_VAR

  retval := 0;    // default: IP range is OK 

  //-------------------------------------------------------------------------------------------------------------------
  // check only possible if there are more than one stations
  //-------------------------------------------------------------------------------------------------------------------
  if (StationCount < 2) then
    return;
  end_if;

  //-------------------------------------------------------------------------------------------------------------------
  // loop for calculating the subnet-mask for the validation
  //-------------------------------------------------------------------------------------------------------------------
  mySubnet := 0;

  for x:=0 to (StationCount -1) do
    
    if (StationList[x].pStation <> NIL) then

      //-------------------------------------------------------------------------------------------------------
      // get data from Station X (for the check we need the IO-Data)
      //-------------------------------------------------------------------------------------------------------
      myThis := this;
      this$^void := StationList[x].pStation;
      #pragma warning(disable: 137);
      RetX := myThis^.StationList[x].pStation$^_IPConfigStation^.GetIOSettings( pIsInternalIF := #X_IsInternalIF, 
                                                                                pIsMMCommIF   := #X_IsMMCommIF, 
                                                                                pIP           := #X_IP, 
                                                                                pSubnet       := #X_Subnet, 
                                                                                pGateway      := #X_Gateway, 
                                                                                pStationNr    := #X_StationNr, 
                                                                                pStationNrMM  := #X_StationNrMM, 
                                                                                pNetMode      := #X_NetMode);
      #pragma warning(default: 137);
      this := myThis;

    else
      retval := -1;   // internal error during check
    end_if;

    if (RetX = 0) then
      if (X_IsMMCommIF = 1) then
        mySubnet := mySubnet or X_Subnet;
      end_if;
    else
      retval := -1;   // internal error during check
    end_if;

  end_for;

  if (retval < 0) then
    return;  
  end_if;

  //-------------------------------------------------------------------------------------------------------------------
  // outer loop for getting station X for the validation
  //-------------------------------------------------------------------------------------------------------------------
  for x:=0 to (StationCount -2) do      // station X only works until next-to-last
    
    if (StationList[x].pStation <> NIL) then

      //-------------------------------------------------------------------------------------------------------
      // get data from Station X (for the check we need the IO-Data)
      //-------------------------------------------------------------------------------------------------------
      myThis := this;
      this$^void := StationList[x].pStation;
      #pragma warning(disable: 137);
      RetX := myThis^.StationList[x].pStation$^_IPConfigStation^.GetIOSettings( pIsInternalIF := #X_IsInternalIF, 
                                                                                pIsMMCommIF   := #X_IsMMCommIF, 
                                                                                pIP           := #X_IP, 
                                                                                pSubnet       := #X_Subnet, 
                                                                                pGateway      := #X_Gateway, 
                                                                                pStationNr    := #X_StationNr, 
                                                                                pStationNrMM  := #X_StationNrMM, 
                                                                                pNetMode      := #X_NetMode);
      #pragma warning(default: 137);
      this := myThis;

    else
      retval := -1;   // internal error during check
    end_if;

    //-------------------------------------------------------------------------------------------------------------
    // inner loop for validation of station X with all the following stations
    //-------------------------------------------------------------------------------------------------------------
    for y:=x+1 to (StationCount -1) do

      if ((StationList[x].pStation <> NIL) & (StationList[y].pStation <> NIL)) then

        //-----------------------------------------------------------------------------------------------------
        // get data from Station Y (for the check we need the IO-Data)
        //-----------------------------------------------------------------------------------------------------
        myThis := this;
        this$^void := StationList[y].pStation;
        #pragma warning(disable: 137);
        RetY := myThis^.StationList[y].pStation$^_IPConfigStation^.GetIOSettings( pIsInternalIF := #Y_IsInternalIF, 
                                                                                  pIsMMCommIF   := #Y_IsMMCommIF, 
                                                                                  pIP           := #Y_IP, 
                                                                                  pSubnet       := #Y_Subnet, 
                                                                                  pGateway      := #Y_Gateway, 
                                                                                  pStationNr    := #Y_StationNr, 
                                                                                  pStationNrMM  := #Y_StationNrMM, 
                                                                                  pNetMode      := #Y_NetMode);
        #pragma warning(default: 137);
        this := myThis;

        //-----------------------------------------------------------------------------------------------------
        // and now the checks ...
        //-----------------------------------------------------------------------------------------------------
        if ((RetX = 0) & (RetY = 0)) then

          //----- IPs must be different -----------------------------------------------------------
          if (X_IP = Y_IP) then
            retval := -2;           // NOT OK, stations with same IP found
          end_if;

          //----- last position of IPs: 0 and 255 ist not allowed ---------------------------------
          if ( ((X_IP and 16#FF000000) = 0) | ((X_IP and 16#FF000000) = 16#FF000000) )then  // x.x.x.0 or x.x.x.255
            retval := -3;           // NOT OK, IP address is not allowed
          end_if;
          if ( ((Y_IP and 16#FF000000) = 0) | ((Y_IP and 16#FF000000) = 16#FF000000) )then  // x.x.x.0 or x.x.x.255
            retval := -3;           // NOT OK, IP address is not allowed
          end_if;

          //----- IP/subnet validation between the two stations -----------------------------------
          if (retval = 0) then
            if ( (X_IsMMCommIF = 1) & (Y_IsMMCommIF = 1) ) then // only if IFs are used for MultiMaster communication
              if ( (X_IP and mySubnet) <> (Y_IP and mySubnet) ) then
                retval := -4;       // NOT OK, IP/subnet validation failed
              end_if;
            end_if;
          end_if;
          //----- Gateway/subnet validation between the two stations ------------------------------
          if (retval = 0) then
            if ( (X_IsMMCommIF = 1) & (Y_IsMMCommIF = 1) ) then // only if IFs are used for MultiMaster communication
              if ( (X_Gateway and mySubnet) <> (Y_Gateway and mySubnet) ) then
//no check!                retval := -5;       // NOT OK, Gateway/subnet validation failed
              end_if;
            end_if;
          end_if;

        else
          retval := -1;   // internal error during check
        end_if;
        //---------------------------------------------------------------------------------------------------

      else
        retval := -1;   // internal error during check
      end_if;

    end_for;
    //-------------------------------------------------------------------------------------------------------------

  end_for;
  //-------------------------------------------------------------------------------------------------------------------

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _IPConfigMain::CmdIPConfig::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR


	CmdIPConfig := input;
	result := CmdIPConfig;
  NewCmdIPConfig  := input;

END_FUNCTION


FUNCTION _IPConfigMain::OpenMsgBox
	VAR_INPUT
		MsgNr 	: DINT;
	END_VAR

  NrLastMessage.Write(MsgNr);

  if (ActWindow = IPcfgWindowNrMsgBox) then
    InsertCmd(x0:=CMD_CLOSE, x1:=IPcfgWindowNrMsgBox, x2:=0);    // close the old Message Box
  end_if;
  InsertCmd(x0:=CMD_NEWWINDOW, x1:=IPcfgWindowNrMsgBox, x2:=0);  // open a new Message Box

//-----------------------------------------------------------------------------
//  negative Msg-No: known errors
//-----------------------------------------------------------------------------
// -01 - ERROR: "check IP Settings" - internal error during check
// -02 - ERROR: "check IP Settings" stations with same IP addr. found
// -03 - ERROR: "check IP Settings" IP address is not allowed
// -04 - ERROR: "check IP Settings" IP/Subnet validation failed
// -05 - ERROR: "check IP Settings" Gateway/Subnet validation failed
// -06 - ERROR: 
// -07 - ERROR: no stations (interfacees) registered
// -08 - ERROR: 
// -09 - ERROR: 
// -10 - ERROR: 
//-----------------------------------------------------------------------------
//  positive Msg-No: known messages
//-----------------------------------------------------------------------------
// +01 - "check IP settings" was OK
// +02 - IP Configuration is BUSY - please try again later
// +03 - "apply IP settings" started ...
// +04 - "apply IP settings" failed - all settings have been reset
// +05 - "apply IP settings" successful - SOFTRESET follows ...
// +06 - "apply IP settings" completely done
// +07 - 
// +08 - 
// +09 - 
// +10 - 
//
//--------------------------------------------------------------------------------------

END_FUNCTION


