//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES

//===========================================================================================================


#define NiCmdIF_HmsWaitIF     20        // NewInst() command to IF object: 
                                        // Time Delay for command work [100 ms] within the IF object


//===========================================================================================================
//}}LSL_DEFINES

//{{LSL_DECLARATION
#include <.\LoaderItf.h>

(*!
<Class
	Name               = "_IPConfigStation"
	Revision           = "1.2"
	GUID               = "{C1ECE2CF-38FC-43C6-AB01-A027547A72B2}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "true"
	DefBackground      = "100 ms"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(570,660)"
	Comment            = "IP Configuration Station&#13;&#10;represents one interface of a station">
	<Channels>
		<Server Name="ClassSvr" GUID="{2F5AB7B1-E543-48C1-915C-11A87E6FFE13}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="class server"/>
		<Server Name="ExtResetCmd" GUID="{414E14AB-E33D-4796-AF62-AD2B61A3EDBC}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="Gateway" GUID="{1E990D3C-0436-4494-86F4-2F4DA3C1BC18}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Network gateway  (I/O)"/>
		<Server Name="InputDirty" GUID="{F7140E16-2B34-4FF8-9C13-A3C9CAE58DEB}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Input dirty bitmask&#13;&#10;Bit 0: IP address&#13;&#10;Bit 1: Subnet&#13;&#10;Bit 2: Gateway"/>
		<Server Name="IPAddress" GUID="{43CE96D5-9987-4C22-92C5-0FDA596A73E3}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Network IP address (I/O)"/>
		<Server Name="IsOnlineMM" GUID="{1E41BDDC-198A-48C7-953C-3BD76C7E9549}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="actual MultiMaster network status&#13;&#10;.. can only be determined in case of an external IF which is also a MultiMaster IF&#13;&#10;0 = offline&#13;&#10;1 = online&#13;&#10;&#13;&#10;"/>
		<Server Name="LastError" GUID="{10637784-0031-49E7-976E-6DD62F78A667}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="last error-code if an error occured"/>
		<Server Name="NetMode" GUID="{23A507EB-D3EC-4185-92FD-14810EE78D02}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="SRam" Comment="actual network mode"/>
		<Server Name="SavGateway" GUID="{E655F539-6A6F-4842-AF4B-1B9E31433219}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="SRam" Comment="saved Network gateway&#13;&#10;for restore in case of problems"/>
		<Server Name="SavIPAddress" GUID="{9A57137E-97D5-48CC-8D3A-3613DBE4810D}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="SRam" Comment="saved Network IP address&#13;&#10;for restore in case of problems"/>
		<Server Name="SavSubnet" GUID="{FFE80237-7351-455B-85C0-4121370187C2}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="SRam" Comment="saved Network subnet mask&#13;&#10;for restore in case of problems"/>
		<Server Name="StationNr" GUID="{C7CA0CB5-4EE7-4E53-A841-ED493FB94B21}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="SRam" Comment="Station number (LSE, from ipc.ini)"/>
		<Server Name="StationNrMM" GUID="{EF746CB0-826C-4122-9476-4DF28168A00A}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="SRam" Comment="MultiMaster Station number (0 to x)&#13;&#10;-1 = no MultiMaster station number&#13;&#10;value can only be determined in case of an external IF which is also a MultiMaster IF"/>
		<Server Name="Subnet" GUID="{7D08E9F1-426F-41DB-88C9-55A3A63FC584}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Network subnet mask  (I/O)"/>
		<Server Name="Timeout" GUID="{07111149-CA23-4EE1-9645-FE6EC532D619}" Visualized="true" Initialize="true" DefValue="30" WriteProtected="false" Retentive="SRam" Comment="preset value for timeout [s]&#13;&#10;internal minimum value 10 [s]"/>
		<Server Name="TimeoutCnt" GUID="{CBCBE07A-3F42-4FB4-A8CE-558C231EDA9F}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="SRam" Comment="actual timeout counter [s]"/>
		<Client Name="_IP" Required="false" Internal="false" Comment="Object channel to _IP (don&apos;t connect)"/>
		<Client Name="_IPConfigIF" Required="true" Internal="false" Comment="Command channel to a _IPConfigIF object"/>
		<Client Name="_IPConfigMain" Required="true" Internal="false" Comment="Command channel to a _IPConfigMain object"/>
		<Client Name="IsInternalIF" Required="true" Internal="false" Comment="Set the place of the interface &#13;&#10;0 = Interface is an external device (for example from a MC-station)&#13;&#10;1 = Interface is an internal device (for example a HMI device)"/>
		<Client Name="IsMMCommIF" Required="true" Internal="false" Comment="Set the usage of the interface &#13;&#10;0 = Interface is used for local network (for exampe a company network)&#13;&#10;1 = Interface is used for MultiMaster (PLC) communication"/>
		<Client Name="MMisOnline" Required="true" Internal="false" Comment="Feedback &quot;MultiMaster Is Online&quot;&#13;&#10;This connection is necessary in case of an &quot;external&quot; &amp; &quot;not MultiMaster&quot; IF&#13;&#10;(IsInternalIF = 0 &amp; IsMMCommIF = 0).&#13;&#10;In that case connect this client to the server &quot;IsOnlineMM&quot; of the station object which is the MultiMaster-IF of this external control!&#13;&#10;"/>
		<Client Name="SigCLib" Required="false" Internal="false" Comment="Object channel to SigCLib (don&apos;t connect)"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\LoaderItf.h" Include="true"/>
			<File Path=".\Class\_IPConfigStation\_IPConfigStation_de.pdf"/>
			<File Path=".\Class\_IPConfigStation\_IPConfigStation_en.pdf"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="1.2" Date="2018-04-10" Author="FurLuk" Company="Sigmatek" Description="added Server for resetting via USB-Stick"/>
		<Dokumentation Revision="1.1" Date="2017-12-01" Author="KaiAnd" Company="Sigmatek GmbH" Description="clear the NewInst-Command in case of timeout or CmdRestoreSavedAddr()"/>
		<Dokumentation Revision="1.0" Date="2017-11-29" Author="KaiAnd" Company="Sigmatek GmbH" Description="Class created"/>
	</RevDoku>
	<Network Name="_IPConfigStation">
		<!-- List of Components in this network -->
		<Components>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
_IPConfigStation : CLASS
	TYPE
	  DirtyFlags : BDINT  //! <Type Public="true" Name="DirtyFlags"/>
	  [
	    1 IPaddress,
	    2 Subnet,
	    3 Gateway,
	    4 Bit4,
	    5 Bit5,
	    6 Bit6,
	    7 Bit7,
	    8 Bit8,
	    9 Bit9,
	    10 Bit10,
	    11 Bit11,
	    12 Bit12,
	    13 Bit13,
	    14 Bit14,
	    15 Bit15,
	    16 Bit16,
	    17 Bit17,
	    18 Bit18,
	    19 Bit19,
	    20 Bit20,
	    21 Bit21,
	    22 Bit22,
	    23 Bit23,
	    24 Bit24,
	    25 Bit25,
	    26 Bit26,
	    27 Bit27,
	    28 Bit28,
	    29 Bit29,
	    30 Bit30,
	    31 Bit31,
	    32 Bit32,
	  ];
	  t_e_ApplyStepsStation :
	  (
	    IDLE,
	    START_APPLY,
	    WORK_APPLY_IF,
	    CHECK_APPLY_IF,
	    WAIT_APPLY_MM,
	    WORK_APPLY_MM,
	    CHECK_APPLY_MM,
	    APPLY_NOK_IF,
	    APPLY_NOK_MM,
	    WAIT_APPLY_OK,
	    WORK_APPLY_OK,
	    APPLY_OK_END
	  )$UDINT;
	  t_e_NET_MODE :  //! <Type Public="true" Name="t_e_NET_MODE"/>
	  (
	    undef,
	    InitDeviceIP,
	    DeviceIP,
	    SoftwareIP
	  )$UDINT;
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	IPAddress 	: SvrCh_HDINT;
	Subnet 	: SvrCh_HDINT;
	Gateway 	: SvrCh_HDINT;
	StationNr 	: SvrCh_DINT;
	StationNrMM 	: SvrCh_DINT;
	SavIPAddress 	: SvrCh_HDINT;
	SavSubnet 	: SvrCh_HDINT;
	SavGateway 	: SvrCh_HDINT;
	Timeout 	: SvrCh_DINT;
	TimeoutCnt 	: SvrCh_DINT;
	NetMode 	: SvrCh_t_e_NET_MODE_PTofCls__IPConfigStation;
	IsOnlineMM 	: SvrCh_DINT;
	InputDirty 	: SvrCh_DirtyFlags_PTofCls__IPConfigStation;
	LastError 	: SvrCh_DINT;
	ExtResetCmd 	: SvrCh_DINT;
  //Clients:
	_IPConfigMain 	: CltChCmd__IPConfigMain;
	_IPConfigIF 	: CltChCmd_DINT;
	IsInternalIF 	: CltCh_DINT;
	IsMMCommIF 	: CltCh_DINT;
	MMisOnline 	: CltCh_DINT;
	_IP 	: CltChCmd__IP;
	SigCLib 	: CltChCmd_SigCLib;
  //Variables:
		InitDone 	: BOOL;
		TimeStampHmsImp 	: UDINT;
		TimeStampSecImp 	: UDINT;
		hmsImp 	: DINT;
		secImp 	: DINT;
		InitIF_Command 	: DINT;
		InitIF_Status 	: DINT;
		InitIF_HmsWait 	: DINT;
		InitMM_Command 	: DINT;
		InitMM_Status 	: DINT;
		InitMM_HmsWait 	: DINT;
		NiCommand 	: INT;
		NiGet 	: results;
		NiGive 	: CmdStruct;
		NiRetCode 	: DINT;
		NiCmdHmsWait 	: DINT;
		NiWaitsForMM 	: DINT;
		ApplyStep 	: t_e_ApplyStepsStation;
		ApplyHmsWait 	: DINT;
		ApplyStatus 	: DINT;
		tmpTxt : ARRAY [0..79] OF CHAR;

  //Functions:
				//! <Function Comment="INIT" Name="Init"/>
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="background task" Name="Background"/>
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="subroutine for the INIT interface" Name="workInitIF"/>
	FUNCTION workInitIF;
				//! <Function Comment="subroutine for the INIT MultiMaster" Name="workInitMM"/>
	FUNCTION workInitMM;
				//! <Function Comment="subroutine for working with the NewInst() to the IPConfigIF" Name="workNewInst"/>
	FUNCTION workNewInst;
				//! <Function Comment="subroutine: work the state machine for &quot;Apply settings&quot;" Name="workApplySettings"/>
	FUNCTION workApplySettings;
				//! <Function Comment="Copy the saved settings (IPs from the saved-vars) to the IO-Vars" Name="CopySavedToIO"/>
	FUNCTION CopySavedToIO;
				//! <Function Comment="get interface configuration via IF-object" Name="GetConfigIF"/>
	FUNCTION GetConfigIF
		VAR_INPUT
			mode 	: UINT;			//! <Variable Comment="Mode 1: Get Interface Config from autoexec&#13;&#10;Mode 2:  Command  2: Get Interface Config from OS&#13;&#10;" Name="GetConfigIF.mode"/>
		END_VAR
		VAR_OUTPUT
			retval 	: DINT;			//! <Variable Comment="  0 = NewInst() is BUSY&#13;&#10;  1 = NewInst() command started&#13;&#10;-1 = wrong parameter" Name="GetConfigIF.retval"/>
		END_VAR;
				//! <Function Comment="set interface configuration via IF-object" Name="SetConfigIF"/>
	FUNCTION SetConfigIF
		VAR_INPUT
			mode 	: UINT;			//! <Variable Comment="mode 1: Set Interface Config to autoexec&#13;&#10;mode 2: Set Interface Config to OS&#13;&#10;mode 3: Set Interface Config to autoexec and OS&#13;&#10;" Name="SetConfigIF.mode"/>
		END_VAR
		VAR_OUTPUT
			retval 	: DINT;			//! <Variable Comment="  0 = NewInst() is BUSY&#13;&#10;  1 = NewInst() command started&#13;&#10;-1 = wrong parameter" Name="SetConfigIF.retval"/>
		END_VAR;
				//! <Function Comment="returns the actual station settings (IPs from the saved-vars)" Name="GetSavedSettings"/>
	FUNCTION GLOBAL GetSavedSettings
		VAR_INPUT
			pIsInternalIF 	: ^DINT;			//! <Variable Comment="pointer to the return value for &quot;IsInternalIF&quot;" Name="GetSavedSettings.pIsInternalIF"/>
			pIsMMCommIF 	: ^DINT;			//! <Variable Comment="pointer to the return value for &quot;IsMMCommIF&quot;" Name="GetSavedSettings.pIsMMCommIF"/>
			pIP 	: ^HDINT;			//! <Variable Comment="pointer to the return value for IP address" Name="GetSavedSettings.pIP"/>
			pSubnet 	: ^HDINT;			//! <Variable Comment="pointer to the return value for subnet" Name="GetSavedSettings.pSubnet"/>
			pGateway 	: ^HDINT;			//! <Variable Comment="pointer to the return value for gateway" Name="GetSavedSettings.pGateway"/>
			pStationNr 	: ^DINT;			//! <Variable Comment="pointer to the return value for station number" Name="GetSavedSettings.pStationNr"/>
			pStationNrMM 	: ^DINT;			//! <Variable Comment="pointer to the return value for MultiMaster station number" Name="GetSavedSettings.pStationNrMM"/>
			pNetMode 	: ^t_e_NET_MODE;			//! <Variable Comment="pointer to the return value for net mode" Name="GetSavedSettings.pNetMode"/>
		END_VAR
		VAR_OUTPUT
			retval 	: DINT;			//! <Variable Comment="return value&#13;&#10;0 = OK / -1 = Error" Name="GetSavedSettings.retval"/>
		END_VAR;
				//! <Function Comment="returns the actual station settings (IPs from the I/O-vars)" Name="GetIOSettings"/>
	FUNCTION GLOBAL GetIOSettings
		VAR_INPUT
			pIsInternalIF 	: ^DINT;			//! <Variable Comment="pointer to the return value for &quot;IsInternalIF&quot;" Name="GetIOSettings.pIsInternalIF"/>
			pIsMMCommIF 	: ^DINT;			//! <Variable Comment="pointer to the return value for &quot;IsMMCommIF&quot;" Name="GetIOSettings.pIsMMCommIF"/>
			pIP 	: ^HDINT;			//! <Variable Comment="pointer to the return value for IP address" Name="GetIOSettings.pIP"/>
			pSubnet 	: ^HDINT;			//! <Variable Comment="pointer to the return value for subnet" Name="GetIOSettings.pSubnet"/>
			pGateway 	: ^HDINT;			//! <Variable Comment="pointer to the return value for gateway" Name="GetIOSettings.pGateway"/>
			pStationNr 	: ^DINT;			//! <Variable Comment="pointer to the return value for station number" Name="GetIOSettings.pStationNr"/>
			pStationNrMM 	: ^DINT;			//! <Variable Comment="pointer to the return value for MultiMaster station number" Name="GetIOSettings.pStationNrMM"/>
			pNetMode 	: ^t_e_NET_MODE;			//! <Variable Comment="pointer to the return value for net mode" Name="GetIOSettings.pNetMode"/>
		END_VAR
		VAR_OUTPUT
			retval 	: DINT;			//! <Variable Comment="return value&#13;&#10;0 = OK / -1 = Error" Name="GetIOSettings.retval"/>
		END_VAR;
				//! <Function Comment="sets the server StationNr to the value of the input" Name="SetStationNr"/>
	FUNCTION GLOBAL SetStationNr
		VAR_INPUT
			StationNumber 	: DINT;			//! <Variable Comment="new station number" Name="SetStationNr.StationNumber"/>
		END_VAR;
				//! <Function Comment="sets the server MulitiMaster StationNr to the value of the input" Name="SetStationNrMM"/>
	FUNCTION GLOBAL SetStationNrMM
		VAR_INPUT
			StationNumberMM 	: DINT;			//! <Variable Comment="new MultiMaster station number" Name="SetStationNrMM.StationNumberMM"/>
		END_VAR;
				//! <Function Comment="do the INIT for interface" Name="CmdInitIF"/>
	FUNCTION GLOBAL CmdInitIF
		VAR_INPUT
			HmsDelay 	: DINT;			//! <Variable Comment="Delay in 100 msec" Name="CmdInitIF.HmsDelay"/>
		END_VAR;
				//! <Function Comment="do the INIT for MultiMaster" Name="CmdInitMM"/>
	FUNCTION GLOBAL CmdInitMM
		VAR_INPUT
			HmsDelay 	: DINT;			//! <Variable Comment="Delay in 100 msec" Name="CmdInitMM.HmsDelay"/>
		END_VAR;
				//! <Function Comment="Apply the IO settings for interface" Name="CmdApplySettingsIF"/>
	FUNCTION GLOBAL CmdApplySettingsIF
		VAR_INPUT
			HmsDelay 	: DINT;			//! <Variable Comment="Delay in 100 msec" Name="CmdApplySettingsIF.HmsDelay"/>
		END_VAR;
				//! <Function Comment="Apply the IO settings for MultiMaster" Name="CmdApplySettingsMM"/>
	FUNCTION GLOBAL CmdApplySettingsMM
		VAR_INPUT
			HmsDelay 	: DINT;			//! <Variable Comment="Delay in 100 msec" Name="CmdApplySettingsMM.HmsDelay"/>
		END_VAR;
				//! <Function Comment="send Apply OK to IF object" Name="CmdApplyOK"/>
	FUNCTION GLOBAL CmdApplyOK
		VAR_INPUT
			HmsDelay 	: DINT;			//! <Variable Comment="Delay in 100 msec" Name="CmdApplyOK.HmsDelay"/>
		END_VAR;
				//! <Function Comment="returns the actual status of the &quot;INIT Interface&quot; procedure" Name="GetInitStatusIF"/>
	FUNCTION GLOBAL GetInitStatusIF
		VAR_OUTPUT
			retval 	: DINT;			//! <Variable Comment="actual status of the &quot;INIT Interface&quot; procedure&#13;&#10;  0 ... BUSY, still working&#13;&#10;  1 ... OK, done &#13;&#10;-1 ... NOT OK, Error&#13;&#10;" Name="GetInitStatusIF.retval"/>
		END_VAR;
				//! <Function Comment="returns the actual status of the &quot;INIT Multimaster&quot; procedure" Name="GetInitStatusMM"/>
	FUNCTION GLOBAL GetInitStatusMM
		VAR_OUTPUT
			retval 	: DINT;			//! <Variable Comment="actual status of the &quot;INIT MultiMaster&quot; procedure&#13;&#10;  0 ... BUSY, still working&#13;&#10;  1 ... OK, done &#13;&#10;-1 ... NOT OK, Error&#13;&#10;" Name="GetInitStatusMM.retval"/>
		END_VAR;
				//! <Function Comment="returns the actual status of the &quot;Apply settings&quot; procedure" Name="GetApplyStatus"/>
	FUNCTION GLOBAL GetApplyStatus
		VAR_OUTPUT
			retval 	: DINT;			//! <Variable Comment="actual status of the &quot;Apply settings&quot; procedure&#13;&#10;  0 ... BUSY, still working&#13;&#10;  1 ... OK, done &#13;&#10;-1 ... NOT OK, Error&#13;&#10;" Name="GetApplyStatus.retval"/>
		END_VAR;
				//! <Function Comment="Reset station to the saved settings (IPs from the saved-vars) and set them via ConfigIF" Name="CmdRestoreSavedAddr"/>
	FUNCTION GLOBAL CmdRestoreSavedAddr;
				//! <Function Comment="save actual station settings (IPs from the I/O-vars) to the saved-vars" Name="SaveIOSettings"/>
	FUNCTION GLOBAL SaveIOSettings;
				//! <Function Comment="used for setting the server &quot;NetMode&quot; from extern" Name="SetNetMode"/>
	FUNCTION GLOBAL SetNetMode
		VAR_INPUT
			NewNetMode 	: t_e_NET_MODE;			//! <Variable Comment="new NetMode" Name="SetNetMode.NewNetMode"/>
		END_VAR;
				//! <Function Comment="reset interface configuration via IF-object" Name="ResetConfigIF"/>
	FUNCTION ResetConfigIF
		VAR_INPUT
			mode 	: DINT;			//! <Variable Comment="mode 1: reset Interface Config to autoexec&#13;&#10;mode 2: reset Interface Config to OS&#13;&#10;mode 3: reset Interface Config to autoexec and OS&#13;&#10;" Name="ResetConfigIF.mode"/>
		END_VAR
		VAR_OUTPUT
			retval 	: DINT;			//! <Variable Comment="  0 = NewInst() is BUSY&#13;&#10;  1 = NewInst() command started&#13;&#10;-1 = wrong parameter" Name="ResetConfigIF.retval"/>
		END_VAR;
				//! <Function Comment="send OK info to IF-object" Name="SendOKConfigIF"/>
	FUNCTION SendOKConfigIF
		VAR_OUTPUT
			retval 	: DINT;			//! <Variable Comment="  0 = NewInst() is BUSY&#13;&#10;  1 = NewInst() command started&#13;&#10;-1 = wrong parameter" Name="SendOKConfigIF.retval"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL InputDirty::Write
		VAR_INPUT
			input (EAX) 	: _IPConfigStation::DirtyFlags;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: _IPConfigStation::DirtyFlags;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ExtResetCmd::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _IP
#pragma usingLtd _IPConfigMain
#pragma usingLtd SigCLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _IPConfigStation::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__IPCONFIGSTATION
1$UINT, 2$UINT, (SIZEOF(::_IPConfigStation))$UINT, 
16$UINT, 7$UINT, 0$UINT, 
TO_UDINT(148468755), "_IPConfigStation", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_IPConfigStation.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::_IPConfigStation.IPAddress.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1853430993), "IPAddress", 
(::_IPConfigStation.Subnet.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1631225232), "Subnet", 
(::_IPConfigStation.Gateway.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(733684581), "Gateway", 
(::_IPConfigStation.StationNr.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(248914119), "StationNr", 
(::_IPConfigStation.StationNrMM.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(3015078157), "StationNrMM", 
(::_IPConfigStation.SavIPAddress.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(462190284), "SavIPAddress", 
(::_IPConfigStation.SavSubnet.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(3625735120), "SavSubnet", 
(::_IPConfigStation.SavGateway.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(1574847523), "SavGateway", 
(::_IPConfigStation.Timeout.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(3187968904), "Timeout", 
(::_IPConfigStation.TimeoutCnt.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(3210597106), "TimeoutCnt", 
(::_IPConfigStation.NetMode.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(2605012621), "NetMode", 
(::_IPConfigStation.IsOnlineMM.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1126857637), "IsOnlineMM", 
(::_IPConfigStation.InputDirty.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3432415582), "InputDirty", 
(::_IPConfigStation.LastError.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3524335321), "LastError", 
(::_IPConfigStation.ExtResetCmd.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1342819887), "ExtResetCmd", 
//Clients:
(::_IPConfigStation._IPConfigMain.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(4058854491), "_IPConfigMain", TO_UDINT(4058854491), "_IPConfigMain", 1$UINT, 2$UINT, 
(::_IPConfigStation._IPConfigIF.pCh)$UINT, _CH_CLT_CMD$UINT, 2#0000000000000010$UINT, TO_UDINT(1245802338), "_IPConfigIF", 
(::_IPConfigStation.IsInternalIF.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3326785527), "IsInternalIF", 
(::_IPConfigStation.IsMMCommIF.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2716451818), "IsMMCommIF", 
(::_IPConfigStation.MMisOnline.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1559556629), "MMisOnline", 
(::_IPConfigStation._IP.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3530626343), "_IP", TO_UDINT(3530626343), "_IP", 1$UINT, 8$UINT, 
(::_IPConfigStation.SigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(77440046), "SigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 23$UINT, 
END_FUNCTION


#define USER_CNT__IPConfigStation 1

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__IPConfigStation] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _IPConfigStation::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT__IPConfigStation, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	IPAddress.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF IPAddress.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Subnet.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Subnet.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Gateway.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Gateway.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	StationNr.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF StationNr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	StationNrMM.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF StationNrMM.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SavIPAddress.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF SavIPAddress.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SavSubnet.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF SavSubnet.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SavGateway.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF SavGateway.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Timeout.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Timeout.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	TimeoutCnt.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF TimeoutCnt.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	NetMode.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF NetMode.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	InputDirty.pMeth			:= StoreMethod( #M_RD_DIRECT(), #InputDirty::Write() );
	IF InputDirty.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ExtResetCmd.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ExtResetCmd::Write() );
	IF ExtResetCmd.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL _IPConfigStation::Init

  if (InitDone = FALSE) then
  
    InitDone := TRUE;

    //=======================================================================================================
    // Register this station in the main class
    //-------------------------------------------------------------------------------------------------------
    _IPConfigMain.RegisterStation(pStation:=this$^void);


    //=======================================================================================================
    // initialize the MultiMaster station number
    //-------------------------------------------------------------------------------------------------------
    // later the value can only be determined in case of an external IF which is also a MultiMaster IF
    if ((IsInternalIF = 1) | (IsMMCommIF = 0)) then
      StationNrMM.Write(-1);    // -1 = no MultiMaster station number
    end_if;

    //=======================================================================================================

  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _IPConfigStation::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

	VAR
    Ret     : DINT;
    myDirty : DirtyFlags;
	END_VAR

	state := READY;

  //===================================================================================================================
  // generate the time impulse
  //-------------------------------------------------------------------------------------------------------------------
	hmsImp := 0;
  if ((ops.tAbsolute - TimeStampHmsImp) >= 100) then
    TimeStampHmsImp := ops.tAbsolute;
	  hmsImp := 1;
  end_if;  

	secImp := 0;
  if ((ops.tAbsolute - TimeStampSecImp) >= 1000) then
    TimeStampSecImp := ops.tAbsolute;
	  secImp := 1;
  end_if;  


  //===================================================================================================================
  // read class clients
  //-------------------------------------------------------------------------------------------------------------------
  MMisOnline := MMisOnline.Read();


  //===================================================================================================================
  // get the isOnlineMM status
  //-------------------------------------------------------------------------------------------------------------------
  if ((secImp) & (StationNrMM <> -1)) then  // -1 = no MultiMaster station number
    Ret := LDR_MM_StatNrIsConnected(udStationId:=TO_UDINT(StationNrMM));
    if (Ret > 0) then
      IsOnlineMM := 1;
    else
      IsOnlineMM := 0;
    end_if;    
  end_if;


  //===================================================================================================================
  // generate the InputDirty
  //-------------------------------------------------------------------------------------------------------------------
  myDirty := 0;
  if (IPAddress <> SavIPAddress) then
    myDirty.IPaddress := 1;
  end_if;
  if (Subnet <> SavSubnet) then
    myDirty.Subnet := 1;
  end_if;
  if (Gateway <> SavGateway) then
    myDirty.Gateway := 1;
  end_if;
  InputDirty := myDirty;


  //===================================================================================================================
  //  work the INITs
  //-------------------------------------------------------------------------------------------------------------------
  workInitIF();
  workInitMM();


  //===================================================================================================================
  // work the NewInst commands to the _IPConfigIF object
  // ... This needs a cyclic call because the _IPConfigIF object could be connected via MultiMaster and in that case
  //     the NewInst() will need more than one cycle
  //-------------------------------------------------------------------------------------------------------------------
  workNewInst();


  //===================================================================================================================
  //  work the state machine for "Apply settings"
  //-------------------------------------------------------------------------------------------------------------------
  workApplySettings();


  //===================================================================================================================

END_FUNCTION


FUNCTION GLOBAL _IPConfigStation::GetSavedSettings
	VAR_INPUT
		pIsInternalIF 	: ^DINT;
		pIsMMCommIF 	: ^DINT;
		pIP 	: ^HDINT;
		pSubnet 	: ^HDINT;
		pGateway 	: ^HDINT;
		pStationNr 	: ^DINT;
		pStationNrMM 	: ^DINT;
		pNetMode 	: ^t_e_NET_MODE;
	END_VAR
	VAR_OUTPUT
		retval 	: DINT;
	END_VAR

  retval := 0;
  
  if (pIsInternalIF <> NIL) then
		IsInternalIF   := IsInternalIF.Read();
		pIsInternalIF^ := IsInternalIF;     // type of IF
  else
    retval := -1;
  end_if;

  if (pIsMMCommIF <> NIL) then
		IsMMCommIF   := IsMMCommIF.Read();
		pIsMMCommIF^ := IsMMCommIF;         // type of IF
  else
    retval := -1;
  end_if;

  if (pIP <> NIL) then
    pIP^:= SavIPAddress;            // IP address
  else
    retval := -1;
  end_if;

  if (pSubnet <> NIL) then
    pSubnet^:= SavSubnet;           // Subnet mask
  else
    retval := -1;
  end_if;

  if (pGateway <> NIL) then
    pGateway^ := SavGateway;        // Gateway
  else
    retval := -1;
  end_if;

  if (pStationNr <> NIL) then
		pStationNr^ := StationNr;       // Station-number
  else
    retval := -1;
  end_if;

  if (pStationNrMM <> NIL) then
		pStationNrMM^ := StationNrMM;   // MultiMaster station-number
  else
    retval := -1;
  end_if;

  if (pNetMode <> NIL) then
		pNetMode^ := NetMode;           // NetMode
  else
    retval := -1;
  end_if;

END_FUNCTION


FUNCTION GLOBAL _IPConfigStation::GetIOSettings
	VAR_INPUT
		pIsInternalIF 	: ^DINT;
		pIsMMCommIF 	: ^DINT;
		pIP 	: ^HDINT;
		pSubnet 	: ^HDINT;
		pGateway 	: ^HDINT;
		pStationNr 	: ^DINT;
		pStationNrMM 	: ^DINT;
		pNetMode 	: ^t_e_NET_MODE;
	END_VAR
	VAR_OUTPUT
		retval 	: DINT;
	END_VAR

  retval := 0;
  
  if (pIsInternalIF <> NIL) then
		IsInternalIF   := IsInternalIF.Read();
		pIsInternalIF^ := IsInternalIF;     // type of IF
  else
    retval := -1;
  end_if;

  if (pIsMMCommIF <> NIL) then
		IsMMCommIF   := IsMMCommIF.Read();
		pIsMMCommIF^ := IsMMCommIF;         // type of IF
  else
    retval := -1;
  end_if;

  if (pIP <> NIL) then
    pIP^ := IPAddress;
  else
    retval := -1;
  end_if;

  if (pSubnet <> NIL) then
    pSubnet^ := Subnet;
  else
    retval := -1;
  end_if;

  if (pGateway <> NIL) then
    pGateway^ := Gateway;
  else
    retval := -1;
  end_if;

  if (pStationNr <> NIL) then
		pStationNr^ := StationNr;       // Station-number
  else
    retval := -1;
  end_if;

  if (pStationNrMM <> NIL) then
		pStationNrMM^ := StationNrMM;   // MultiMaster station-number
  else
    retval := -1;
  end_if;

  if (pNetMode <> NIL) then
		pNetMode^ := NetMode;           // NetMode
  else
    retval := -1;
  end_if;

END_FUNCTION


FUNCTION GLOBAL _IPConfigStation::SetStationNr
	VAR_INPUT
		StationNumber 	: DINT;
	END_VAR

  StationNr.Write(StationNumber);

END_FUNCTION


FUNCTION GLOBAL _IPConfigStation::SetStationNrMM
	VAR_INPUT
		StationNumberMM 	: DINT;
	END_VAR

  StationNrMM.Write(StationNumberMM);

END_FUNCTION


FUNCTION GLOBAL _IPConfigStation::CmdInitIF
	VAR_INPUT
		HmsDelay 	: DINT;
	END_VAR

  InitIF_Command := 1;       // command
  InitIF_Status  := 0;
  InitIF_HmsWait := HmsDelay;

END_FUNCTION


FUNCTION GLOBAL _IPConfigStation::CmdInitMM
	VAR_INPUT
		HmsDelay 	: DINT;
	END_VAR

  InitMM_Command := 1;       // command
  InitMM_Status  := 0;
  InitMM_HmsWait := HmsDelay;

END_FUNCTION


FUNCTION GLOBAL _IPConfigStation::CmdApplySettingsIF
	VAR_INPUT
		HmsDelay 	: DINT;
	END_VAR

  ApplyStep := START_APPLY;       // start-step of the state machine
  ApplyStatus := 0;
  ApplyHmsWait := HmsDelay;

END_FUNCTION


FUNCTION GLOBAL _IPConfigStation::CmdApplySettingsMM
	VAR_INPUT
		HmsDelay 	: DINT;
	END_VAR

  ApplyStep := WORK_APPLY_MM;       // start-step MultiMaster of the state machine
  ApplyStatus := 0;
  ApplyHmsWait := HmsDelay;

END_FUNCTION


FUNCTION GLOBAL _IPConfigStation::CmdApplyOK
	VAR_INPUT
		HmsDelay 	: DINT;
	END_VAR

  ApplyStep := WORK_APPLY_OK;       // start-step Apply OK of the state machine
  ApplyStatus := 0;
  ApplyHmsWait := HmsDelay;

END_FUNCTION


FUNCTION GLOBAL _IPConfigStation::GetInitStatusIF
	VAR_OUTPUT
		retval 	: DINT;
	END_VAR

  retval := InitIF_Status;

END_FUNCTION


FUNCTION GLOBAL _IPConfigStation::GetInitStatusMM
	VAR_OUTPUT
		retval 	: DINT;
	END_VAR

  retval := InitMM_Status;

END_FUNCTION


FUNCTION GLOBAL _IPConfigStation::GetApplyStatus
	VAR_OUTPUT
		retval 	: DINT;
	END_VAR

  retval := ApplyStatus;

END_FUNCTION


FUNCTION GLOBAL _IPConfigStation::SaveIOSettings
  
  SavIPAddress.Write(IPAddress);  // IP address
  SavSubnet.Write(Subnet);        // Subnet mask
  SavGateway.Write(Gateway);      // Gateway
  
END_FUNCTION


FUNCTION GLOBAL _IPConfigStation::CmdRestoreSavedAddr

  ApplyHmsWait := 0;
  ApplyStep := APPLY_NOK_IF;     // NOK-step of the state machine
  ApplyStatus := 0;
  NiCommand := 0;

END_FUNCTION


FUNCTION GLOBAL _IPConfigStation::SetNetMode
	VAR_INPUT
		NewNetMode 	: t_e_NET_MODE;
	END_VAR

  NetMode.Write(NewNetMode);

END_FUNCTION


FUNCTION _IPConfigStation::workInitIF

  if (InitIF_Command = 1) then

    InitIF_HmsWait -= hmsImp;
    if (InitIF_HmsWait < 0) then
      InitIF_HmsWait := 0;

      InitIF_Command := 0;  // clear the command

      //=======================================================================================================
      // GET or SET IP addresses depending on the NetMode
      //=======================================================================================================

      //---------------------------------------------------------------------------------------------------
      //  Case A: Station is NOT in NetMode "Software-IP" ... GET the IF-data from the _IPConfigIF object
      //---------------------------------------------------------------------------------------------------
      if (NetMode <> SoftwareIP) then
      
        InitIF_Status := 0; // the status will be set in the NewInst-GetState!!

        NetMode.Write(InitDeviceIP);
        GetConfigIF(2);     // 2 = get the Interface-Data from OS

        //-----------------------------------------------------------------------------------------------
        // max. time delay for NewInst() call (will be automatically reduced if MultiMaster gets online)
        // - only if station is an external IF
        //-----------------------------------------------------------------------------------------------
        if (IsInternalIF = 0) then
          NiWaitsForMM := 1;
          NiCmdHmsWait := 1200;  // max.Delay
        else
          NiWaitsForMM := 0;
          NiCmdHmsWait := 0;
        end_if;

      //---------------------------------------------------------------------------------------------------
      //  Case B: Station IS in NetMode "Software-IP" ... copy the saved data to the IO data
      //---------------------------------------------------------------------------------------------------
      else

        CopySavedToIO();    // copy the saved IP addresses to the IO vars

        InitIF_Status := 1; // InitIF done

      end_if;

      //=======================================================================================================
    end_if;

  end_if;

END_FUNCTION


FUNCTION _IPConfigStation::workInitMM

	VAR
    tmpIP   : HDINT;
		x 	    : DINT;
  END_VAR

  if (InitMM_Command = 1) then

    InitMM_HmsWait -= hmsImp;
    if (InitMM_HmsWait < 0) then
      InitMM_HmsWait := 0;

      InitMM_Command := 0;  // clear the command

      //=======================================================================================================
      // GET or SET IP addresses depending on the NetMode
      //=======================================================================================================

      //---------------------------------------------------------------------------------------------------
      //  Case A: Station is NOT in NetMode "Software-IP" ... set the MM-station-number
      //---------------------------------------------------------------------------------------------------
      if (NetMode <> SoftwareIP) then
      
        //-----------------------------------------------------------------------------------------------
        // the MultiMaster settings have still the actual settings! 
        // --> Search in the MultiMaster settings for the IP of the station and set the MM-station-number
        //     of the station to the value of the MM-settings
        //-----------------------------------------------------------------------------------------------
        if (IsMMCommIF = 1) then      // only if station is used for MultiMaster communication
          for x:=0 to (255 -1) do     // loop MultiMaster stations

            tmpTxt[0] := 0;
            LDR_MM_StatNrConnGetStr(udStationId:=TO_UDINT(x), pszConn:=#tmpTxt[0]);
            if (tmpTxt[0] = 'T') then   // returned IP-String starts with "TCPIP:"
              _IP.ConvertStrToBin(strAddress:=#tmpTxt[6], pIPAddress:=#tmpIP$UDINT);  // convert IP address

              if (tmpIP = SavIPAddress) then    // is the MultiMaster-IP the the Station-IP?
                SetStationNrMM(StationNumberMM:=x);
                exit;
              end_if;

            end_if;

          end_for;
        end_if;

        InitMM_Status := 1; // InitMM done

      //---------------------------------------------------------------------------------------------------
      //  Case B: Station IS in NetMode "Software-IP" ... set the MultiMaster settings
      //---------------------------------------------------------------------------------------------------
      else

        CopySavedToIO();    // copy the saved IP addresses to the IO vars

        //-----------------------------------------------------------------------------------------------
        // overwrite the MultiMaster-Settings
        // - only if station is an external IF and used for MultiMaster
        //-----------------------------------------------------------------------------------------------
        if ((IsInternalIF = 0) & (IsMMCommIF = 1)) then
          SigCLib.StrCpy(dst0:=#tmpTxt[0], src0:="TCPIP:");   // needed Prefix
          _IP.ConvertBinToStr(strAddress:=#tmpTxt[6], strAddressLen:=sizeof(tmpTxt)-6, TO_UDINT(IPAddress));
          LDR_MM_StatNrConnSetStr(udStationId:=TO_UINT(StationNrMM), pszConn:=#tmpTxt[0]);
        end_if;

        InitMM_Status := 1; // InitMM done

      end_if;

      //=======================================================================================================
    end_if;

  end_if;

END_FUNCTION


FUNCTION _IPConfigStation::workNewInst

  //===================================================================================================================
  // work the NewInst commands to the _IPConfigIF object
  //------------------------------------------------------------------------------------------------------------------
  // This needs a cyclic call because the _IPConfigIF object could be connected via MultiMaster and in that case
  // the NewInst() will need more than one cycle.
  // If the NewInst() call returns "BUSY" we have to call GetState() so often until it returns not "BUSY".
  //===================================================================================================================

  VAR
		NiRet 	  : IprStates;
  END_VAR

  //===============================================================================================================
  // Command > 0 ... new Command x for NewInst()
  //===============================================================================================================
  if (NiCommand > 0) then
  
    //-----------------------------------------------------------------------------------------------------------
    //  if a NewInst-command is delayed because of needing the MultiMaster-Online status
    //-----------------------------------------------------------------------------------------------------------
    // if the own station gets online (the own class server)
    if ((NiWaitsForMM = 1) & (IsOnlineMM = 1)) then
      NiWaitsForMM := 0;
      NiCmdHmsWait := 5;  // reduce the delay
    end_if;

    // if the the other station of this control gets online (client connected to the server of other station)
    if ((NiWaitsForMM = 1) & (MMisOnline = 1)) then
      NiWaitsForMM := 0;
      NiCmdHmsWait := 10; // reduce the delay
    end_if;
    //-----------------------------------------------------------------------------------------------------------

    NiCmdHmsWait -= hmsImp;
    if (NiCmdHmsWait < 0) then
      NiCmdHmsWait := 0;

      NiGive.uiCmd := TO_UINT(NiCommand);    // set NewInst() command

      case (NiCommand) of

        //-------------------------------------------------------------------------------------------------------
        // Command  1: Get Interface Config from autoexec
        // Command  2: Get Interface Config from OS
        //-------------------------------------------------------------------------------------------------------
        1, 2:
          NiRet := _IPConfigIF.NewInst(#NiGive, #NiGet);  // call NewInst command
          NiCmdHmsWait := 0;
          NiCommand *= -1;                                // switch to GetState() calls

        //-------------------------------------------------------------------------------------------------------
        // Command 11: Set Interface Config autoexec
        // Command 12: Set Interface Config OS
        // Command 13: Set Interface Config autoexec and OS
        // Command 21: Reset Interface Config autoexec
        // Command 22: Reset Interface Config OS
        // Command 23: Reset Interface Config autoexec and OS
        //-------------------------------------------------------------------------------------------------------
        11, 12, 13, 21, 22, 23:
          NiGive.aPara[0]$UDINT := IPAddress;           // IP address
          NiGive.aPara[1]$UDINT := Subnet;              // Subnet mask
          NiGive.aPara[2]$UDINT := Gateway;             // Gateway
          NiGive.aPara[3]       := NiCmdIF_HmsWaitIF;   // Time Delay for command work [100 ms] within the IF object
          NiGive.aPara[4]       := Timeout;             // TimeOut

          NiRet := _IPConfigIF.NewInst(#NiGive, #NiGet);  // call NewInst command
          NiCmdHmsWait := 0;
          NiCommand *= -1;                                // switch to GetState() calls

        //-------------------------------------------------------------------------------------------------------
        // Command 99: send OK info to IF-object
        //-------------------------------------------------------------------------------------------------------
        99:
          NiRet := _IPConfigIF.NewInst(#NiGive, #NiGet);  // call NewInst command
          NiCommand *= -1;                                // switch to GetState() calls

          if ((NiRet <> BUSY) & (NiRet <> READY)) then

          end_if;


        //-------------------------------------------------------------------------------------------------------
        // Command unknown
        //-------------------------------------------------------------------------------------------------------
        else
          NiCommand := 0;

        //-------------------------------------------------------------------------------------------------------
      end_case;

    end_if;

  //===============================================================================================================
  // Command < 0 ... Command x is running - call GetState() so often until it returns not "BUSY"
  //===============================================================================================================
  elsif (NiCommand < 0) then

    NiCmdHmsWait -= hmsImp;
    if (NiCmdHmsWait < 0) then
      NiCmdHmsWait := 0;

      NiRet := _IPConfigIF.GetState(#NiGive, #NiGet);
    
      //---------------------------------------------------------------------------------------------------------
      if (NiRet = READY) then
      
        case (NiCommand) of

          //-------------------------------------------------------------------------------------------------------
          // Command  1: Get Interface Config from autoexec
          // Command  2: Get Interface Config from OS
          //-------------------------------------------------------------------------------------------------------
          -1, -2:

            SavIPAddress.Write(NiGet.aData[0]$UDINT);   // result I 000: IP address
            SavSubnet.Write(NiGet.aData[4]$UDINT);      // result I 004: Subnet mask
            SavGateway.Write(NiGet.aData[8]$UDINT);     // result I 008: Gateway
            CopySavedToIO();                            // copy saved addresses to I/O-addresses
            if (NetMode = InitDeviceIP) then
              NetMode.Write(DeviceIP);
            end_if;
            InitIF_Status := 1;                         // InitIF done

          //-------------------------------------------------------------------------------------------------------
          // Command 11: Set Interface Config autoexec
          // Command 12: Set Interface Config OS
          // Command 13: Set Interface Config autoexec and OS
          // Command 21: Reset Interface Config autoexec
          // Command 22: Reset Interface Config OS
          // Command 23: Reset Interface Config autoexec and OS
          //-------------------------------------------------------------------------------------------------------
          -11, -12, -13, -21, -22, -23:

            if (NiGet.aData[0]$DINT < 0) then           // I 000: return-value
              LastError := NiGet.aData[0]$DINT;         // Error: IPAPI_ERR_xx
              NiRetCode := LastError;
            end_if;

          //-------------------------------------------------------------------------------------------------------
          // Command 99: send OK info to IF-object
          //-------------------------------------------------------------------------------------------------------
          -99:
            NiRetCode := 0;   // no answer

        end_case;

      end_if;
      //---------------------------------------------------------------------------------------------------------
      if ((NiRet = ERROR) | (NiRet = ERROR_BUSY)) then
        LastError := -10000 + NiCommand;              // Error: NewInst returned "ERROR"
        NiRetCode := LastError;
        if ((NiCommand = -1) | (NiCommand = -2)) then
          InitIF_Status := -1;                        // Init not OK
        end_if;
        NiCommand := 0;                               // stop NewInst working (ready now for new commands)
      //---------------------------------------------------------------------------------------------------------
      elsif (NiRet <> BUSY) then
        NiCommand := 0;                               // stop NewInst working (ready now for new commands)
      end_if;
      //---------------------------------------------------------------------------------------------------------

    end_if;

  end_if;   // (NiCommand)
  //===============================================================================================================

END_FUNCTION


FUNCTION _IPConfigStation::workApplySettings
	VAR
		myRet     : DINT;
  END_VAR

  //=========================================================================================================
  // TimeOut of the state machine
  //=========================================================================================================
  if ((ApplyStep$UDINT > 0) & (ApplyStep <> APPLY_NOK_MM)) then

    TimeoutCnt.Write(TimeoutCnt - secImp);
    if (TimeoutCnt < 0) then
      TimeoutCnt := 0;    
      ApplyHmsWait := 0;
      ApplyStep := APPLY_NOK_IF;
      NiCommand := 0;
    end_if;

  end_if;

  //=========================================================================================================
  // state machine with different steps for procedure "Apply settings"
  //=========================================================================================================
  case (ApplyStep) of

  	//=======================================================================================================
    // IDLE ... no action
  	//-------------------------------------------------------------------------------------------------------
  	IDLE:

  	//=======================================================================================================
    // START_APPLY ... start the Apply procedure
  	//-------------------------------------------------------------------------------------------------------
  	START_APPLY:

      LastError   := 0;
      ApplyStatus := 0;             // INIT: Status = BUSY

      if (Timeout < 10) then
        Timeout.Write(10);
      end_if;

      TimeoutCnt := Timeout;        // INIT: raise the timeout
      NiRetCode := 0;               // clear the NewInst-RetCode

      ApplyHmsWait -= hmsImp;
      if (ApplyHmsWait <= 0) then
        ApplyHmsWait := 0;

        ApplyHmsWait := 0;
        ApplyStep := WORK_APPLY_IF;
      end_if;

  	//=======================================================================================================
    // WORK_APPLY_IF ... forward command to the ConfigIF object
  	//-------------------------------------------------------------------------------------------------------
  	WORK_APPLY_IF:

      ApplyHmsWait -= hmsImp;
      if (ApplyHmsWait <= 0) then
        ApplyHmsWait := 0;

        myRet := SetConfigIF(2);          // 2 = set the Interface-Data OS

        if (myRet = 1) then               // Ret 1 = NewInst() command ready and started
          ApplyHmsWait := NiCmdIF_HmsWaitIF +5;
          ApplyStep := CHECK_APPLY_IF;
        end_if;

      end_if;
  	
  	//=======================================================================================================
    // CHECK_APPLY_IF ... check for success ConfigIF object
  	//-------------------------------------------------------------------------------------------------------
  	CHECK_APPLY_IF:

      ApplyHmsWait -= hmsImp;
      if (ApplyHmsWait <= 0) then
        ApplyHmsWait := 0;

        if (NiCommand = 0) then     // has NewInst stopped?
          if (NiRetCode >= 0) then 
            ApplyHmsWait := 0;
            ApplyStep := WAIT_APPLY_MM;
          else
            ApplyHmsWait := 10;
            ApplyStep := APPLY_NOK_IF;
          end_if;
        end_if;

      end_if;

  	//=======================================================================================================
    // WAIT_APPLY_MM ... wait for command to overwrite the MultiMaster-Settings
  	//-------------------------------------------------------------------------------------------------------
  	WAIT_APPLY_MM:

      ApplyHmsWait -= hmsImp;
      if (ApplyHmsWait <= 0) then
        ApplyHmsWait := 0;

          ApplyStatus := 1;     // first apply procedure OK

      end_if;

    //=======================================================================================================
    // WORK_APPLY_MM ... overwrite the MultiMaster-Settings
  	//-------------------------------------------------------------------------------------------------------
  	WORK_APPLY_MM:

      ApplyHmsWait -= hmsImp;
      if (ApplyHmsWait <= 0) then
        ApplyHmsWait := 0;

        //-----------------------------------------------------------------------------------------------
        // overwrite the MultiMaster-Settings
        // - only if station is an external IF and used for MultiMaster
        //-----------------------------------------------------------------------------------------------
        if ((IsInternalIF = 0) & (IsMMCommIF = 1)) then
          SigCLib.StrCpy(dst0:=#tmpTxt[0], src0:="TCPIP:");   // needed Prefix
          _IP.ConvertBinToStr(strAddress:=#tmpTxt[6], strAddressLen:=sizeof(tmpTxt)-6, TO_UDINT(IPAddress));
          myRet := LDR_MM_StatNrConnSetStr(udStationId:=TO_UINT(StationNrMM), pszConn:=#tmpTxt[0]);

          if (myRet < 0) then
            ApplyHmsWait := 10;
            ApplyStep := APPLY_NOK_IF;
          else
            IsOnlineMM := 0;
            ApplyHmsWait := 10;
            ApplyStep := CHECK_APPLY_MM;
          end_if;

        //-----------------------------------------------------------------------------------------------
        // Don't overwrite the MultiMaster-Settings, but wait for MultiMaster IsOnline
        // - only if station is an external IF and is not used for MultiMaster
        //-----------------------------------------------------------------------------------------------
        elsif ((IsInternalIF = 0) & (IsMMCommIF = 0)) then
          ApplyHmsWait := 10;
          ApplyStep := CHECK_APPLY_MM;

        //-----------------------------------------------------------------------------------------------
        else
          ApplyHmsWait := 10;
          ApplyStep := WAIT_APPLY_OK;  // OK!!
        end_if;

      end_if;

  	//=======================================================================================================
    // CHECK_APPLY_MM ... check for success new MultiMaster-Settings
  	//-------------------------------------------------------------------------------------------------------
  	CHECK_APPLY_MM:

      ApplyHmsWait -= hmsImp;
      if (ApplyHmsWait <= 0) then
        ApplyHmsWait := 0;

        //-----------------------------------------------------------------------------------------------
        // if station is an external IF and used for MultiMaster
        //-----------------------------------------------------------------------------------------------
        if ((IsInternalIF = 0) & (IsMMCommIF = 1)) then
          if (IsOnlineMM = 1) then  // IsOnline Multimaster?
            ApplyHmsWait := 0;
            ApplyStep := WAIT_APPLY_OK;  // OK!!
          end_if;

        //-----------------------------------------------------------------------------------------------
        // if station is an external IF and is not used for MultiMaster
        //-----------------------------------------------------------------------------------------------
        elsif ((IsInternalIF = 0) & (IsMMCommIF = 0)) then
          if (MMIsOnline = 1) then  // Client IsOnline Multimaster?
            ApplyHmsWait := 0;
            ApplyStep := WAIT_APPLY_OK;  // OK!!
          end_if;

        //-----------------------------------------------------------------------------------------------
        else  // (that case is not really possible in this step ...)
          ApplyHmsWait := 0;
          ApplyStep := WAIT_APPLY_OK;  // OK!!

        end_if;
        //-----------------------------------------------------------------------------------------------

      end_if;

  	//=======================================================================================================
    // APPLY_NOK_IF ... Apply procedure was not OK -> reset IF to old settings
  	//-------------------------------------------------------------------------------------------------------
  	APPLY_NOK_IF:

      ApplyHmsWait -= hmsImp;
      if (ApplyHmsWait <= 0) then
        ApplyHmsWait := 0;

        ApplyStatus := -1;        // -1 = Status NOK
 
        CopySavedToIO();            // copy the saved IP addresses to the IO vars
        myRet := ResetConfigIF(2);  // 2 = reset the Interface-Data OS

        if (myRet = 1) then         // Ret 1 = NewInst() command ready and started
        
          ApplyHmsWait := NiCmdIF_HmsWaitIF +5;
          ApplyStep := APPLY_NOK_MM;
      
        end_if;

      end_if;

  	//=======================================================================================================
    // APPLY_NOK_MM ... Apply procedure was not OK -> reset Multimaster to old settings
  	//-------------------------------------------------------------------------------------------------------
  	APPLY_NOK_MM:

      ApplyHmsWait -= hmsImp;
      if (ApplyHmsWait <= 0) then
        ApplyHmsWait := 0;
        
        //-----------------------------------------------------------------------------------------------
        // reset the MultiMaster-Settings
        // - only if station is an external IF and used for MultiMaster
        //-----------------------------------------------------------------------------------------------
        if ((IsInternalIF = 0) & (IsMMCommIF = 1)) then
          SigCLib.StrCpy(dst0:=#tmpTxt[0], src0:="TCPIP:");   // needed Prefix
          _IP.ConvertBinToStr(strAddress:=#tmpTxt[6], strAddressLen:=sizeof(tmpTxt)-6, TO_UDINT(IPAddress));
          myRet := LDR_MM_StatNrConnSetStr(udStationId:=TO_UINT(StationNrMM), pszConn:=#tmpTxt[0]);
        end_if;
        //-----------------------------------------------------------------------------------------------

        ApplyStep := IDLE;

      end_if;

  	//=======================================================================================================
    // WAIT_APPLY_OK ... own Apply procedure was OK -> wait for command "global Apply OK"
  	//-------------------------------------------------------------------------------------------------------
  	WAIT_APPLY_OK:

      ApplyHmsWait -= hmsImp;
      if (ApplyHmsWait <= 0) then
        ApplyHmsWait := 0;

          ApplyStatus := 1;     // first apply procedure OK

      end_if;

  	//=======================================================================================================
    // WORK_APPLY_OK ... global Apply procedure was OK -> finish
  	//-------------------------------------------------------------------------------------------------------
  	WORK_APPLY_OK:

      ApplyHmsWait -= hmsImp;
      if (ApplyHmsWait <= 0) then
        ApplyHmsWait := 0;

        myRet := SendOKConfigIF();  // send OK-Info to the IPConfigIF object (so it will not run into it's own timeout!)  

        if (myRet = 1) then         // Ret 1 = NewInst() command ready and started

          ApplyHmsWait := 10;
          ApplyStep := APPLY_OK_END;

        end_if;

      end_if;

  	//=======================================================================================================
    // APPLY_OK_END ... Finish
  	//-------------------------------------------------------------------------------------------------------
  	APPLY_OK_END:

      ApplyHmsWait -= hmsImp;
      if (ApplyHmsWait <= 0) then
        ApplyHmsWait := 0;

        ApplyStatus := 1;         // 1 = Status OK
        ApplyStep := IDLE;

      end_if;

  	//=======================================================================================================
  end_case;

  //=========================================================================================================

END_FUNCTION


FUNCTION _IPConfigStation::CopySavedToIO
  
  IPAddress.Write(SavIPAddress);  // IP address
  Subnet.Write(SavSubnet);        // Subnet mask
  Gateway.Write(SavGateway);      // Gateway

END_FUNCTION


FUNCTION _IPConfigStation::GetConfigIF
	VAR_INPUT
		mode 	: UINT;
	END_VAR
	VAR_OUTPUT
		retval 	: DINT;
	END_VAR

  retval := 0;
  if ((mode >= 1) & (mode <=2)) then

    if (NiCommand = 0) then
      NiCommand := TO_INT(mode);   // set command for workNewInst()
      NiCmdHmsWait := 0;
      retval := 1;
    end_if;

  else
    retval := -1;
  end_if;

END_FUNCTION


FUNCTION _IPConfigStation::SetConfigIF
	VAR_INPUT
		mode 	: UINT;
	END_VAR
	VAR_OUTPUT
		retval 	: DINT;
	END_VAR

  retval := 0;
  if ((mode >= 1) & (mode <=3)) then

    if (NiCommand = 0) then
      NiCommand := 10 + TO_INT(mode);   // set command for workNewInst()
      NiCmdHmsWait := 0;
      retval := 1;
    end_if;

  else
    retval := -1;
  end_if;

END_FUNCTION


FUNCTION _IPConfigStation::ResetConfigIF
	VAR_INPUT
		mode 	: DINT;
	END_VAR
	VAR_OUTPUT
		retval 	: DINT;
	END_VAR

  retval := 0;
  if ((mode >= 1) & (mode <=3)) then

    if (NiCommand = 0) then
      NiCommand := 20 + TO_INT(mode);   // set command for workNewInst()
      NiCmdHmsWait := 0;
      retval := 1;
    end_if;

  else
    retval := -1;
  end_if;

END_FUNCTION


FUNCTION _IPConfigStation::SendOKConfigIF
	VAR_OUTPUT
		retval 	: DINT;
	END_VAR

  retval := 0;

  if (NiCommand = 0) then
    NiCommand := 99;        // set command for workNewInst()
      NiCmdHmsWait := 0;
    retval := 1;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _IPConfigStation::InputDirty::Write
	VAR_INPUT
		input (EAX) 	: _IPConfigStation::DirtyFlags;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: _IPConfigStation::DirtyFlags;
	END_VAR

	InputDirty := input;
	result := InputDirty;

  if (InputDirty = 0) then

    CopySavedToIO();    // reset the Inputs
  
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _IPConfigStation::ExtResetCmd::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	ExtResetCmd := input;
  
  if (ExtResetCmd = 1) then
    
    NetMode := NetMode.Write(input:=DeviceIP);
    
  end_if;
  
	result := ExtResetCmd;

END_FUNCTION
