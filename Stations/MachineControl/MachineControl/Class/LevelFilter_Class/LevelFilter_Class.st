//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "LevelFilter_Class"
	Revision           = "0.0"
	GUID               = "{D9415EC1-DFCE-4026-A61B-6B3F4DC10513}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(840,420)">
	<Channels>
		<Server Name="ChangeX_Y_S" GUID="{A8530723-A564-4043-87BB-B32B0BF6D116}" Visualized="true" Remotely="true" Initialize="true" DefValue="0" WriteProtected="false" Retentive="File"/>
		<Server Name="ClassSvr" GUID="{26C1BDCF-EEF5-48BA-84E8-FC333C809BC0}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="Invert_X_S" GUID="{82E35276-1546-4D30-B687-DF206E43D123}" Visualized="true" Remotely="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="Invert_y_S" GUID="{B0661EB7-6E9A-42A5-825D-DBC1DB67DE21}" Visualized="true" Remotely="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="X_Out_S" GUID="{A356C362-6CD7-4F45-B123-E0BC96795A09}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="Y_Out_S" GUID="{0A390DC4-60A0-4232-A85E-049B71800DB7}" Visualized="false" Initialize="true" WriteProtected="false" Retentive="false"/>
		<Client Name="X_IN_C" Required="true" Internal="false"/>
		<Client Name="Y_IN_C" Required="true" Internal="false"/>
	</Channels>
</Class>
*)
LevelFilter_Class : CLASS
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	X_Out_S 	: SvrCh_DINT;
	Y_Out_S 	: SvrCh_DINT;
	ChangeX_Y_S 	: SvrCh_DINT;
	Invert_X_S 	: SvrCh_DINT;
	Invert_y_S 	: SvrCh_DINT;
  //Clients:
	X_IN_C 	: CltCh_DINT;
	Y_IN_C 	: CltCh_DINT;
  //Variables:
		CounterVar 	: DINT;
		XVAR 	: DINT;
		YVAR 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB LevelFilter_Class::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_LEVELFILTER_CLASS
0$UINT, 0$UINT, (SIZEOF(::LevelFilter_Class))$UINT, 
6$UINT, 2$UINT, 0$UINT, 
TO_UDINT(912864977), "LevelFilter_Class", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::LevelFilter_Class.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::LevelFilter_Class.X_Out_S.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4060755261), "X_Out_S", 
(::LevelFilter_Class.Y_Out_S.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1417494153), "Y_Out_S", 
(::LevelFilter_Class.ChangeX_Y_S.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(3047576049), "ChangeX_Y_S", 
(::LevelFilter_Class.Invert_X_S.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(2690309576), "Invert_X_S", 
(::LevelFilter_Class.Invert_y_S.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(2711140351), "Invert_y_S", 
//Clients:
(::LevelFilter_Class.X_IN_C.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2779944431), "X_IN_C", 
(::LevelFilter_Class.Y_IN_C.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1861109322), "Y_IN_C", 
END_FUNCTION


#define USER_CNT_LevelFilter_Class 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_LevelFilter_Class] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION LevelFilter_Class::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_LevelFilter_Class, pCmd := #vmt.CmdTable);
	vmt.CmdTable.CyWork		:= #CyWork();
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	X_Out_S.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF X_Out_S.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Y_Out_S.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Y_Out_S.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ChangeX_Y_S.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ChangeX_Y_S.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Invert_X_S.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Invert_X_S.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Invert_y_S.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Invert_y_S.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL LevelFilter_Class::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
    
    
    
    //Einlesen
    X_IN_C      :=  X_IN_C.Read();
    
    Y_IN_C      :=  Y_IN_C.Read();
    
    ChangeX_Y_S :=  ChangeX_Y_S.Read();
    
    Invert_X_S  :=  Invert_X_S.Read();
    
    Invert_y_S  :=  Invert_y_S.Read();
     
     
    //Ergebnisse addieren für xx Clocks
    if CounterVar <50 then
      
       XVAR          +=  X_IN_C;
       YVAR          +=  Y_IN_C;
       CounterVar    +=  1;
     
     
    end_if;
    
    // Durchschnitt ausgeben
    
  if CounterVar >= 50  then
  
      
    if ChangeX_Y_S = 1 then
      
      X_Out_S     :=    X_Out_S.Write(input:=(YVAR/CounterVar * Invert_X_S));
      Y_Out_S     :=    Y_Out_S.Write(input:=(XVAR/CounterVar * Invert_Y_S));
      CounterVar  :=    0;
      XVAR        :=    0;
      YVAR        :=    0;
    
    ELSE

      X_Out_S     :=    X_Out_S.Write(input:=(XVAR/CounterVar * Invert_X_S));
      Y_Out_S     :=    Y_Out_S.Write(input:=(YVAR/CounterVar * Invert_y_S));
      CounterVar  :=    0;
      XVAR        :=    0;
      YVAR        :=    0;
      
    end_if;

 end_if;   


	state := READY;

END_FUNCTION
