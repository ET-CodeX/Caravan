//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "NetworkConfig"
	Revision           = "1.31"
	GUID               = "{C47A4F1B-D744-4F26-882F-1AF550460DCE}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "true"
	DefBackground      = "100 ms"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(510,420)"
	Comment            = "Class handles the Networkconfiguration for one Interface">
	<Channels>
		<Server Name="ClassSvr" GUID="{59A390F3-91B7-4B2D-A6E0-6468470AC799}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="GetConfig" GUID="{87A4A343-AFC5-45CE-853D-9B5CA0A54E53}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Call Write-Methode to get the actual IP-Configuration&#13;&#10;&#13;&#10;1..read from the autoexec.lsl&#13;&#10;2..read from the OS Interface"/>
		<Server Name="GWAddress" GUID="{EE2DDCE3-4FD5-4E3F-AF95-F1DBE3EB3B4E}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Network Configuration: Gateway-Address"/>
		<Server Name="IPAddress" GUID="{DA86FB94-E449-4814-B15F-2A7B43620705}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Network Configuration: IP-Address"/>
		<Server Name="SetConfig" GUID="{0ED76C1A-D93C-491F-B0FD-FFACFDFE9CE6}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Call Write-Methode to set the actual IP-Configuration&#13;&#10;&#13;&#10;1..write the configuration to the autoexec.lsl&#13;&#10;2..set configuration with the OS Interface&#13;&#10;3..write at first the configuration to the autoexec.lsl and afterwards change it with the OS Interface"/>
		<Server Name="SNMask" GUID="{17FF7BCD-F401-46C6-9904-236CE2A5B038}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Network Configuration: Subnet-Mask"/>
		<Client Name="coFileSys" Required="false" Internal="false" Comment="Objectchannel to class _FileSys"/>
		<Client Name="coIP" Required="false" Internal="false" Comment="Objectchannel to class _IP"/>
		<Client Name="coSigCLib" Required="false" Internal="false" Comment="Objectchannel to class SigCLib"/>
		<Client Name="coStdLib" Required="false" Internal="false" Comment="Objectchannel to class _StdLib"/>
		<Client Name="Interface" Required="true" Internal="false" Comment="Write the number of the IP Interface to this client!&#13;&#10;The given number will be changed.&#13;&#10;If the value is 0 the class looks for no interface number!"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="ObeChr"/>
		<Dokumentation Revision="1.31" Date="2015-07-09" Author="LeiChr&#13;&#10;FriHer" Company="Sigmatek" Description="- changed the setConfig and GetConfig to background&#13;&#10;- Interface numbers &gt;9 also work now"/>
		<Dokumentation Revision="1.30" Date="2013-10-01" Author="spimar" Company="Sigmatek" Description="Improvement: if ip adress is read from autoexec, the interface number is only necessary if it is greater 1"/>
		<Dokumentation Revision="1.20" Date="2013-07-12" Author="spimar" Company="Sigmatek" Description="- Changed call of method from SigCLib, because of compiler errror;&#13;&#10;- Removed not needed memset() for performance gain"/>
		<Dokumentation Revision="1.10" Date="2012-12-19" Author="SpiMar" Company="Sigmatek" Description="Bugfix: now the correct number of chars is set if there is no interface number given.&#13;&#10;Improvement: now a complete line is ignored if there is a rem in front of the line.&#13;&#10;Bugfix: now the handling of the Interface client is correct."/>
		<Dokumentation Revision="1.0" Date="2012-12-06" Author="ObeChr" Company="Sigmatek" Description="Initial Version"/>
	</RevDoku>
</Class>
*)
NetworkConfig : CLASS
	TYPE
	  e_GetOptions :  //! <Type Public="true" Name="e_GetOptions"/>
	  (
	    GET_IDLE,
	    GET_AUTOEXEC,
	    GET_OS
	  )$UDINT;
	  e_SetOptions :  //! <Type Public="true" Name="e_SetOptions"/>
	  (
	    SET_IDLE,
	    SET_AUTOEXEC,
	    SET_OS,
	    SET_BOTH
	  )$UDINT;
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	IPAddress 	: SvrCh_HDINT;
	SNMask 	: SvrCh_HDINT;
	GWAddress 	: SvrCh_HDINT;
	SetConfig 	: SvrCh_e_SetOptions_PTofCls_NetworkConfig;
	GetConfig 	: SvrCh_e_GetOptions_PTofCls_NetworkConfig;
  //Clients:
	Interface 	: CltCh_DINT;
	coFileSys 	: CltChCmd__FileSys;
	coStdLib 	: CltChCmd__StdLib;
	coSigCLib 	: CltChCmd_SigCLib;
	coIP 	: CltChCmd__IP;
  //Variables:
		udIPAddress 	: UDINT;			//! <Variable Comment="IP address" Name="udIPAddress"/>
		udSubnetMask 	: UDINT;			//! <Variable Comment="Subnet mask" Name="udSubnetMask"/>
		udGateway 	: UDINT;			//! <Variable Comment="Gateway" Name="udGateway"/>
		aIPAddress : ARRAY [0..19] OF CHAR;
			//! <Variable Comment="String IP Address" Name="aIPAddress"/>
		aSubnetMask : ARRAY [0..19] OF CHAR;
			//! <Variable Comment="String Subnet mask" Name="aSubnetMask"/>
		aGateway : ARRAY [0..19] OF CHAR;
			//! <Variable Comment="String Gateway" Name="aGateway"/>
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="Changes the ip informations in the autoexec.lsl" Name="ExchangeNumber"/>
	FUNCTION ExchangeNumber
		VAR_INPUT
			usType 	: USINT;			//! <Variable Comment="0..IP&#13;&#10;1..Subnet&#13;&#10;2..Gateway" Name="ExchangeNumber.usType"/>
			pBuffer 	: ^CHAR;			//! <Variable Comment="pointer to the buffer which contains the text of the autoexec.lsl" Name="ExchangeNumber.pBuffer"/>
			pPosition 	: ^UDINT;			//! <Variable Comment="position in the file" Name="ExchangeNumber.pPosition"/>
			pLength 	: ^DINT;			//! <Variable Comment="file length" Name="ExchangeNumber.pLength"/>
		END_VAR
		VAR_OUTPUT
			pNewBuffer 	: ^CHAR;			//! <Variable Comment="pointer to the new buffer (points behind the last ip setting)" Name="ExchangeNumber.pNewBuffer"/>
		END_VAR;
				//! <Function Comment="read out the file and parses the ip information" Name="GetIPAutoexec"/>
	FUNCTION GetIPAutoexec;
				//! <Function Comment="Check if the given character is a number" Name="IsNumber"/>
	FUNCTION IsNumber
		VAR_INPUT
			usCHAR 	: DINT;			//! <Variable Comment="the character" Name="IsNumber.usCHAR"/>
		END_VAR
		VAR_OUTPUT
			bNumber 	: DINT;			//! <Variable Comment="true = number&#13;&#10;false = other character" Name="IsNumber.bNumber"/>
		END_VAR;
				//! <Function Comment="This method parses the number" Name="ParseNumber"/>
	FUNCTION ParseNumber
		VAR_INPUT
			usType 	: USINT;			//! <Variable Comment="0 = IP&#13;&#10;1 = SUBNET&#13;&#10;2 = GATEWAY" Name="ParseNumber.usType"/>
			pBuffer 	: ^CHAR;			//! <Variable Comment="pointer to the buffer which contains the text of the autoexec.lsl" Name="ParseNumber.pBuffer"/>
			udLength 	: UDINT;			//! <Variable Comment="len of the file" Name="ParseNumber.udLength"/>
		END_VAR
		VAR_OUTPUT
			Length 	: UDINT;			//! <Variable Comment="len of the paresed ip " Name="ParseNumber.Length"/>
		END_VAR;
				//! <Function Comment="make the number valid for the autoexec.lsl" Name="SerializeNumber"/>
	FUNCTION SerializeNumber
		VAR_INPUT
			Byte1 	: USINT;			//! <Variable Comment="first byte of the address" Name="SerializeNumber.Byte1"/>
			Byte2 	: USINT;			//! <Variable Comment="second byte of the address" Name="SerializeNumber.Byte2"/>
			Byte3 	: USINT;			//! <Variable Comment="third byte of the address" Name="SerializeNumber.Byte3"/>
			Byte4 	: USINT;			//! <Variable Comment="fourth byte of the address" Name="SerializeNumber.Byte4"/>
			pBuffer 	: ^CHAR;			//! <Variable Comment="pointer to the buffer which contains the text of the autoexec.lsl" Name="SerializeNumber.pBuffer"/>
			udLength 	: UDINT;			//! <Variable Comment="length of the file" Name="SerializeNumber.udLength"/>
		END_VAR
		VAR_OUTPUT
			udSize 	: UDINT;			//! <Variable Comment="length of the string which contains the address for the autoexec.lsl" Name="SerializeNumber.udSize"/>
		END_VAR;
				//! <Function Comment="writes the address of the servers to the autoexec.lsl" Name="SetIPAutoexec"/>
	FUNCTION SetIPAutoexec;
				//! <Function Comment="reads out the address of the OS " Name="GetIPOS"/>
	FUNCTION GetIPOS;
				//! <Function Comment="sets the address in the OS" Name="SetIPOS"/>
	FUNCTION SetIPOS;
	
	FUNCTION VIRTUAL GLOBAL SetConfig::Write
		VAR_INPUT
			input (EAX) 	: NetworkConfig::e_SetOptions;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: NetworkConfig::e_SetOptions;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetConfig::Write
		VAR_INPUT
			input (EAX) 	: NetworkConfig::e_GetOptions;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: NetworkConfig::e_GetOptions;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _FileSys
#pragma usingLtd _IP
#pragma usingLtd _StdLib
#pragma usingLtd SigCLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB NetworkConfig::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_NETWORKCONFIG
1$UINT, 31$UINT, (SIZEOF(::NetworkConfig))$UINT, 
6$UINT, 5$UINT, 0$UINT, 
TO_UDINT(3068426329), "NetworkConfig", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::NetworkConfig.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::NetworkConfig.IPAddress.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1853430993), "IPAddress", 
(::NetworkConfig.SNMask.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3030764618), "SNMask", 
(::NetworkConfig.GWAddress.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2893991514), "GWAddress", 
(::NetworkConfig.SetConfig.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2390827369), "SetConfig", 
(::NetworkConfig.GetConfig.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2142056980), "GetConfig", 
//Clients:
(::NetworkConfig.Interface.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1882649138), "Interface", 
(::NetworkConfig.coFileSys.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(940542775), "coFileSys", TO_UDINT(545279513), "_FileSys", 1$UINT, 19$UINT, 
(::NetworkConfig.coStdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3815072667), "coStdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
(::NetworkConfig.coSigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1750761597), "coSigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 23$UINT, 
(::NetworkConfig.coIP.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2582857610), "coIP", TO_UDINT(3530626343), "_IP", 1$UINT, 8$UINT, 
END_FUNCTION


#define USER_CNT_NetworkConfig 1

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_NetworkConfig] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION NetworkConfig::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_NetworkConfig, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	IPAddress.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF IPAddress.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SNMask.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF SNMask.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	GWAddress.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF GWAddress.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SetConfig.pMeth			:= StoreMethod( #M_RD_DIRECT(), #SetConfig::Write() );
	IF SetConfig.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	GetConfig.pMeth			:= StoreMethod( #M_RD_DIRECT(), #GetConfig::Write() );
	IF GetConfig.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

// LeiChr rev 1.31   09.07.2015
// -----------------------------------
FUNCTION VIRTUAL GLOBAL NetworkConfig::Init

  // read ip settings from os if we start the system
  if (_FirstScan) then
    GetIPOS();
  end_if;
  
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL NetworkConfig::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

  // Set the ip settings in background
  // depent on the selected server
  // *********************************************
  case SetConfig of
    // wait for action
    // -----------------------
    SET_IDLE:
      
    // set the ip settings to autoexec.lsl
    // -----------------------
    SET_AUTOEXEC:
      SetIPAutoexec();
      SetConfig := SET_IDLE;
    
    // set the ip settings to os
    // -----------------------
    SET_OS:
      SetIPOS();
      SetConfig := SET_IDLE;
    
    // set the ip settings to both
    // -----------------------
    SET_BOTH:
      SetIPAutoexec();
      SetIPOS();
      SetConfig := SET_IDLE;
      
  end_case;
  
  
  // get the ip settings in background
  // depent on the selected server
  // *********************************************
  case GetConfig of
    // wait for action
    // -----------------------
    GET_IDLE:
    
    // get the ip settings from autoexec
    // -----------------------
    GET_AUTOEXEC:
      GetIPAutoexec();
      GetConfig := GET_IDLE;
    
    // get the ip settings from os
    // -----------------------
    GET_OS:
      GetIPOS();
      GetConfig := GET_IDLE;
      
  end_case;


	state := READY;

END_FUNCTION


FUNCTION NetworkConfig::GetIPAutoexec
VAR
	tmpHandle       : DINT;
  tmpFileLength   : DINT;
  tmpReadLength   : UDINT;
  tmpFile         : ^CHAR;
  tmpSearchString : ARRAY[0..14] OF CHAR;
  szInterface     : ARRAY[0..5] OF CHAR;
  tmpCommands     : BSINT;
  tmpReturncode   : UDINT;
  tmpSearchLength : UDINT;
  tmpfound        : DINT;
END_VAR

  szInterface[0] := 0;
  
  //Initialize Server
  IPAddress := SNMask := GWAddress := 0;

  //Read Client for Interface-number
  Interface := Interface.Read();
  
  //Init Stack-Variables
  tmpCommands        := 0;
  tmpReadLength      := 0;
  tmpSearchString[0] := 'S';
  tmpSearchString[1] := 'E';
  tmpSearchString[2] := 'T';
  tmpSearchString[3] := ' ';
  tmpSearchString[4] := 'I';
  tmpSearchString[5] := 'P';
  
  if (Interface > 1) & (Interface < 10) then   //  FriHer rev. 1.31
    tmpSearchString[6] := ' ';
    tmpSearchString[7] := (48 + Interface)$CHAR;
    tmpSearchString[8] := 0;
  elsif Interface >= 10 then 
    tmpSearchString[6] := ' ';
    tmpSearchString[7] := 0;
    coSigCLib.IToA(val:= Interface, dst:= #szInterface[0], base:= 10);
    _strcat(dest:= #tmpSearchString[0], src:= #szInterface[0]);
  else
    tmpSearchString[6] := 0;
  end_if;

  tmpSearchLength := _strlen(#tmpSearchString[0]);
  
  //Open autoexec.lsl  
  tmpHandle := coFileSys.FileOpen(filename    := "C:\autoexec.lsl", 
                                  attributes  := ATT_READ_ONLY);
     
     
  //Check if Handle is valid
  if tmpHandle < 0 then
    return;
  end_if;
  
  
  //Allocate Memory for Block  
  //*****************************************************************************
  
  //Get Length of File
  tmpFileLength := coFileSys.FileLength(handle := tmpHandle);

  if tmpFileLength < 0 then
    return;
  end_if;

  //Allocate Memory
  tmpFile:= (coStdLib.Malloc(size := tmpFileLength$UDINT + 1))$^CHAR;

  //Check if Pointer is valid
  if tmpFile = NIL then
    return;
  end_if;
  
  
  //Read File and search for Configuration
  //*****************************************************************************
  
  //Get Data from File
  coFileSys.FileRead( handle  := tmpHandle,
                      buffer  := tmpFile, 
                      length  := tmpFileLength$UDINT);
  
  //Close File
  coFileSys.FileClose(handle := tmpHandle);
  
  //ZeroCut of File to avoid problems with _strupr
  (tmpFile + tmpFileLength)^ := 0;
  
  //Change to Capital Letters
  _strupr(str := tmpFile);
       
  //Parsing
  //*****************************************************************************
  while tmpReadLength < tmpFileLength$UDINT do

    tmpfound := 0;

    // Search for REM    
    if (_memcmp(tmpFile + tmpReadLength, "REM", 3) = 0) then
      repeat
        tmpReadLength += 1;
      until ((tmpFile + (tmpReadLength - 1))^ = 10) end_repeat;

    else

      //Search for Configuration of IP2
      if _memcmp(ptr1 := tmpFile + tmpReadLength, ptr2 := #tmpSearchString[0], cntr := tmpSearchLength) = 0 then

        //Get over "Set IP X"
        if (Interface > 1) then // spimar rev 1.21
          tmpReadLength += 9;

        else
          tmpReadLength += 6;

          repeat

            if (((tmpFile + tmpReadLength)^ >'0') & ((tmpFile + tmpReadLength)^ < '9')) then

              repeat
                tmpReadLength += 1;

              until ((tmpFile + tmpReadLength)^ = 10) end_repeat;

              tmpfound := 1;

            else
              tmpReadLength += 1;

            end_if;

          until ((tmpFile + (tmpReadLength))^ > '9') end_repeat;

        end_if;

        if (tmpfound = 0) then
          //Search for type of Set IP
          while tmpReadLength < tmpFileLength$UDINT do
            //Hostaddr
            //------------------------------------------------------------------------------------
            if (_memcmp(ptr1 := tmpFile + tmpReadLength, ptr2 := "HOSTADDR", cntr := 8) = 0) & (tmpCommands.1 = 0) then
              
              //Get over "HOSTADDR"
              tmpReadLength += 8;
            
              //Search forAddress
              while tmpReadLength < tmpFileLength$UDINT do
              
                //Search for Numbers
                if IsNumber(usCHAR := (tmpFile + tmpReadLength)^) = true then
                  
                  tmpReturncode := ParseNumber( usType    := 0, 
                                                pBuffer   := tmpFile + tmpReadLength, 
                                                udLength  := tmpFileLength$UDINT - tmpReadLength);
                                                
                  if tmpReturncode then
    //                tmpReadLength += tmpReturncode;
                    tmpCommands.1 := 1;
                  end_if;
                  
                  exit;
                
                else
                  //GoTo next Element
                  tmpReadLength += 1;
                end_if;

                
              end_while;
                        
              exit;
              
            end_if;


            //Subnet
            //------------------------------------------------------------------------------------
            if (_memcmp(ptr1 := tmpFile + tmpReadLength, ptr2 := "SUBNET", cntr := 6) = 0) & (tmpCommands.2 = 0) then
              
              //Get over "SUBNET"
              tmpReadLength += 6;
              
              //Search forAddress
              while tmpReadLength < tmpFileLength$UDINT do
              
                //Search for Numbers
                if IsNumber(usCHAR := (tmpFile + tmpReadLength)^) = true then
                  
                  tmpReturncode := ParseNumber( usType    := 1, 
                                                pBuffer   := tmpFile + tmpReadLength, 
                                                udLength  := tmpFileLength$UDINT - tmpReadLength);
                                                
                  if tmpReturncode then
    //                tmpReadLength += tmpReturncode;
                    tmpCommands.2 := 1;
                  end_if;
                  
                  exit;

                else
                  //GoTo next Element
                  tmpReadLength += 1;
                end_if;

              end_while;
            
              exit;
              
            end_if;

            //Gateway
            //------------------------------------------------------------------------------------
            if (_memcmp(ptr1 := tmpFile + tmpReadLength, ptr2 := "GATEWAY", cntr := 7) = 0) & (tmpCommands.3 = 0) then
              
              //Get over "GATEWAY"
              tmpReadLength += 7;
     
              //Search forAddress
              while tmpReadLength < tmpFileLength$UDINT do
              
                //Search for Numbers
                if IsNumber(usCHAR := (tmpFile + tmpReadLength)^) = true then
                  
                  tmpReturncode := ParseNumber( usType    := 2, 
                                                pBuffer   := tmpFile + tmpReadLength, 
                                                udLength  := tmpFileLength$UDINT - tmpReadLength);
                                                
                  if tmpReturncode then
    //                tmpReadLength += tmpReturncode;
                    tmpCommands.3 := 1;
                  end_if;
                  
                  exit;

                else
                  //GoTo next Element
                  tmpReadLength += 1;
                end_if;
                
              end_while;

              exit;
              
            end_if;

            //Get to next Position
            tmpReadLength += 1;
            
          end_while;

        else
          tmpReadLength -= 1;

        end_if;

        //Everything is done
        if tmpCommands = 2#111 then
          exit;
        end_if;

      end_if;

      //Get to next Position
      tmpReadLength += 1;

    end_if;
  end_while;

  //Free Memory
  coStdLib.Free(mptr := tmpFile);

END_FUNCTION


FUNCTION NetworkConfig::ParseNumber
	VAR_INPUT
		usType 	: USINT;
		pBuffer 	: ^CHAR;
		udLength 	: UDINT;
	END_VAR
	VAR_OUTPUT
		Length 	: UDINT;
	END_VAR
  VAR
  	tmpLength   : UDINT;
    tmpPosition : DINT;
    tmpString   : ARRAY[0..3] OF CHAR;
    tmpValue    : USINT;
    tmpElement  : USINT;
  END_VAR
  
  //Init Locals
  tmpLength   := 0;
  tmpPosition := -1;
  tmpElement  := 0;
  
  //Init Returncode
  Length := 0;
  
  //Parse Address
  while tmpLength < udLength do
  
    //Search for end of Number
    if (tmpPosition <> -1) & (IsNumber(usCHAR := (pBuffer + tmpLength)^) = false) then
    
      //Get Number in own String
//      _memset(dest := #tmpString[0], usByte := 0, cntr := sizeof(tmpString));
      _memcpy(ptr1 := #tmpString[0], ptr2 := pBuffer + tmpPosition$UDINT, cntr := tmpLength - tmpPosition$UDINT);
      tmpString[tmpLength - tmpPosition$UDINT] := 0;
      
      //Delete Position
      tmpPosition := -1;
      
      //Convert to IP
      tmpValue := (coSigCLib.AToI(#tmpString[0]))$USINT;
   
      //Write Information to Server
      case usType of
      
        //IP Address
        //-----------------------------------------
        0:
          case tmpElement of
            0: IPAddress := (IPAddress AND 16#FFFFFF00) OR tmpValue;
            1: IPAddress := (IPAddress AND 16#FFFF00FF) OR (tmpValue SHL 8);
            2: IPAddress := (IPAddress AND 16#FF00FFFF) OR (tmpValue SHL 16);
            3: IPAddress := (IPAddress AND 16#00FFFFFF) OR (tmpValue SHL 24);
          end_case;
          
        //Subnet Mask
        //-----------------------------------------
        1:
          case tmpElement of
            0: SNMask := (SNMask AND 16#FFFFFF00) OR tmpValue;
            1: SNMask := (SNMask AND 16#FFFF00FF) OR (tmpValue SHL 8);
            2: SNMask := (SNMask AND 16#FF00FFFF) OR (tmpValue SHL 16);
            3: SNMask := (SNMask AND 16#00FFFFFF) OR (tmpValue SHL 24);
          end_case;
        
        //Gateways
        //-----------------------------------------
        2:
          case tmpElement of
            0: GWAddress := (GWAddress AND 16#FFFFFF00) OR tmpValue;
            1: GWAddress := (GWAddress AND 16#FFFF00FF) OR (tmpValue SHL 8);
            2: GWAddress := (GWAddress AND 16#FF00FFFF) OR (tmpValue SHL 16);
            3: GWAddress := (GWAddress AND 16#00FFFFFF) OR (tmpValue SHL 24);
          end_case;
          
      end_case;
      

      //Everything finished?
      if tmpElement >= 3 then
      
        //-1 because we are now at the next letter!
        tmpLength -= 1;
        
        //Set Returncode and Exit
        Length := tmpLength;
        exit;
        
      else
        tmpElement += 1;
      end_if;
    
    
    //Search for Numbers
    elsif (tmpPosition = -1) & (IsNumber(usCHAR := (pBuffer + tmpLength)^) = true) then
      tmpPosition := tmpLength$DINT;
      
    //No valid size for address
    elsif (tmpPosition <> -1) & (tmpLength - tmpPosition$UDINT >= 3) then
      tmpPosition := -1;
      tmpElement += 1;
    end_if;
  
    //Move to next Position
    tmpLength += 1;
   
  end_while;
  
END_FUNCTION


FUNCTION NetworkConfig::IsNumber
	VAR_INPUT
		usCHAR 	: DINT;
	END_VAR
	VAR_OUTPUT
		bNumber 	: DINT;
	END_VAR

  //Ascii Number
  if usCHAR >= '0' & usCHAR <= '9' then
    bNumber := true;
    
  //No Ascii Number
  else
    bNumber := false;
  end_if;
  
END_FUNCTION


FUNCTION NetworkConfig::SerializeNumber
	VAR_INPUT
		Byte1 	: USINT;
		Byte2 	: USINT;
		Byte3 	: USINT;
		Byte4 	: USINT;
		pBuffer 	: ^CHAR;
		udLength 	: UDINT;
	END_VAR
	VAR_OUTPUT
		udSize 	: UDINT;
	END_VAR
  VAR
  	tmpString : ARRAY[0..15] OF CHAR;
    tmpByte   : ARRAY[0..3] OF CHAR;
    tmpLength : UDINT;
  END_VAR

  //Init Returncode
  udSize := 0;
  
  //Check Input Parameter
  if pBuffer = NIL | udLength = 0 then
    return;
  end_if;
  
  //First Byte
  //*****************************************************************************
  //Reset Byte
  _memset(#tmpByte[0], 0, sizeof(tmpByte));
  
  coSigCLib.IToA(val := Byte1, dst := #tmpByte[0], base := 10);
       
  _strcpy(dest := #tmpString[0], src := #tmpByte[0]);
  _strcat(dest := #tmpString[0], src := ".");

  //Second Byte
  //*****************************************************************************
  //Reset Byte
  _memset(#tmpByte[0], 0, sizeof(tmpByte));
  
  coSigCLib.IToA(val := Byte2, dst := #tmpByte[0], base := 10);
       
  _strcat(dest := #tmpString[0], src := #tmpByte[0]);
  _strcat(dest := #tmpString[0], src := ".");

  //Third Byte
  //*****************************************************************************
  //Reset Byte
  _memset(#tmpByte[0], 0, sizeof(tmpByte));
  
  coSigCLib.IToA(val := Byte3, dst := #tmpByte[0], base := 10);
       
  _strcat(dest := #tmpString[0], src := #tmpByte[0]);
  _strcat(dest := #tmpString[0], src := ".");
 
  //Fourth Byte
  //*****************************************************************************
  //Reset Byte
  _memset(#tmpByte[0], 0, sizeof(tmpByte));
  
  coSigCLib.IToA(val := Byte4, dst := #tmpByte[0], base := 10);
       
  _strcat(dest:= #tmpString[0], src := #tmpByte[0]);
  
  
  //Get Length of String
  tmpLength := _strlen(src := #tmpString[0]);
  
  //Check if we got enough Space in Buffer
  if tmpLength > udLength then
    return;
  end_if;

  //Copy to Buffer
  _memcpy(ptr1 := pBuffer, ptr2 := #tmpString[0], cntr := tmpLength);

  //Return Size of String
  udSize := tmpLength;
  
END_FUNCTION


FUNCTION NetworkConfig::SetIPAutoexec
VAR
	tmpHandle       : DINT;
  tmpFileLength   : DINT;
  tmpReadLength   : UDINT;
  tmpFile         : ^CHAR;
  tmpSearchString : ARRAY[0..14] OF CHAR;
  szInterface     : ARRAY[0..5] OF CHAR;
  tmpCommands     : BSINT;
  tmpSearchLength : UDINT;
  tmpfound        : DINT;
END_VAR

  szInterface[0] := 0;

  //Read Client for Interface-number
  Interface := Interface.Read();
  
  //Init Stack-Variables
  tmpCommands         := 0;
  tmpReadLength       := 0;
  tmpSearchString[0]  := 'S';
  tmpSearchString[1]  := 'E';
  tmpSearchString[2]  := 'T';
  tmpSearchString[3]  := ' ';
  tmpSearchString[4]  := 'I';
  tmpSearchString[5]  := 'P';
  
  if (Interface > 1) & (Interface < 10) then   //  FriHer rev 1.31
    tmpSearchString[6] := ' ';
    tmpSearchString[7] := (48 + Interface)$CHAR;
    tmpSearchString[8] := 0;
  elsif Interface >= 10 then 
    tmpSearchString[6] := ' ';
    tmpSearchString[7] := 0;
    coSigCLib.IToA(val:= Interface, dst:= #szInterface[0], base:= 10);
    _strcat(dest:= #tmpSearchString[0], src:= #szInterface[0]);
  else
    tmpSearchString[6] := 0;
  end_if;

  tmpSearchLength := _strlen(#tmpSearchString[0]);
  
  //Open autoexec.lsl  
  tmpHandle := coFileSys.FileOpen(filename    := "C:\autoexec.lsl", 
                                  attributes  := ATT_READ_ONLY);
     
     
  //Check if Handle is valid
  if tmpHandle < 0 then
    return;
  end_if;
  
  
  //Allocate Memory for Block  
  //*****************************************************************************
  
  //Get Length of File
  tmpFileLength := coFileSys.FileLength(handle := tmpHandle);

  if tmpFileLength < 0 then
    return;
  end_if;

  //Allocate Memory
  tmpFile:= (coStdLib.Malloc(size := tmpFileLength$UDINT + 1))$^CHAR;

  //Check if Pointer is valid
  if tmpFile = NIL then
    return;
  end_if;
  
  
  //Read File and search for Configuration
  //*****************************************************************************
  
  //Get Data from File
  coFileSys.FileRead( handle  := tmpHandle,
                      buffer  := tmpFile, 
                      length  := tmpFileLength$UDINT);
   
  coFileSys.FileClose(handle := tmpHandle);
  
  //ZeroCut of File to avoid problems with _strupr
  (tmpFile + tmpFileLength)^ := 0;
  
  //Change to Capital Letters
  _strupr(str := tmpFile);
       
  //Parsing
  //*****************************************************************************
  while tmpReadLength < tmpFileLength$UDINT do

    tmpfound := 0;

    // Search for REM
    if (_memcmp(tmpFile + tmpReadLength, "REM", 3) = 0) then
      repeat
        tmpReadLength += 1;
      until ((tmpFile + (tmpReadLength - 1))^ = 10) end_repeat;

    else

      //Search for Configuration of IP2
      if _memcmp(ptr1 := tmpFile + tmpReadLength, ptr2 := #tmpSearchString[0], cntr := tmpSearchLength) = 0 then
        
        //Get over "Set IP X"
        if (Interface > 1) then // spimar rev 1.21
          tmpReadLength += 9;

        else
          tmpReadLength += 6;

          repeat

            if (((tmpFile + tmpReadLength)^ >'0') & ((tmpFile + tmpReadLength)^ < '9')) then

              repeat
                tmpReadLength += 1;

              until ((tmpFile + tmpReadLength)^ = 10) end_repeat;

              tmpfound := 1;

            else
              tmpReadLength += 1;

            end_if;

          until ((tmpFile + (tmpReadLength))^ > '9') end_repeat;

        end_if;

        if (tmpfound = 0) then
          //Search for type of Set IP
          while tmpReadLength < tmpFileLength$UDINT do
          
            //Hostaddr
            //------------------------------------------------------------------------------------
            if (_memcmp(ptr1 := tmpFile + tmpReadLength, ptr2 := "HOSTADDR", cntr := 8) = 0) & (tmpCommands.1 = 0) & (IPAddress) then
              
              //Get over "HOSTADDR"
              tmpReadLength += 8;
            
              //Exchange Number
              tmpFile := ExchangeNumber(usType    := 0, 
                                        pBuffer   := tmpFile, 
                                        pPosition := #tmpReadLength, 
                                        pLength   := #tmpFileLength); 
                              
              tmpCommands.1 := 1;
              exit;
                                           
            end_if;
            
            //Subnet
            //------------------------------------------------------------------------------------
            if (_memcmp(ptr1 := tmpFile + tmpReadLength, ptr2 := "SUBNET", cntr := 6) = 0) & (tmpCommands.2 = 0) & (SNMask) then
              
              //Get over "SUBNET"
              tmpReadLength += 6;
              
              //Exchange Number
              tmpFile := ExchangeNumber(usType    := 1, 
                                        pBuffer   := tmpFile, 
                                        pPosition := #tmpReadLength, 
                                        pLength   := #tmpFileLength); 
                              
              tmpCommands.2 := 1;
              exit;
                              
            end_if;

            //Gateway
            //------------------------------------------------------------------------------------
            if (_memcmp(ptr1 := tmpFile + tmpReadLength, ptr2 := "GATEWAY", cntr := 7) = 0) & (tmpCommands.3 = 0) & (GWAddress) then
              
              //Get over "GATEWAY"
              tmpReadLength += 7;
              
              //Exchange Number
              tmpFile := ExchangeNumber(usType    := 2, 
                                        pBuffer   := tmpFile, 
                                        pPosition := #tmpReadLength, 
                                        pLength   := #tmpFileLength); 
                              
              tmpCommands.3 := 1;
              exit;
                              
            end_if;

            //Get to next Position
            tmpReadLength += 1;
            
          end_while;
        else
          tmpReadLength -= 1;

        end_if;

        //Everything is done
        if tmpCommands = 2#111 then
          exit;
        end_if;

      end_if;
      
      //Get to next Position
      tmpReadLength += 1;

    end_if;
  end_while;

  //Open autoexec.lsl  
  tmpHandle := coFileSys.FileOpen(filename    := "C:\autoexec.lsl", 
                                  attributes  := ATT_CREATE_ALWAYS);
     
     
  //Check if Handle is valid
  if tmpHandle < 0 then
    return;
  end_if;
                      
  //Write Data into File
  coFileSys.FileWrite(handle  := tmpHandle, 
                      buffer  := tmpFile, 
                      length  := tmpFileLength$UDINT);
                
  //Close the File
  coFileSys.FileClose(handle := tmpHandle);
                      
  //Free Memory
  coStdLib.Free(mptr :=tmpFile);
  
END_FUNCTION


FUNCTION NetworkConfig::ExchangeNumber
	VAR_INPUT
		usType 	: USINT;
		pBuffer 	: ^CHAR;
		pPosition 	: ^UDINT;
		pLength 	: ^DINT;
	END_VAR
	VAR_OUTPUT
		pNewBuffer 	: ^CHAR;
	END_VAR
  VAR
    tmpSeperator    : USINT;
    tmpWaitNumber   : BOOL;
    tmpPosition1    : UDINT;
    tmpPosition2    : UDINT;
    tmpString       : ARRAY[0..15] OF CHAR;
    tmpSize         : UDINT;
    tmpNewSize      : UDINT;
  END_VAR
    
  //Search for Address
  while pPosition^ < pLength^$UDINT do

    //Search for Numbers
    if IsNumber(usCHAR := (pBuffer + pPosition^)^) = true then
      
      tmpSeperator  := 0;
      tmpWaitNumber := false;
      tmpPosition1  := pPosition^;
      
      //Search for end of Address
      while pPosition^ < pLength^$UDINT  do
      
        if (tmpWaitNumber = false) & (IsNumber(usCHAR := (pBuffer + pPosition^)^) = false) & (tmpSeperator < 3) then
          //If next Element is number, we got Seperator
          tmpWaitNumber := true;
        
        elsif (tmpWaitNumber = true) & (IsNumber(usCHAR := (pBuffer + pPosition^)^) = true) & (tmpSeperator < 3) then
          //Count Seperators
          tmpSeperator  += 1;
          tmpWaitNumber := false;
          
        //End of Address (after 3 Seperator)
        elsif (tmpSeperator >= 3) & (IsNumber(usCHAR := (pBuffer + pPosition^)^) = false) then
        
          tmpPosition2 := pPosition^;
          
          //Depending on Type, serialize Adress
          case usType of
            
            //IP-Address
            //------------------------------------------------------------------
            0:  tmpSize := SerializeNumber( Byte1     := (IPAddress AND 16#FF)$USINT, 
                                            Byte2     := ((IPAddress AND 16#FF00) SHR 8)$USINT, 
                                            Byte3     := ((IPAddress AND 16#FF0000) SHR 16)$USINT, 
                                            Byte4     := ((IPAddress AND 16#FF000000) SHR 24)$USINT, 
                                            pBuffer   := #tmpString[0], 
                                            udLength  := sizeof(tmpString));
            
            //Subnet-Mask
            //------------------------------------------------------------------
            1:  tmpSize := SerializeNumber( Byte1     := (SNMask AND 16#FF)$USINT, 
                                            Byte2     := ((SNMask AND 16#FF00) SHR 8)$USINT, 
                                            Byte3     := ((SNMask AND 16#FF0000) SHR 16)$USINT, 
                                            Byte4     := ((SNMask AND 16#FF000000) SHR 24)$USINT, 
                                            pBuffer   := #tmpString[0], 
                                            udLength  := sizeof(tmpString));
                                            
            //Gateway
            //------------------------------------------------------------------
            2:  tmpSize := SerializeNumber( Byte1     := (GWAddress AND 16#FF)$USINT, 
                                            Byte2     := ((GWAddress AND 16#FF00) SHR 8)$USINT, 
                                            Byte3     := ((GWAddress AND 16#FF0000) SHR 16)$USINT, 
                                            Byte4     := ((GWAddress AND 16#FF000000) SHR 24)$USINT, 
                                            pBuffer   := #tmpString[0], 
                                            udLength  := sizeof(tmpString));
                                            
          end_case;
          
          //Check if Size is equal
          if tmpSize <> tmpPosition2 - tmpPosition1 then
          
            //More Memory is needed
            //--------------------------------------------------------------
            if tmpSize > tmpPosition2 - tmpPosition1 then
            
              tmpNewSize := pLength^$UDINT + (tmpSize - (tmpPosition2 - tmpPosition1));
              pPosition^ += tmpSize - (tmpPosition2 - tmpPosition1);
              
              //Reallocate everytime, to avoid problems with invalid configuration which get corrected by this class
              pBuffer$^void := coStdLib.ReAlloc(mptr := pBuffer$^void, newsize := tmpNewSize);
              
              //Move Memory to get Space for the Address
              _memmove(dest := pBuffer + tmpPosition2 + tmpNewSize - pLength^$UDINT, src := pBuffer + tmpPosition2, anz := pLength^$UDINT - tmpPosition2);
              
            //Less Memory is needed
            //--------------------------------------------------------------
            else
            
              tmpNewSize := pLength^$UDINT - ((tmpPosition2 - tmpPosition1) - tmpSize);
              pPosition^ -= (tmpPosition2 - tmpPosition1) - tmpSize;
              
              //Move Memory to get Space for the Address
              _memmove(dest := pBuffer + tmpPosition2 - ((tmpPosition2 - tmpPosition1) - tmpSize), src := pBuffer + tmpPosition2, anz := pLength^$UDINT - tmpPosition2);
              
              //Reallocate everytime, to avoid problems with invalid configuration which get corrected by this class
              pBuffer$^void := coStdLib.ReAlloc(mptr := pBuffer$^void, newsize := tmpNewSize);

            end_if;

            pLength^ := tmpNewSize$DINT;
          
          end_if;
          
          //Copy String into the Memory
          _memcpy(ptr1 := pBuffer + tmpPosition1, ptr2 := #tmpString[0], cntr := tmpSize);

          //Finished
          exit;
          
        end_if;
      
        //GoTo next Element
        pPosition^ += 1;
        
      end_while;

      exit;
    
    else
      //GoTo next Element
      pPosition^ += 1;
    end_if;

  end_while;
  
  //Return new Pointer
  pNewBuffer := pBuffer;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL NetworkConfig::SetConfig::Write
	VAR_INPUT
		input (EAX) 	: NetworkConfig::e_SetOptions;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: NetworkConfig::e_SetOptions;
	END_VAR
  
  // LeIChr rev1.31  delete the set options and move to background
	SetConfig := input;
 	result := SetConfig;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL NetworkConfig::GetConfig::Write
	VAR_INPUT
		input (EAX) 	: NetworkConfig::e_GetOptions;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: NetworkConfig::e_GetOptions;
	END_VAR

  // LeiChr rev1.31  delte the get options and move to background

	GetConfig := input;
 	result := GetConfig;

END_FUNCTION


FUNCTION NetworkConfig::GetIPOS
      
  //Get selected Interface
  Interface := Interface.Read();
  
  //Get IP-Address
  coIP.GetIPInfo( dIface  := Interface, 
                  dOption := IPAPI_OPT_ADDR, 
                  pValue  := #IPAddress, 
                  addOpt  := 0);
                  
  //Get SubnetMask
  coIP.GetIPInfo( dIface  := Interface, 
                  dOption := IPAPI_OPT_SUBNETMASK, 
                  pValue  := #SNMask,   
                  addOpt  := 0);
                                              
  //Get Gateway
  coIP.GetIPInfo( dIface  := Interface, 
                  dOption := IPAPI_OPT_GATEWAY, 
                  pValue  := #GWAddress, 
                  addOpt  := 0);
                                              
END_FUNCTION


FUNCTION NetworkConfig::SetIPOS
VAR
	tmpIPAddress  : ARRAY[0..15] OF CHAR;
  tmpSNMask     : ARRAY[0..15] OF CHAR;
  tmpGWAddress  : ARRAY[0..15] OF CHAR;
END_VAR

  //Convert IP-Address to String
  coIP.ConvertBinToStr( strAddress    := #tmpIPAddress[0], 
                        strAddressLen := sizeof(tmpIPAddress), 
                        IPAddress     := IPAddress);

  //Convert SubnetMask to String
  coIP.ConvertBinToStr( strAddress    := #tmpSNMask[0], 
                        strAddressLen := sizeof(tmpSNMask), 
                        IPAddress     := SNMask);


  //Convert Gateway to String
  coIP.ConvertBinToStr( strAddress    := #tmpGWAddress[0], 
                        strAddressLen := sizeof(tmpGWAddress), 
                        IPAddress     := GWAddress);
                                                    
  //Get selected Interface
  Interface := Interface.Read();
  
  //Set new IP Configuration
  coIP.SetIP( InterfaceNumber := Interface, 
              Address         := #tmpIPAddress[0], 
              SubnetMask      := #tmpSNMask[0], 
              Gateway         := #tmpGWAddress[0]);
              
END_FUNCTION

