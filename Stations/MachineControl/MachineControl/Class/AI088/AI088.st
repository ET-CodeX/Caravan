//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define DEVICE_ID_AI088 1009

#define AI088_ADDR_CYC_WRITE        16#000
#define AI088_ADDR_CYC_READ         16#080
#define AI088_ADDR_CFG_FIRMWARE     16#100
#define AI088_ADDR_STATE_FIRMWARE   16#180

#define AI088_SDO_RESPONSE_TIMEOUT  SDIAS_SDO_TIMEOUT * 2

#define AI088_LENGTH_STATE_FIRMWARE 2
#define AI088_NUMBER_OF_TMP_INPUT   10
#define AI088_CABLE_BREAK_MASK      16#3FF  //10 BITS
#define AI088_SHORT_CIRCUIT_MASK    16#3    //2 BITS
#define AI088_INVALID_VALUE         16#80000010$DINT

#define AI088_FIRMWARE_VERSION_INT_TEMP_REF 16#200  //Firmware version since when internal temperature reference and message counter are supported
#define AI088_HARDWARE_VERSION_INT_TEMP_REF 16#300  //Hardware version since when internal temperature reference are supported
// for TMP_XSelect = 10: data coming from FW may be originally negative but are
// sent as UINT type - so negativ values are sent as very big UINT values
// values greater than AI088_THRESHOLD_NEG_VALS are interpreted as neative ones
#define AI088_THRESHOLD_NEG_VALS  59000
#define AI088_SUBTRACT_FOR_INT    16#10000
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "AI088"
	Revision           = "1.34"
	GUID               = "{D9D2B248-5D16-4402-9C4A-7431D84AF14B}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\s-dias.ico"
	SharedCommandTable = "true"
	Objectsize         = "(528,120)"
	Comment            = "SDIAS Analog In Module&#13;&#10;8x Temperature In for selectable thermocouple elements&#13;&#10;2x Temperature In for KTY-temperature sensors">
	<Channels>
		<Server Name="CableBreak" GUID="{1B7D247E-425F-458D-B9B2-019ABA7B771D}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Cable break detection:&#13;&#10;Bit1...Cable break on TMP_1&#13;&#10;Bit2...Cable break on TMP_2&#13;&#10;Bit3...Cable break on TMP_3&#13;&#10;Bit4...Cable break on TMP_4&#13;&#10;Bit5...Cable break on TMP_5&#13;&#10;Bit6...Cable break on TMP_6&#13;&#10;Bit7...Cable break on TMP_7&#13;&#10;Bit8...Cable break on TMP_8&#13;&#10;Bit9...Cable break on KTY_1&#13;&#10;Bit10...Cable break on KTY_2"/>
		<Server Name="FirmwareVersion" GUID="{5EC27C2C-D730-4134-A679-44C5B3EF892C}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Version of the used firmware&#13;&#10;&#13;&#10;e.g. 16#100 means v1.0"/>
		<Server Name="FWErrorBits" GUID="{B4566F17-27B9-4B2E-A84E-6919B708D32C}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Firmware Status:&#13;&#10;Bit1...DC not Ok&#13;&#10;Bit2...No Sync&#13;&#10;Bit3...Flash data CRC error&#13;&#10;Bit4...Ram data CRC error&#13;&#10;Bit5...No valid EEPROM Version&#13;&#10;Bit6...Bus Time Error&#13;&#10;"/>
		<Server Name="KTY_1" GUID="{CC1D8C07-FE0B-4F02-A806-B09555966097}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the reference temperature measured &#13;&#10;over KTY input in 1/10 °C.&#13;&#10;The invalid value in case of cable break or &#13;&#10;short circuit is -2147483632. "/>
		<Server Name="KTY_2" GUID="{164CA711-05AC-4F16-A26D-983F0C4FDF00}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the reference temperature measured &#13;&#10;over KTY input in 1/10 °C.&#13;&#10;The invalid value in case of cable break or &#13;&#10;short circuit is -2147483632. "/>
		<Server Name="KTY_Int_1" GUID="{9F1F8051-724E-4761-8BD8-573961C7192E}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the reference temperature measured by the internal KTY for temperature inputs 1-4 in 1/10°C.&#13;&#10;If this function is disabled or not supported (only firmware version 2.00 or higher and &#13;&#10;hardware version 3.00 or higher), the server displays  -2147483632. "/>
		<Server Name="KTY_Int_2" GUID="{0DBC5F39-1C26-49E1-BFAC-D3B0ECAA6F99}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the reference temperature measured by the internal KTY for temperature inputs 5-8 in 1/10°C.&#13;&#10;If this function is disabled or not supported (only firmware version 2.00 or higher and &#13;&#10;hardware version 3.00 or higher), the server displays  -2147483632. "/>
		<Server Name="ShortCircuit" GUID="{8621D488-0B90-498C-AD96-22D425819778}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Short cut detection:&#13;&#10;Bit1...Short circuit on KTY_1&#13;&#10;Bit2...Short circuit on KTY_2"/>
		<Server Name="TMP_1" GUID="{00685AAB-A9BA-4F76-B00D-BB127F43028E}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Thermocouple  Input in 1/10 °C or in µV corresponding to setting of TMP_xSelect.&#13;&#10;The invalid value in case of Cable Break is &#13;&#10;-2147483632."/>
		<Server Name="TMP_2" GUID="{3575F4FB-E428-4B1C-AE5A-28EA0FC88695}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Thermocouple  Input in 1/10 °C or in µV corresponding to setting of TMP_xSelect.&#13;&#10;The invalid value in case of Cable Break is &#13;&#10;-2147483632."/>
		<Server Name="TMP_3" GUID="{2F63DDD6-A62A-4CEE-98AC-0B17A4E39FE5}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Thermocouple  Input in 1/10 °C or in µV corresponding to setting of TMP_xSelect.&#13;&#10;The invalid value in case of Cable Break is &#13;&#10;-2147483632."/>
		<Server Name="TMP_4" GUID="{21A7C306-263E-4C3C-9E00-9FC5794517AC}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Thermocouple  Input in 1/10 °C or in µV corresponding to setting of TMP_xSelect.&#13;&#10;The invalid value in case of Cable Break is &#13;&#10;-2147483632."/>
		<Server Name="TMP_5" GUID="{A8E6A683-3323-45AA-B51E-4AF39CBE718A}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Thermocouple  Input in 1/10 °C or in µV corresponding to setting of TMP_xSelect.&#13;&#10;The invalid value in case of Cable Break is &#13;&#10;-2147483632."/>
		<Server Name="TMP_6" GUID="{AEE098A7-C0C8-4250-97AA-FDEA8B368FAA}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Thermocouple  Input in 1/10 °C or in µV corresponding to setting of TMP_xSelect.&#13;&#10;The invalid value in case of Cable Break is &#13;&#10;-2147483632."/>
		<Server Name="TMP_7" GUID="{CB4D147C-79B6-4279-B3F2-2A799266DE6F}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Thermocouple  Input in 1/10 °C or in µV corresponding to setting of TMP_xSelect.&#13;&#10;The invalid value in case of Cable Break is &#13;&#10;-2147483632."/>
		<Server Name="TMP_8" GUID="{AFBEF1C9-B06E-44E6-B9E0-4AF5736056E9}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Thermocouple  Input in 1/10 °C or in µV corresponding to setting of TMP_xSelect.&#13;&#10;The invalid value in case of Cable Break is &#13;&#10;-2147483632."/>
		<Client Name="TMP_1RefSensor" Required="false" Internal="false" DefValue="0" Comment="Select reference KTY input for temperatur compensation:&#13;&#10;0..KTY_1&#13;&#10;1..KTY_2&#13;&#10;2..internal KTY&#13;&#10;"/>
		<Client Name="TMP_1Select" Required="false" Internal="false" Comment="This client selects the thermocouple element for the temperature input&#13;&#10;0...Typ J (Fe-CuNi  0... +690°C)&#13;&#10;1...Typ K (NiCr-Ni  0... +940°C)&#13;&#10;2...Typ T (Cu-CuNi  0... +400°C)&#13;&#10;3...Typ E (NiCr-CuNi  0... +520°C)&#13;&#10;4...Typ N (NiCrSi-NiSi 0...+1080°C)&#13;&#10;5...Typ S (Pt10Rh-Pt 0...+1760°C)&#13;&#10;6...Typ R (Pt13Rh-Pt 0...+1760°C)&#13;&#10;7...Typ B (Pt30Rh-Pt6Rh 0...+1820°C)&#13;&#10;8...Typ L (Fe-CuNi 0... +680°C)&#13;&#10;9...Typ U (Cu-CuNi 0... +590°C)&#13;&#10;10..Analog In (0 - 40000µV)"/>
		<Client Name="TMP_2RefSensor" Required="false" Internal="false" DefValue="0" Comment="Select reference KTY input for temperatur compensation:&#13;&#10;0..KTY_1&#13;&#10;1..KTY_2&#13;&#10;2..internal KTY&#13;&#10;"/>
		<Client Name="TMP_2Select" Required="false" Internal="false" Comment="This client selects the thermocouple element for the temperature input&#13;&#10;0...Typ J (Fe-CuNi  0... +690°C)&#13;&#10;1...Typ K (NiCr-Ni  0... +940°C)&#13;&#10;2...Typ T (Cu-CuNi  0... +400°C)&#13;&#10;3...Typ E (NiCr-CuNi  0... +520°C)&#13;&#10;4...Typ N (NiCrSi-NiSi 0...+1080°C)&#13;&#10;5...Typ S (Pt10Rh-Pt 0...+1760°C)&#13;&#10;6...Typ R (Pt13Rh-Pt 0...+1760°C)&#13;&#10;7...Typ B (Pt30Rh-Pt6Rh 0...+1820°C)&#13;&#10;8...Typ L (Fe-CuNi 0... +680°C)&#13;&#10;9...Typ U (Cu-CuNi 0... +590°C)&#13;&#10;10..Analog In (0 - 40000µV)"/>
		<Client Name="TMP_3RefSensor" Required="false" Internal="false" DefValue="0" Comment="Select reference KTY input for temperatur compensation:&#13;&#10;0..KTY_1&#13;&#10;1..KTY_2&#13;&#10;2..internal KTY&#13;&#10;"/>
		<Client Name="TMP_3Select" Required="false" Internal="false" Comment="This client selects the thermocouple element for the temperature input&#13;&#10;0...Typ J (Fe-CuNi  0... +690°C)&#13;&#10;1...Typ K (NiCr-Ni  0... +940°C)&#13;&#10;2...Typ T (Cu-CuNi  0... +400°C)&#13;&#10;3...Typ E (NiCr-CuNi  0... +520°C)&#13;&#10;4...Typ N (NiCrSi-NiSi 0...+1080°C)&#13;&#10;5...Typ S (Pt10Rh-Pt 0...+1760°C)&#13;&#10;6...Typ R (Pt13Rh-Pt 0...+1760°C)&#13;&#10;7...Typ B (Pt30Rh-Pt6Rh 0...+1820°C)&#13;&#10;8...Typ L (Fe-CuNi 0... +680°C)&#13;&#10;9...Typ U (Cu-CuNi 0... +590°C)&#13;&#10;10..Analog In (0 - 40000µV)"/>
		<Client Name="TMP_4RefSensor" Required="false" Internal="false" DefValue="0" Comment="Select reference KTY input for temperatur compensation:&#13;&#10;0..KTY_1&#13;&#10;1..KTY_2&#13;&#10;2..internal KTY&#13;&#10;"/>
		<Client Name="TMP_4Select" Required="false" Internal="false" Comment="This client selects the thermocouple element for the temperature input&#13;&#10;0...Typ J (Fe-CuNi  0... +690°C)&#13;&#10;1...Typ K (NiCr-Ni  0... +940°C)&#13;&#10;2...Typ T (Cu-CuNi  0... +400°C)&#13;&#10;3...Typ E (NiCr-CuNi  0... +520°C)&#13;&#10;4...Typ N (NiCrSi-NiSi 0...+1080°C)&#13;&#10;5...Typ S (Pt10Rh-Pt 0...+1760°C)&#13;&#10;6...Typ R (Pt13Rh-Pt 0...+1760°C)&#13;&#10;7...Typ B (Pt30Rh-Pt6Rh 0...+1820°C)&#13;&#10;8...Typ L (Fe-CuNi 0... +680°C)&#13;&#10;9...Typ U (Cu-CuNi 0... +590°C)&#13;&#10;10..Analog In (0 - 40000µV)"/>
		<Client Name="TMP_5RefSensor" Required="false" Internal="false" DefValue="0" Comment="Select reference KTY input for temperatur compensation:&#13;&#10;0..KTY_1&#13;&#10;1..KTY_2&#13;&#10;2..internal KTY&#13;&#10;"/>
		<Client Name="TMP_5Select" Required="false" Internal="false" Comment="This client selects the thermocouple element for the temperature input&#13;&#10;0...Typ J (Fe-CuNi  0... +690°C)&#13;&#10;1...Typ K (NiCr-Ni  0... +940°C)&#13;&#10;2...Typ T (Cu-CuNi  0... +400°C)&#13;&#10;3...Typ E (NiCr-CuNi  0... +520°C)&#13;&#10;4...Typ N (NiCrSi-NiSi 0...+1080°C)&#13;&#10;5...Typ S (Pt10Rh-Pt 0...+1760°C)&#13;&#10;6...Typ R (Pt13Rh-Pt 0...+1760°C)&#13;&#10;7...Typ B (Pt30Rh-Pt6Rh 0...+1820°C)&#13;&#10;8...Typ L (Fe-CuNi 0... +680°C)&#13;&#10;9...Typ U (Cu-CuNi 0... +590°C)&#13;&#10;10..Analog In (0 - 40000µV)"/>
		<Client Name="TMP_6RefSensor" Required="false" Internal="false" DefValue="0" Comment="Select reference KTY input for temperatur compensation:&#13;&#10;0..KTY_1&#13;&#10;1..KTY_2&#13;&#10;2..internal KTY&#13;&#10;"/>
		<Client Name="TMP_6Select" Required="false" Internal="false" Comment="This client selects the thermocouple element for the temperature input&#13;&#10;0...Typ J (Fe-CuNi  0... +690°C)&#13;&#10;1...Typ K (NiCr-Ni  0... +940°C)&#13;&#10;2...Typ T (Cu-CuNi  0... +400°C)&#13;&#10;3...Typ E (NiCr-CuNi  0... +520°C)&#13;&#10;4...Typ N (NiCrSi-NiSi 0...+1080°C)&#13;&#10;5...Typ S (Pt10Rh-Pt 0...+1760°C)&#13;&#10;6...Typ R (Pt13Rh-Pt 0...+1760°C)&#13;&#10;7...Typ B (Pt30Rh-Pt6Rh 0...+1820°C)&#13;&#10;8...Typ L (Fe-CuNi 0... +680°C)&#13;&#10;9...Typ U (Cu-CuNi 0... +590°C)&#13;&#10;10..Analog In (0 - 40000µV)"/>
		<Client Name="TMP_7RefSensor" Required="false" Internal="false" DefValue="0" Comment="Select reference KTY input for temperatur compensation:&#13;&#10;0..KTY_1&#13;&#10;1..KTY_2&#13;&#10;2..internal KTY&#13;&#10;"/>
		<Client Name="TMP_7Select" Required="false" Internal="false" Comment="This client selects the thermocouple element for the temperature input&#13;&#10;0...Typ J (Fe-CuNi  0... +690°C)&#13;&#10;1...Typ K (NiCr-Ni  0... +940°C)&#13;&#10;2...Typ T (Cu-CuNi  0... +400°C)&#13;&#10;3...Typ E (NiCr-CuNi  0... +520°C)&#13;&#10;4...Typ N (NiCrSi-NiSi 0...+1080°C)&#13;&#10;5...Typ S (Pt10Rh-Pt 0...+1760°C)&#13;&#10;6...Typ R (Pt13Rh-Pt 0...+1760°C)&#13;&#10;7...Typ B (Pt30Rh-Pt6Rh 0...+1820°C)&#13;&#10;8...Typ L (Fe-CuNi 0... +680°C)&#13;&#10;9...Typ U (Cu-CuNi 0... +590°C)&#13;&#10;10..Analog In (0 - 40000µV)"/>
		<Client Name="TMP_8RefSensor" Required="false" Internal="false" DefValue="0" Comment="Select reference KTY input for temperatur compensation:&#13;&#10;0..KTY_1&#13;&#10;1..KTY_2&#13;&#10;2..internal KTY&#13;&#10;"/>
		<Client Name="TMP_8Select" Required="false" Internal="false" Comment="This client selects the thermocouple element for the temperature input&#13;&#10;0...Typ J (Fe-CuNi  0... +690°C)&#13;&#10;1...Typ K (NiCr-Ni  0... +940°C)&#13;&#10;2...Typ T (Cu-CuNi  0... +400°C)&#13;&#10;3...Typ E (NiCr-CuNi  0... +520°C)&#13;&#10;4...Typ N (NiCrSi-NiSi 0...+1080°C)&#13;&#10;5...Typ S (Pt10Rh-Pt 0...+1760°C)&#13;&#10;6...Typ R (Pt13Rh-Pt 0...+1760°C)&#13;&#10;7...Typ B (Pt30Rh-Pt6Rh 0...+1820°C)&#13;&#10;8...Typ L (Fe-CuNi 0... +680°C)&#13;&#10;9...Typ U (Cu-CuNi 0... +590°C)&#13;&#10;10..Analog In (0 - 40000µV)"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="BeiWol"/>
		<Dokumentation Revision="1.34" Date="08.06.2018" Author="RamAnd" Company="Sigmatek" Description="LASAL Hardware Description (.lhd) file has been updated."/>
		<Dokumentation Revision="1.33" Date="23.01.2018" Author="RamAnd" Company="Sigmatek" Description="Log messages have been standardized for easier maintenance, easier use in any class and to allow spam filtering. Code for the logging functions is now only located in HwControl."/>
		<Dokumentation Revision="1.32" Date="29.09.2017" Author="ZoePat" Company="Sigmatek" Description="Added temperature compensation by internal KTY for Firmware 2.0 and HW 3.0.&#13;&#10;Added MessageCounter for Firmware 2.0.&#13;&#10;Corrected error with signed-overflow for µV values."/>
		<Dokumentation Revision="1.31" Date="16.05.2017" Author="RamAnd" Company="Sigmatek" Description="When adding an SDO (i.e. via ReadSPIData) from background priority it was possible that the adding process got interrupted by receiving the answer to this SDO which is handled in cyclic priority. In the error case the answer was unexpected and therefore ignored. Then the class signals a timeout while waiting for the answer, which already arrived before waiting for it. Added mutex and changed instruction order to prevent this error."/>
		<Dokumentation Revision="1.30" Date="12.07.2016" Author="SeiChr" Company="Sigmatek" Description="Added Values for the total Current calculation. SA 31571"/>
		<Dokumentation Revision="1.29" Date="01.03.2016" Author="EisMic" Company="Sigmatek" Description="Corrected BoundExceed Error in base class at Write method of LEDControl Server when Place = LSL_DEACTIVATED."/>
		<Dokumentation Revision="1.27" Date="17.06.2015" Author="EisMic" Company="Sigmatek" Description="The servers FPGAVersion, SerialNo, Device ID and status and input servers are now not reset anymore when the module is disconnected."/>
		<Dokumentation Revision="1.26" Date="16.04.2015" Author="EisMic&#13;&#10;LanSte" Company="Sigmatek" Description="Added support for visualisation in graphical hardware editor.&#13;&#10;Added support for calculating resources for graphical hardware editor."/>
		<Dokumentation Revision="1.25" Date="17.03.2015" Author="RamAnd" Company="Sigmatek" Description="Added HW Version for sdias clients."/>
		<Dokumentation Revision="1.24" Date="11.02.2015" Author="PieSte" Company="Sigmatek" Description="Corrected read spi data for hardwaretree in methode GetSPIDataFromID from baseclass."/>
		<Dokumentation Revision="1.23" Date="18.11.2014" Author="PieSte" Company="Sigmatek" Description="Added possibility  to read more data from spi flash then one sdo access.&#13;&#10;Set methode GetDeviceID to global.&#13;&#10;Add methode to calculate checksum of spi flash."/>
		<Dokumentation Revision="1.22" Date="04.07.2014" Author="EisMic" Company="Sigmatek" Description="Added support for reading hardware diagnosis and hardwaretree entry."/>
		<Dokumentation Revision="1.21" Date="07.03.2014" Author="EisMic" Company="Sigmatek" Description="Corrected comment of server Firmwareversion"/>
		<Dokumentation Revision="1.20" Date="20.01.2014" Author="PieSte" Company="Sigmatek" Description="Read Client Required and Place in Init SdiasBase"/>
		<Dokumentation Revision="1.10" Date="05.12.2013" Author="RamAnd" Company="Sigmatek" Description="Changed login mechanism to sdias manager class to be independent of bus accesses."/>
		<Dokumentation Revision="1.0" Date="31.07.2013" Author="RamAnd" Company="Sigmatek" Description="First library version"/>
	</RevDoku>
	<Network Name="AI088">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{2E2B51EE-2A24-4C23-AD0E-096F3EA733DA}"
				Class      = "SdiasBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassState"/>
					<Server Name="DeviceID"/>
					<Server Name="FPGAVersion"/>
					<Server Name="HwVersion"/>
					<Server Name="LEDControl" Value="0"/>
					<Server Name="RetryCounter"/>
					<Server Name="SDOState"/>
					<Server Name="SerialNo"/>
					<Client Name="Place" Value="0"/>
					<Client Name="Required" Value="1"/>
					<Client Name="SdiasIn"/>
					<Client Name="ToStdLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassState" Destination="_base.ClassState" Vertices="(804,210),(632,210),"/>
			<Connection Source="this.DeviceID" Destination="_base.DeviceID" Vertices="(804,270),(632,270),"/>
			<Connection Source="this.SerialNo" Destination="_base.SerialNo" Vertices="(804,450),(632,450),"/>
			<Connection Source="this.RetryCounter" Destination="_base.RetryCounter" Vertices="(804,510),(632,510),"/>
			<Connection Source="this.LEDControl" Destination="_base.LEDControl" Vertices="(804,570),(632,570),"/>
			<Connection Source="_base.SdiasIn" Destination="this.SdiasIn" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.Place" Destination="this.Place" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.Required" Destination="this.Required" Vertices="(218,330),(38,330),"/>
			<Connection Source="this.FPGAVersion" Destination="_base.FPGAVersion" Vertices="(804,330),(632,330),"/>
			<Connection Source="this.HwVersion" Destination="_base.HwVersion" Vertices="(804,390),(632,390),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using SdiasBase

AI088 : CLASS
: SdiasBase
	TYPE
	  t_SpecialPurposeFWge20 : BSINT
	  [
	    1 PmbModus,
	    2 BootloaderUpdateRequ,
	    3 EnableMessageCounter,
	  ];
#pragma pack(push, 1)
	  t_StandardModusFWge20 : STRUCT
	    TmpSelect_1_2 : USINT;
	    TmpSelect_3_4 : USINT;
	    TmpSelect_5_6 : USINT;
	    TmpSelect_7_8 : USINT;
	    TmpRefSensor : BSINT
	    [
	      1 TMP_1,
	      2 TMP_2,
	      3 TMP_3,
	      4 TMP_4,
	      5 TMP_5,
	      6 TMP_6,
	      7 TMP_7,
	      8 TMP_8,
	    ];
	    TmpRefSensorInt : BSINT
	    [
	      1 TMP_1,
	      2 TMP_2,
	      3 TMP_3,
	      4 TMP_4,
	      5 TMP_5,
	      6 TMP_6,
	      7 TMP_7,
	      8 TMP_8,
	    ];
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_CfgFirmware : STRUCT
	    CRC : UINT;
	    DataLength : UINT;
	    Info : t_SpecialPurposeFWge20;
	    MessageCounter : USINT;
	    StandardModus : t_StandardModusFWge20;
	  END_STRUCT;
#pragma pack(pop)
	  t_Error : BINT
	  [
	    1 CableBreakTMP_1,
	    2 CableBreakTMP_2,
	    3 CableBreakTMP_3,
	    4 CableBreakTMP_4,
	    5 CableBreakTMP_5,
	    6 CableBreakTMP_6,
	    7 CableBreakTMP_7,
	    8 CableBreakTMP_8,
	    9 CableBreakKTY_1,
	    10 CableBreakKTY_2,
	    11 ShortCircuitKTY_1,
	    12 ShortCircuitKTY_2,
	    16 ErrorIn,
	  ];
	  t_InitSSW :
	  (
	    _InitGetFWVersion:=0,
	    _InitVariables:=1,
	    _ConfigModule:=2,
	    _ReadState:=3,
	    _Finish:=4,
	    _InitError:=5
	  )$UDINT;
#pragma pack(push, 1)
	  t_ReadData : STRUCT
	    Status : t_b_SdiasFWState;
	    TmpIn1 : INT;
	    TmpIn2 : INT;
	    TmpIn3 : INT;
	    TmpIn4 : INT;
	    TmpIn5 : INT;
	    TmpIn6 : INT;
	    TmpIn7 : INT;
	    TmpIn8 : INT;
	    KtyIn1 : INT;
	    KtyIn2 : INT;
	    Error : t_Error;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_ReadDataInt : STRUCT
	    IntKtyIn1 : INT;
	    IntKtyIn2 : INT;
	  END_STRUCT;
#pragma pack(pop)
	  t_ResponseState :
	  (
	    _idle,
	    _wait,
	    _valid
	  )$UDINT;
	  t_SpecialPurpose : BSINT
	  [
	    1 PmbModus,
	    2 BootloaderUpdateRequ,
	  ];
#pragma pack(push, 1)
	  t_sReadAccessTimeOffset : STRUCT
	    AccessHandle : UDINT;
	    pControlByte : t_SDIAS_pControlByte;
	    pStateByte : t_SDIAS_pStateByte;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_StandardModus : STRUCT
	    TmpSelect_1_2 : USINT;  //! <Type Comment="Cut off frequency for analog in low pass filter" Name="t_StandardModus.TmpSelect_1_2"/>
	    TmpSelect_3_4 : USINT;  //! <Type Comment="Cut off frequency for analog in low pass filter" Name="t_StandardModus.TmpSelect_3_4"/>
	    TmpSelect_5_6 : USINT;  //! <Type Comment="Cut off frequency for analog in low pass filter" Name="t_StandardModus.TmpSelect_5_6"/>
	    TmpSelect_7_8 : USINT;  //! <Type Comment="Cut off frequency for analog in low pass filter" Name="t_StandardModus.TmpSelect_7_8"/>
	    TmpRefSensor : BSINT  //! <Type Comment="Select intern reference input for compensating temperature input&#13;&#10;0..KTY1&#13;&#10;1..KTY2" Name="t_StandardModus.TmpRefSensor"/>
	    [
	      1 TMP_1,
	      2 TMP_2,
	      3 TMP_3,
	      4 TMP_4,
	      5 TMP_5,
	      6 TMP_6,
	      7 TMP_7,
	      8 TMP_8,
	    ];
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_StateFirmware : STRUCT
	    CRC : UINT;
	    DataLength : UINT;
	    FirmwareVersion : UINT;
	    MessageCounter : USINT;
	    reserved : USINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_ThermoTyp :
	  (
	    _J,
	    _K,
	    _T,
	    _E,
	    _N,
	    _S,
	    _R,
	    _B,
	    _L,
	    _U
	  )$UDINT;
	END_TYPE
  //Servers:
	FirmwareVersion 	: SvrCh_HDINT;
	FWErrorBits 	: SvrCh_t_s_SdiasFWStateStandard_PTofCls_SdiasBase;
	TMP_1 	: SvrCh_DINT;
	TMP_2 	: SvrCh_DINT;
	TMP_3 	: SvrCh_DINT;
	TMP_4 	: SvrCh_DINT;
	TMP_5 	: SvrCh_DINT;
	TMP_6 	: SvrCh_DINT;
	TMP_7 	: SvrCh_DINT;
	TMP_8 	: SvrCh_DINT;
	KTY_1 	: SvrCh_DINT;
	KTY_2 	: SvrCh_DINT;
	KTY_Int_1 	: SvrCh_DINT;
	KTY_Int_2 	: SvrCh_DINT;
	CableBreak 	: SvrCh_BDINT;
	ShortCircuit 	: SvrCh_BDINT;
  //Clients:
	TMP_1Select 	: CltCh_DINT;
	TMP_1RefSensor 	: CltCh_DINT;
	TMP_2Select 	: CltCh_DINT;
	TMP_2RefSensor 	: CltCh_DINT;
	TMP_3Select 	: CltCh_DINT;
	TMP_3RefSensor 	: CltCh_DINT;
	TMP_4Select 	: CltCh_DINT;
	TMP_4RefSensor 	: CltCh_DINT;
	TMP_5Select 	: CltCh_DINT;
	TMP_5RefSensor 	: CltCh_DINT;
	TMP_6Select 	: CltCh_DINT;
	TMP_6RefSensor 	: CltCh_DINT;
	TMP_7Select 	: CltCh_DINT;
	TMP_7RefSensor 	: CltCh_DINT;
	TMP_8Select 	: CltCh_DINT;
	TMP_8RefSensor 	: CltCh_DINT;
  //Variables:
		eInitSSW 	: t_InitSSW;			//! <Variable Comment="Initialisation Statemachine." Name="eInitSSW"/>
		eInitSSWErrorStep 	: t_InitSSW;			//! <Variable Comment="Initialisation Statemachine in case of an Error." Name="eInitSSWErrorStep"/>
		eResponseState 	: t_ResponseState;			//! <Variable Comment="Actual Response State of the SDO Communication." Name="eResponseState"/>
		pReadData 	: ^t_ReadData;			//! <Variable Comment="Read-Data from the Module." Name="pReadData"/>
		sStateFirmware 	: t_StateFirmware;			//! <Variable Comment="FW Informations of the Module." Name="sStateFirmware"/>
		udSDOTimeout 	: UDINT;			//! <Variable Comment="Timeout for SDO-Communication." Name="udSDOTimeout"/>
		sCfgFirmware 	: t_CfgFirmware;			//! <Variable Comment="Configuration Data for the Firmware." Name="sCfgFirmware"/>
		sReadAccessCycInt 	: t_sReadAccessTimeOffset;
		ud_WaitForAccessHandle 	: UDINT;
		pReadDataInt 	: ^t_ReadDataInt;
		b_InternalKTYConfigured 	: BOOL;
  //Functions:
				//! <Function Comment="Constructor of Class." Name="AI088"/>
	FUNCTION AI088
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="Realtime Update Methode which runs in PreScan." Name="UpdateRt"/>
	FUNCTION VIRTUAL GLOBAL UpdateRt;
	
	FUNCTION VIRTUAL GLOBAL AddAccesses
		VAR_OUTPUT
			eModuleInitState 	: iprStates;
		END_VAR;
				//! <Function Comment="Methode is called if this Module gets connected." Name="ConnectEvent"/>
	FUNCTION VIRTUAL GLOBAL ConnectEvent;
				//! <Function Comment="Methode is called if this Module gets disconnected." Name="DisconnectEvent"/>
	FUNCTION VIRTUAL GLOBAL DisconnectEvent;
				//! <Function Comment="Methode should be used to run a Statemachine to Initialize the Module." Name="InitModule"/>
	FUNCTION VIRTUAL GLOBAL InitModule
		VAR_OUTPUT
			eModuleInitState 	: iprStates;			//! <Variable Comment="Return BUSY until the Initialisation is finished." Name="InitModule.eModuleInitState"/>
		END_VAR;
				//! <Function Comment="This Methode is used, to check the DeviceID of the Module." Name="CheckDeviceID"/>
	FUNCTION VIRTUAL GLOBAL CheckDeviceID
		VAR_INPUT
			udID2Check 	: UDINT;			//! <Variable Comment="Device ID of connected Module." Name="CheckDeviceID.udID2Check"/>
		END_VAR
		VAR_OUTPUT
			bIsOK 	: BOOL;			//! <Variable Comment="FALSE = Wrong DeviceID for Module&#13;&#10;TRUE  = DeviceID of Module is correct" Name="CheckDeviceID.bIsOK"/>
		END_VAR;
				//! <Function Comment="Methode to receive the Response in case of SDO-Communication." Name="ReceiveSDOResponse"/>
	FUNCTION VIRTUAL ReceiveSDOResponse
		VAR_INPUT
			eCommand 	: t_SDIAS_SDO_Cmd;			//! <Variable Comment="Type of SDO-Command" Name="ReceiveSDOResponse.eCommand"/>
			hOffset 	: HINT;			//! <Variable Comment="Address-Offset in Module." Name="ReceiveSDOResponse.hOffset"/>
			usLength 	: USINT;			//! <Variable Comment="Length of Data." Name="ReceiveSDOResponse.usLength"/>
			eResult 	: iprStates;			//! <Variable Comment="State of SDO-Communication." Name="ReceiveSDOResponse.eResult"/>
			pResponseBuffer 	: ^USINT;			//! <Variable Comment="Pointer of ResponseBuffer, where the SDO-Data is located." Name="ReceiveSDOResponse.pResponseBuffer"/>
			ResponseLength 	: USINT;			//! <Variable Comment="Size of the ResponseBuffer." Name="ReceiveSDOResponse.ResponseLength"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;			//! <Variable Comment="Indicates if the Methode was successful." Name="ReceiveSDOResponse.ret_code"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetTaskCfg
		VAR_OUTPUT
			TaskCfg 	: BDINT;			//! <Variable Comment="Select which tasks will be available for this module:&#13;&#10;Bit0..Realtime PreScan&#13;&#10;Bit1..Realtime PostScan&#13;&#10;Bit2..Cyclic&#13;&#10;&#13;&#10;e.g. if only realtime postscan is needed:&#13;&#10;2#010" Name="GetTaskCfg.TaskCfg"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetDeviceID
		VAR_OUTPUT
			output 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GetFWVersion
		VAR_INPUT
			pData 	: ^CHAR;
			Length 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB AI088::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_AI088
1$UINT, 34$UINT, (SIZEOF(::AI088))$UINT, 
16$UINT, 16$UINT, 0$UINT, 
TO_UDINT(1583050918), "AI088", //Class
TO_UDINT(3175101883), "SdiasBase", 1$UINT, 58$UINT, //Baseclass
//Servers:
(::AI088.FirmwareVersion.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(389440282), "FirmwareVersion", 
(::AI088.FWErrorBits.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3888132073), "FWErrorBits", 
(::AI088.TMP_1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1653502439), "TMP_1", 
(::AI088.TMP_2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4219936861), "TMP_2", 
(::AI088.TMP_3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2357203147), "TMP_3", 
(::AI088.TMP_4.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(316966248), "TMP_4", 
(::AI088.TMP_5.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1709422078), "TMP_5", 
(::AI088.TMP_6.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4243252292), "TMP_6", 
(::AI088.TMP_7.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2347619538), "TMP_7", 
(::AI088.TMP_8.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(458410307), "TMP_8", 
(::AI088.KTY_1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2734576174), "KTY_1", 
(::AI088.KTY_2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1006044052), "KTY_2", 
(::AI088.KTY_Int_1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(156741877), "KTY_Int_1", 
(::AI088.KTY_Int_2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2422137167), "KTY_Int_2", 
(::AI088.CableBreak.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3580028836), "CableBreak", 
(::AI088.ShortCircuit.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(265202714), "ShortCircuit", 
//Clients:
(::AI088.TMP_1Select.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(841748805), "TMP_1Select", 
(::AI088.TMP_1RefSensor.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2718941907), "TMP_1RefSensor", 
(::AI088.TMP_2Select.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(63179736), "TMP_2Select", 
(::AI088.TMP_2RefSensor.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1228437968), "TMP_2RefSensor", 
(::AI088.TMP_3Select.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2779971692), "TMP_3Select", 
(::AI088.TMP_3RefSensor.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2801406702), "TMP_3RefSensor", 
(::AI088.TMP_4Select.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1611939554), "TMP_4Select", 
(::AI088.TMP_4RefSensor.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1143343511), "TMP_4RefSensor", 
(::AI088.TMP_5Select.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3328390486), "TMP_5Select", 
(::AI088.TMP_5RefSensor.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2883871401), "TMP_5RefSensor", 
(::AI088.TMP_6Select.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(4153094091), "TMP_6Select", 
(::AI088.TMP_6RefSensor.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1087625642), "TMP_6RefSensor", 
(::AI088.TMP_7Select.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1375478911), "TMP_7Select", 
(::AI088.TMP_7RefSensor.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2937172628), "TMP_7RefSensor", 
(::AI088.TMP_8Select.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2813613206), "TMP_8Select", 
(::AI088.TMP_8RefSensor.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1578821913), "TMP_8RefSensor", 
END_FUNCTION


#define USER_CNT_AI088 20

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_AI088] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION AI088::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= SdiasBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= SdiasBase::ClassState.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, SdiasBase::ClassState.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_AI088;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #UpdateRt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #AddAccesses();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #ConnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #DisconnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #InitModule();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #CheckDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #ReceiveSDOResponse();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #GetTaskCfg();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #GetDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #GetFWVersion();

#pragma warning (default : 74)
	SdiasBase::ClassState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SdiasBase::ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= AI088();

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION VIRTUAL GLOBAL AI088::UpdateRt
  VAR
  	TempReadData    : t_ReadData;
    TempReadDataInt : t_ReadDataInt; 
    dtmpVal         : DINT;
  END_VAR

  TempReadData := pReadData^;
  
  // set status
  FWErrorBits.ErrorBits := TempReadData.Status;  
  CableBreak            := TempReadData.Error and AI088_CABLE_BREAK_MASK;       // Mask Cable break Bits
  ShortCircuit          := (TempReadData.Error shr (AI088_NUMBER_OF_TMP_INPUT)) and AI088_SHORT_CIRCUIT_MASK;  // Shift to short circuit Bits

  // for TMP_XSelect = 10 (analog in - mode): data coming from FW may be originally negative 
  // but are sent as UINT type - so negative values are sent as very big UINT values
  if (TempReadData.Error.CableBreakTMP_1) then
    TMP_1 := AI088_INVALID_VALUE;
  else
    if TMP_1Select <> 10 then
      TMP_1 := TempReadData.TmpIn1;
    else // analog in - mode
      dtmpVal := (TempReadData.TmpIn1)$UINT;
      if dtmpVal > AI088_THRESHOLD_NEG_VALS then
        dtmpVal := dtmpVal - AI088_SUBTRACT_FOR_INT;
      end_if;
      TMP_1 := dtmpVal;
    end_if;
  end_if;
  if (TempReadData.Error.CableBreakTMP_2) then
    TMP_2 := AI088_INVALID_VALUE;
  else
    if TMP_2Select <> 10 then
      TMP_2 := TempReadData.TmpIn2;
    else // analog in - mode
      dtmpVal := (TempReadData.TmpIn2)$UINT;
      if dtmpVal > AI088_THRESHOLD_NEG_VALS then
        dtmpVal := dtmpVal - AI088_SUBTRACT_FOR_INT;
      end_if;
      TMP_2 := dtmpVal;
    end_if;
  end_if;
  if (TempReadData.Error.CableBreakTMP_3) then
    TMP_3 := AI088_INVALID_VALUE;
  else
    if TMP_3Select <> 10 then
      TMP_3 := TempReadData.TmpIn3;
    else // analog in - mode
      dtmpVal := (TempReadData.TmpIn3)$UINT;
      if dtmpVal > AI088_THRESHOLD_NEG_VALS then
        dtmpVal := dtmpVal - AI088_SUBTRACT_FOR_INT;
      end_if;
      TMP_3 := dtmpVal;
    end_if;
  end_if;
  if (TempReadData.Error.CableBreakTMP_4) then
    TMP_4 := AI088_INVALID_VALUE;
  else
    if TMP_4Select <> 10 then
      TMP_4 := TempReadData.TmpIn4;
    else // analog in - mode
      dtmpVal := (TempReadData.TmpIn4)$UINT;
      if dtmpVal > AI088_THRESHOLD_NEG_VALS then
        dtmpVal := dtmpVal - AI088_SUBTRACT_FOR_INT;
      end_if;
      TMP_4 := dtmpVal;
    end_if;
  end_if;
  if (TempReadData.Error.CableBreakTMP_5) then
    TMP_5 := AI088_INVALID_VALUE;
  else
    if TMP_5Select <> 10 then
      TMP_5 := TempReadData.TmpIn5;
    else // analog in - mode
      dtmpVal := (TempReadData.TmpIn5)$UINT;
      if dtmpVal > AI088_THRESHOLD_NEG_VALS then
        dtmpVal := dtmpVal - AI088_SUBTRACT_FOR_INT;
      end_if;
      TMP_5 := dtmpVal;
    end_if;
  end_if;
  if (TempReadData.Error.CableBreakTMP_6) then
    TMP_6 := AI088_INVALID_VALUE;
  else
    if TMP_6Select <> 10 then
      TMP_6 := TempReadData.TmpIn6;
    else // analog in - mode
      dtmpVal := (TempReadData.TmpIn6)$UINT;
      if dtmpVal > AI088_THRESHOLD_NEG_VALS then
        dtmpVal := dtmpVal - AI088_SUBTRACT_FOR_INT;
      end_if;
      TMP_6 := dtmpVal;
    end_if;
  end_if;
  if (TempReadData.Error.CableBreakTMP_7) then
    TMP_7 := AI088_INVALID_VALUE;
  else
    if TMP_7Select <> 10 then
      TMP_7 := TempReadData.TmpIn7;
    else // analog in - mode
      dtmpVal := (TempReadData.TmpIn7)$UINT;
      if dtmpVal > AI088_THRESHOLD_NEG_VALS then
        dtmpVal := dtmpVal -AI088_SUBTRACT_FOR_INT;
      end_if;
      TMP_7 := dtmpVal;
    end_if;
  end_if;
  if (TempReadData.Error.CableBreakTMP_8) then
    TMP_8 := AI088_INVALID_VALUE;
  else
    if TMP_8Select <> 10 then
      TMP_8 := TempReadData.TmpIn8;
    else // analog in - mode
      dtmpVal := (TempReadData.TmpIn8)$UINT;
      if dtmpVal > AI088_THRESHOLD_NEG_VALS then
        dtmpVal := dtmpVal - AI088_SUBTRACT_FOR_INT;
      end_if;
      TMP_8 := dtmpVal;
    end_if;
  end_if;

  if (TempReadData.Error.CableBreakKTY_1) | (TempReadData.Error.ShortCircuitKTY_1) then
    KTY_1 := AI088_INVALID_VALUE;
  else
    KTY_1 := TempReadData.KtyIn1;  
  end_if;
  if (TempReadData.Error.CableBreakKTY_2) | (TempReadData.Error.ShortCircuitKTY_2) then
    KTY_2 := AI088_INVALID_VALUE;
  else
    KTY_2 := TempReadData.KtyIn2;  
  end_if;

  if b_InternalKTYConfigured then
    TempReadDataInt := pReadDataInt^;
    // internal temp ref sensor
    KTY_Int_1 := TempReadDataInt.IntKtyIn1;
    KTY_Int_2 := TempReadDataInt.IntKtyIn2;
  end_if;
    
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI088::ConnectEvent

  if DefaultAccesses.ReadAccess.pControlByte then
    // memory area of additional access
    pReadData := DefaultAccesses.ReadAccess.pData$^t_ReadData;

    DefaultAccesses.ReadAccess.pControlByte^.EnableDO := TRUE;
  else
    eInitState := _DOHandleInvalid;
    return;
  end_if;  
   
  eInitSSW        := _InitGetFWVersion;
  eResponseState  := _idle;
  eInitState      := _NotInitialized;

END_FUNCTION


FUNCTION VIRTUAL AI088::ReceiveSDOResponse
	VAR_INPUT
		eCommand 	: t_SDIAS_SDO_Cmd;
		hOffset 	: HINT;
		usLength 	: USINT;
		eResult 	: iprStates;
		pResponseBuffer 	: ^USINT;
		ResponseLength 	: USINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR
  
  ret_code := SdiasBase::ReceiveSDOResponse(eCommand, hOffset, usLength, eResult, pResponseBuffer, ResponseLength);

  // spi access from baseclass                                         
  if bSDOResponseHandle = TRUE then
    return;
  end_if;   
  
  if eResult = READY then    
    case eCommand of
      SDIAS_SDO_CMD_MEM_WRITE:
        case hOffset of
          AI088_ADDR_CFG_FIRMWARE:
            if eResponseState = _wait then
              eResponseState := _valid;
            end_if;           
        end_case;
        
      SDIAS_SDO_CMD_MEM_READ:
        case hOffset of      
          AI088_ADDR_STATE_FIRMWARE:
            if eResponseState = _wait then
              eResponseState := _valid;
            end_if;
            sStateFirmware := pResponseBuffer^$t_StateFirmware;
        end_case;
    end_case;
    
    if eResponseState <> _valid then
      LogError("@ZZZZ (AI088::ReceiveSDOResponse) Error in response data of SDO");
      eInitSSW := _InitError;      
    end_if;
  else
    case eCommand of
      SDIAS_SDO_CMD_MEM_WRITE:
        LogError("@ZZZZ (AI088::ReceiveSDOResponse) Error while writing the firmware configuration");
      SDIAS_SDO_CMD_MEM_READ:
        LogError("@ZZZZ (AI088::ReceiveSDOResponse) Error while waiting for the firmware state");
    end_case;
    eInitSSW := _InitError;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI088::InitModule
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
  VAR
  	TmpRetcode      :iprStates;
  END_VAR
  
  eModuleInitState := BUSY;

  CASE eInitSSW OF  
    //Get FW Version
    //***************************************************************************    
    _InitGetFWVersion:    
      //Statemachine for SDO-Communication
      case eResponseState of      
        //*****************************************************************************************
        _idle:        
          //Start SDO-Command
          TmpRetcode  := StartReadSDO(  hOffset   :=AI088_ADDR_STATE_FIRMWARE,
                                        usLength  :=sizeof(t_StateFirmware),
                                        eCommand  :=SDIAS_SDO_CMD_MEM_READ);
                                        
          //Evaluate Returncode
          if TmpRetcode = READY then
            //Timestamp for TimeoutCheck
            udSDOTimeout      := ops.tAbsolute;
            eResponseState := _wait;
          //Error occured 
          elsif TmpRetcode = ERROR then
            eModuleInitState := ERROR;
            LogError("@ZZZZ (AI088::InitModule) Failed to add read SDO for firmware info");
            eInitState := _NoMem;
          end_if;

        //*****************************************************************************************
        _wait:          
          //Timeout-Check
          if ((ops.tAbsolute - udSDOTimeout) > AI088_SDO_RESPONSE_TIMEOUT) then          
            LogError("@ZZZZ (AI088::InitModule) SDO Response timeout read state");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW := _InitError;            
          end_if;
          
        //*****************************************************************************************
        _valid:
          // Check for correct length, allow old and new datalength
          if  (sStateFirmware.DataLength = sizeof(t_StateFirmware) - sizeof(t_StateFirmware.CRC) - sizeof(t_StateFirmware.DataLength)) |
              (sStateFirmware.DataLength = sizeof(t_StateFirmware) - sizeof(t_StateFirmware.CRC) - sizeof(t_StateFirmware.DataLength) - sizeof(t_StateFirmware.MessageCounter) - sizeof(t_StateFirmware.reserved)) then

            //Check CRC
            if (sStateFirmware.CRC = CheckSum_16(pData:= #sStateFirmware.FirmwareVersion,
                                            uiDataLength:= sStateFirmware.DataLength,
                                            uiCrcStart:=16#FFFF)) then

              eInitSSW        := _InitVariables;
              eResponseState  := _idle;   
              
              //Write Version of FW to Server
              FirmwareVersion := (sStateFirmware.FirmwareVersion and 16#0000FFFF)$HDINT;
            else
              eModuleInitState := ERROR;
              LogError("@ZZZZ (AI088::InitModule - _InitGetFWVersion) Invalid checksum at firmware info");
              eInitState := _ClientNotready;
            end_if;
          else
            eModuleInitState := ERROR;
            LogError("@ZZZZ (AI088::InitModule - _InitGetFWVersion) Invalid length at firmware info");
            eInitState := _ClientNotready;
          end_if;
      end_case;
      
//**********************************************************************************************************************************************************
    _InitVariables:
      TMP_1Select := TMP_1Select.Read() and 16#FF;
      TMP_2Select := TMP_2Select.Read() and 16#FF;
      TMP_3Select := TMP_3Select.Read() and 16#FF;
      TMP_4Select := TMP_4Select.Read() and 16#FF;
      TMP_5Select := TMP_5Select.Read() and 16#FF;
      TMP_6Select := TMP_6Select.Read() and 16#FF;
      TMP_7Select := TMP_7Select.Read() and 16#FF;
      TMP_8Select := TMP_8Select.Read() and 16#FF; 
      
      TMP_1RefSensor := TMP_1RefSensor.Read();
      TMP_2RefSensor := TMP_2RefSensor.Read();
      TMP_3RefSensor := TMP_3RefSensor.Read();
      TMP_4RefSensor := TMP_4RefSensor.Read();
      TMP_5RefSensor := TMP_5RefSensor.Read();
      TMP_6RefSensor := TMP_6RefSensor.Read();
      TMP_7RefSensor := TMP_7RefSensor.Read();
      TMP_8RefSensor := TMP_8RefSensor.Read();      
      
      if FirmwareVersion < AI088_FIRMWARE_VERSION_INT_TEMP_REF then
        // TMP_XRefSensor = 0 ... external KTY 1
        // TMP_XRefSensor = 1 ... external KTY 2
        case TMP_1RefSensor of
          0..1: sCfgFirmware.StandardModus.TmpRefSensor.TMP_1  := TMP_1RefSensor$BOOL;
        else
            TMP_1RefSensor := 0;
        end_case;
        case TMP_2RefSensor of
          0..1: sCfgFirmware.StandardModus.TmpRefSensor.TMP_2  := TMP_2RefSensor$BOOL;
        else
            TMP_2RefSensor := 0;
        end_case;
        case TMP_3RefSensor of
          0..1: sCfgFirmware.StandardModus.TmpRefSensor.TMP_3  := TMP_3RefSensor$BOOL;
        else
            TMP_3RefSensor := 0;
        end_case;
        case TMP_4RefSensor of
          0..1: sCfgFirmware.StandardModus.TmpRefSensor.TMP_4  := TMP_4RefSensor$BOOL;
        else
            TMP_4RefSensor := 0;
        end_case;
        case TMP_5RefSensor of
          0..1: sCfgFirmware.StandardModus.TmpRefSensor.TMP_5  := TMP_5RefSensor$BOOL;
        else
            TMP_5RefSensor := 0;
        end_case;
        case TMP_6RefSensor of
          0..1: sCfgFirmware.StandardModus.TmpRefSensor.TMP_6  := TMP_6RefSensor$BOOL;
        else
            TMP_6RefSensor := 0;
        end_case;
        case TMP_7RefSensor of
          0..1: sCfgFirmware.StandardModus.TmpRefSensor.TMP_7  := TMP_7RefSensor$BOOL;
        else
            TMP_7RefSensor := 0;
        end_case;
        case TMP_8RefSensor of
          0..1: sCfgFirmware.StandardModus.TmpRefSensor.TMP_8  := TMP_8RefSensor$BOOL;
        else
            TMP_8RefSensor := 0;
        end_case;
        
        sCfgFirmware.StandardModus.TmpSelect_1_2   := (TMP_2Select$USINT shl 4) or TMP_1Select$USINT;
        sCfgFirmware.StandardModus.TmpSelect_3_4   := (TMP_4Select$USINT shl 4) or TMP_3Select$USINT;
        sCfgFirmware.StandardModus.TmpSelect_5_6   := (TMP_6Select$USINT shl 4) or TMP_5Select$USINT;
        sCfgFirmware.StandardModus.TmpSelect_7_8   := (TMP_8Select$USINT shl 4) or TMP_7Select$USINT;
        
        //Clear Info register
        sCfgFirmware.Info := 0;
        sCfgFirmware.DataLength := sizeof(t_CfgFirmware) - sizeof(t_CfgFirmware.CRC) - sizeof(t_CfgFirmware.DataLength) - 
                                          sizeof(sCfgFirmware.StandardModus.TmpRefSensorInt);
        sCfgFirmware.CRC        := CheckSum_16(pData:=(#sCfgFirmware.Info)$^UINT, uiDataLength:=sCfgFirmware.DataLength, uiCrcStart:=16#FFFF);        
        // internal temp ref sensor not available
        KTY_Int_1 := AI088_INVALID_VALUE;
        KTY_Int_2 := AI088_INVALID_VALUE;
        b_InternalKTYConfigured := FALSE;
        
      else  //Firmware version 2.00 or higher
        // TMP_XRefSensor = 0 ... external KTY 1
        // TMP_XRefSensor = 1 ... external KTY 2
        // TMP_XRefSensor = 2 ... internal KTY
        case TMP_1RefSensor of
          0..1: sCfgFirmware.StandardModus.TmpRefSensor.TMP_1 := TMP_1RefSensor$BOOL;
          2: sCfgFirmware.StandardModus.TmpRefSensorInt.TMP_1 := TRUE;
        else
            sCfgFirmware.StandardModus.TmpRefSensor.TMP_1  := FALSE;
            TMP_1RefSensor := 0;
        end_case;
        case TMP_2RefSensor of
          0..1: sCfgFirmware.StandardModus.TmpRefSensor.TMP_2  := TMP_2RefSensor$BOOL;
          2: sCfgFirmware.StandardModus.TmpRefSensorInt.TMP_2  := TRUE;
        else
            sCfgFirmware.StandardModus.TmpRefSensor.TMP_3  := FALSE;
            TMP_2RefSensor := 0;
        end_case;
        case TMP_3RefSensor of
          0..1: sCfgFirmware.StandardModus.TmpRefSensor.TMP_3  := TMP_3RefSensor$BOOL;
          2: sCfgFirmware.StandardModus.TmpRefSensorInt.TMP_3  := TRUE;
        else
            sCfgFirmware.StandardModus.TmpRefSensor.TMP_3  := FALSE;
            TMP_3RefSensor := 0;
        end_case;
        case TMP_4RefSensor of
          0..1: sCfgFirmware.StandardModus.TmpRefSensor.TMP_4  := TMP_4RefSensor$BOOL;
          2: sCfgFirmware.StandardModus.TmpRefSensorInt.TMP_4  := TRUE;
        else
            sCfgFirmware.StandardModus.TmpRefSensor.TMP_4  := FALSE;
            TMP_4RefSensor := 0;
        end_case;
        case TMP_5RefSensor of
          0..1: sCfgFirmware.StandardModus.TmpRefSensor.TMP_5  := TMP_5RefSensor$BOOL;
          2: sCfgFirmware.StandardModus.TmpRefSensorInt.TMP_5  := TRUE;
        else
            sCfgFirmware.StandardModus.TmpRefSensor.TMP_5  := FALSE;
            TMP_5RefSensor := 0;
        end_case;
        case TMP_6RefSensor of
          0..1: sCfgFirmware.StandardModus.TmpRefSensor.TMP_6  := TMP_6RefSensor$BOOL;
          2: sCfgFirmware.StandardModus.TmpRefSensorInt.TMP_6  := TRUE;
        else
            sCfgFirmware.StandardModus.TmpRefSensor.TMP_6  := FALSE;
            TMP_6RefSensor := 0;
        end_case;
        case TMP_7RefSensor of
          0..1: sCfgFirmware.StandardModus.TmpRefSensor.TMP_7  := TMP_7RefSensor$BOOL;
          2: sCfgFirmware.StandardModus.TmpRefSensorInt.TMP_7  := TRUE;
        else
            sCfgFirmware.StandardModus.TmpRefSensor.TMP_7  := FALSE;
            TMP_7RefSensor := 0;
        end_case;
        case TMP_8RefSensor of
          0..1: sCfgFirmware.StandardModus.TmpRefSensor.TMP_8  := TMP_8RefSensor$BOOL;
          2: sCfgFirmware.StandardModus.TmpRefSensorInt.TMP_8  := TRUE;
        else
            TMP_8RefSensor := 0;
            sCfgFirmware.StandardModus.TmpRefSensor.TMP_8  := FALSE;
        end_case;
        
        sCfgFirmware.StandardModus.TmpSelect_1_2   := (TMP_2Select$USINT shl 4) or TMP_1Select$USINT;
        sCfgFirmware.StandardModus.TmpSelect_3_4   := (TMP_4Select$USINT shl 4) or TMP_3Select$USINT;
        sCfgFirmware.StandardModus.TmpSelect_5_6   := (TMP_6Select$USINT shl 4) or TMP_5Select$USINT;
        sCfgFirmware.StandardModus.TmpSelect_7_8   := (TMP_8Select$USINT shl 4) or TMP_7Select$USINT;
        
        //Clear Info register
        sCfgFirmware.Info                       := 0;
        //enable message counter if new firmware is used.
        sCfgFirmware.Info.EnableMessageCounter  := TRUE;
        
        //Increment message counter and calculate data length
        sCfgFirmware.MessageCounter             += 1;
        
        sCfgFirmware.DataLength := sizeof(t_CfgFirmware) - sizeof(t_CfgFirmware.CRC) - sizeof(t_CfgFirmware.DataLength);
        sCfgFirmware.CRC        := CheckSum_16(pData:=(#sCfgFirmware.Info)$^UINT, uiDataLength:=sCfgFirmware.DataLength, uiCrcStart:=16#FFFF);
        
        if b_InternalKTYConfigured then
          if HwVersion >= AI088_HARDWARE_VERSION_INT_TEMP_REF then
            if sReadAccessCycInt.pControlByte then
              sReadAccessCycInt.pControlByte^.EnableDO := TRUE;
            else
              eModuleInitState := ERROR;
              eInitState := _DOHandleInvalid;
              eInitSSWErrorStep := eInitSSW;
              eInitSSW := _InitError;
            end_if;
          else
            eModuleInitState := ERROR;
            LogError("@ZZZZ (AI088::InitModule) Internal KTY sensor is not supported. A HW-Version with at least 3.0 is required!");
            eInitState := _InvalidConfguration;
            eInitSSWErrorStep := eInitSSW;
            eInitSSW := _InitError; 
          end_if;
        else
          // internal temp ref sensor not available
          KTY_Int_1 := AI088_INVALID_VALUE;
          KTY_Int_2 := AI088_INVALID_VALUE;
          b_InternalKTYConfigured := FALSE;
        end_if;  
      end_if;
      eInitSSW := _ConfigModule;
    
//**********************************************************************************************************************************************************
    _ConfigModule:
      case eResponseState of
        _idle:
          TmpRetcode  := StartWriteSDO(hOffset:=AI088_ADDR_CFG_FIRMWARE, usLength:=sizeof(t_CfgFirmware), pWriteBuffer:=(#sCfgFirmware)$^USINT, eCommand:=SDIAS_SDO_CMD_MEM_WRITE);
          if TmpRetcode = READY then
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= _wait; 
          elsif TmpRetcode = ERROR then
            eModuleInitState := ERROR;
            LogError("@ZZZZ (AI088::InitModule) Failed to add write SDO for firmware configuration");
            eInitState := _NoMem;
          end_if;
          //*****************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > AI088_SDO_RESPONSE_TIMEOUT) then
            LogError("@ZZZZ (AI088::InitModule) SDO Response timeout config module");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW := _InitError;
          end_if;
        //*****************************************************
        _valid:
          eInitSSW        := _ReadState;
          eResponseState  := _idle;
        //*****************************************************
      end_case;
      
//**********************************************************************************************************************************************************
    _ReadState:
      case eResponseState of
        _idle:
          TmpRetcode  := StartReadSDO(hOffset:=AI088_ADDR_STATE_FIRMWARE, usLength:=sizeof(t_StateFirmware), eCommand:=SDIAS_SDO_CMD_MEM_READ);
          if TmpRetcode = READY then
            udSDOTimeout      := ops.tAbsolute;
            eResponseState := _wait; 
          elsif TmpRetcode = ERROR then
            eModuleInitState := ERROR;
            LogError("@ZZZZ (AI088::InitModule) Failed to add read SDO for firmware info");
            eInitState := _NoMem;
          end_if; 
          //*****************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > AI088_SDO_RESPONSE_TIMEOUT) then
            LogError("@ZZZZ (AI088::InitModule) SDO Response timeout read state");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW := _InitError;
          end_if;
        //*****************************************************
        _valid:
          if ( sStateFirmware.DataLength = (sizeof(t_StateFirmware) - sizeof(t_StateFirmware.CRC) - sizeof(t_StateFirmware.DataLength)) ) |
             ( sStateFirmware.DataLength = (sizeof(t_StateFirmware) - sizeof(t_StateFirmware.CRC) - sizeof(t_StateFirmware.DataLength) - 
                sizeof(t_StateFirmware.MessageCounter) - sizeof(t_StateFirmware.reserved)) )
          then
            if (sStateFirmware.CRC = CheckSum_16(pData:= #sStateFirmware.FirmwareVersion, uiDataLength:= sStateFirmware.DataLength, uiCrcStart:=16#FFFF)) then
              FirmwareVersion := (sStateFirmware.FirmwareVersion and 16#0000FFFF)$HDINT;
              eInitSSW         := _Finish;
              eResponseState   := _idle;
              
              if FirmwareVersion >= AI088_FIRMWARE_VERSION_INT_TEMP_REF then              
                if sStateFirmware.MessageCounter <> sCfgFirmware.MessageCounter then                
                  eModuleInitState := ERROR;
                  LogError("@ZZZZ (AI088::InitModule) Invalid message counter from Firmware");
                  eInitState := _ClientNotready;
                end_if;
              end_if;
            else
              eModuleInitState := ERROR;
              LogError("@ZZZZ (AI088::InitModule) Invalid checksum at firmware info");
              eInitState := _ClientNotready;
            end_if;
          else
              eModuleInitState := ERROR;
              LogError("@ZZZZ (AI088::InitModule) Invalid length at firmware info");
              eInitState := _ClientNotready;
          end_if;
      end_case;
      
//**********************************************************************************************************************************************************
    _Finish:
      eInitSSW         := _InitVariables;
      eModuleInitState := READY;
      eInitState      := _ClassOk;
      
//**********************************************************************************************************************************************************
    _InitError:
      eModuleInitState := ERROR; 
      eInitState      := _ClientNotready;
      
//**********************************************************************************************************************************************************
  END_CASE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI088::CheckDeviceID
	VAR_INPUT
		udID2Check 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bIsOK 	: BOOL;
	END_VAR
  
	//look if it is right hardware
	if ( udID2Check <> DEVICE_ID_AI088 ) then
		bIsOK := FALSE;
	else
    bIsOK := TRUE;
	end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI088::DisconnectEvent

  SdiasBase::DisconnectEvent();
  
END_FUNCTION


FUNCTION AI088::AI088
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
  
	ret_code := C_OK;

END_FUNCTION


FUNCTION VIRTUAL AI088::GetTaskCfg
	VAR_OUTPUT
		TaskCfg 	: BDINT;
	END_VAR

  TaskCfg := SDIAS_TASK_MASK_RT_PRE;

END_FUNCTION


FUNCTION VIRTUAL AI088::GetDeviceID
	VAR_OUTPUT
		output 	: UDINT;
	END_VAR

  output := DEVICE_ID_AI088;

END_FUNCTION


FUNCTION VIRTUAL AI088::GetFWVersion
	VAR_INPUT
		pData 	: ^CHAR;
		Length 	: UDINT;
	END_VAR

  //Check pointer
  if pData then
    //Length of Firmwareversion (HDINT) -> 8Byte +1 byte zero termination
    if Length >= 9 then
      _itoa(udNumber:=FirmwareVersion, pString:=pData);  
    else
      pData^ := 0;
    end_if; 
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI088::AddAccesses
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR

  eModuleInitState := READY;
    
  if  (TMP_1RefSensor = 2) | (TMP_2RefSensor = 2) |(TMP_3RefSensor = 2) | (TMP_4RefSensor = 2) |
      (TMP_5RefSensor = 2) | (TMP_6RefSensor = 2) |(TMP_7RefSensor = 2) | (TMP_8RefSensor = 2)
  then
    // internal KTY is configured
    b_InternalKTYConfigured := TRUE;
    // at lest one internal KTY is configured so the additional read access for the data is installed
    // additonal access begins to read at end of t_ReadData
    if AddRdAccess(hOffset            := AI088_ADDR_CYC_READ + sizeof(t_ReadData)
               , uLength              := sizeof(t_ReadDataInt)
               , ppData               := #pReadDataInt
               , ppStateByte          := #sReadAccessCycInt.pStateByte
               , ppControlByte        := #sReadAccessCycInt.pControlByte
               , pAccessHandle        := #sReadAccessCycInt.AccessHandle
               , WaitForAccessHandle  := 0
               ) <> READY then
               
      eModuleInitState := ERROR;
      LogError("@ZZZZ (AI088::AddAccesses) Adding read access for intern kty sensor failed");
    end_if;  
  end_if;

END_FUNCTION